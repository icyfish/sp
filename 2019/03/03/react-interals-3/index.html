<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> React Internals(3) · spicyfish</title><meta name="description" content="React Internals(3) - icyfish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="spicyfish"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React Internals(3)</h1><div class="post-info">Mar 3, 2019</div><div class="post-content"><p><a href="https://www.mattgreer.org/articles/react-internals-part-three-basic-updating/" target="_blank" rel="noopener">React Internals, Part Three: basic updating</a></p>
<p>第一个章节中, 只谈到了第一次的 render, 后续重新渲染的情况并未被提及. 这一张会针对这种情况进行阐述, 主要是关于 React 的虚拟 DOM 的工作机制.</p>
<h2 id="简单的更新"><a href="#简单的更新" class="headerlink" title="简单的更新"></a>简单的更新</h2><p>在 React app 中, 大部分情况下我们调用<code>setState()</code>来更新 app 的状态. React 同时还支持通过调用<code>React.render()</code>来更新状态. 看下面的例子:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.render(&lt;h1&gt;hello&lt;/h1&gt;, root);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  React.render(&lt;h1&gt;hello again&lt;/h1&gt;, root);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>我们暂时把<code>setState()</code>放在一边(第四章节会谈到), 现在先通过<code>Feact.render()</code>实现状态的更新. 这种方式实现的更新是通过 props 改变引起的更新. Truth be told, this is simply “props have changed so update”, which also happens if you render again and pass different props down to a child component. We just happen to be causing the props change through Feact.render().</p>
<h2 id="实现更新"><a href="#实现更新" class="headerlink" title="实现更新"></a>实现更新</h2><p>The concept is pretty simple, Feact.render() just needs to check if it has rendered before, and if so, update the page instead of starting fresh.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  render(element, container) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevComponent = getTopLevelComponentInContainer(container);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prevComponent) &#123;</span><br><span class="line">      <span class="keyword">return</span> updateRootComponent(prevComponent, element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> renderNewRootComponent(element, container);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderNewRootComponent</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrapperElement = Feact.createElement(TopLevelWrapper, element);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> FeactCompositeComponentWrapper(wrapperElement);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> FeactReconciler.mountComponent(componentInstance, container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTopLevelComponentInContainer</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// need to figure this out</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateRootComponent</span>(<span class="params">prevComponent, nextElement</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// need to figure this out too</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来十分合理, 如果组件之前已经被 render 过, 则获取前一次 render 时的状态, 再获取新的更新后的状态, 传入相关方法中对比两次的更新再进行判断是否要执行 DOM 的更新. 如果没有前一次 render, 则该次为第一次 render, 执行之前两个章节部分的代码.</p>
<p>现在看看如何实现<code>getTopLevelComponentInContainer</code>和<code>updateRootComponent</code></p>
<h2 id="记下每一次-render-时的状态"><a href="#记下每一次-render-时的状态" class="headerlink" title="记下每一次 render 时的状态"></a>记下每一次 render 时的状态</h2><p>对于每一次的 render, 我们都需要存储所创建的组件, 这样下一次更新时才知道哪些部分是新的内容. 那么要把它们存在哪里呢? 为什么不存在它们所创建的 DOM 节点中?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderNewRootComponent</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> wrapperElement = Feact.createElement(TopLevelWrapper, element);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> FeactCompositeComponentWrapper(wrapperElement);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> markUp = FeactReconciler.mountComponent(componentInstance, container);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new line here, store the component instance on the container</span></span><br><span class="line">  <span class="comment">// we want its _renderedComponent because componentInstance is just</span></span><br><span class="line">  <span class="comment">// the TopLevelWrapper, which we don't need for updates</span></span><br><span class="line">  container.__feactComponentInstance = componentInstance._renderedComponent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> markUp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这样获取暂存的组件实例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTopLevelComponentInContainer</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> container.__feactComponentInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Feact.render(Feact.createElement(<span class="string">"h1"</span>, <span class="literal">null</span>, <span class="string">"hello"</span>), root);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Feact.render(Feact.createElement(<span class="string">"h1"</span>, <span class="literal">null</span>, <span class="string">"hello again"</span>), root);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>2 秒之后, 我们会重新调用<code>Feact.render()</code></p>
<p>Since Feact determined this is an update, we ended up in updateRootComponent, which is just going to delegate to the component</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateRootComponent</span>(<span class="params">prevComponent, nextElement</span>) </span>&#123;</span><br><span class="line">  prevComponent.receiveComponent(nextElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在这里我们没有凭空创建一个新的组件, <code>prevComponent</code>是在第一次render时被创建的. 现在它接受一个新的组件然后根据新组件的修改状态更新自己. 组件在mount时被创建, 直到unmount它的生命周期结束.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeactDOMComponent</span> </span>&#123;</span><br><span class="line">  receiveComponent(nextElement) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevElement = <span class="keyword">this</span>._currentElement;</span><br><span class="line">    <span class="keyword">this</span>.updateComponent(prevElement, nextElement);</span><br><span class="line">  &#125;</span><br><span class="line">  updateComponent(prevElement, nextElement) &#123;</span><br><span class="line">    <span class="keyword">const</span> lastProps = prevElement.props;</span><br><span class="line">    <span class="keyword">const</span> nextProps = nextElement.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.receiveComponent(lastProps, nextProps);</span><br><span class="line">    <span class="keyword">this</span>._updateDOMChildren(lastProps, nextProps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._currentElement = nextElement;</span><br><span class="line">  &#125;</span><br><span class="line">  _updateDOMProperties(lastProps, nextProps) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _updateDOMChildren(lastProps, nextProps) &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>receiveComponent</code> 配置好 updateComponent, 最终调用<code>_updateDOMProperties</code>与<code>_updateDOMChildren</code>这两个真正有效的方法使真实DOM更新. </p>
<p><code>updateDOMProperties</code>与更新CSS样式相关. 在这系列文章中我们不会对该方法有过多的阐释. </p>
<p><code>updateDOMChildren</code>方法在React中相对比较复杂, 处理了很多种不同的情况. 但是在<code>Feact</code>中, children 仅仅是</p>
<p>TO BE Continued</p>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2019/06/27/element-in-view/" class="prev">PREV</a><a href="/posts/2019/03/03/react-interals-2/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 <a href="https://icyfish.github.io/posts">icyfish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>