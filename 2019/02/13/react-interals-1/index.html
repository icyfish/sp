<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="IDYUPnBNhdnU8o9LRNKZ1RSt14tIxTI0rLeMrBtswXw"><title> React Internals(1) · spicyfish</title><meta name="description" content="React Internals(1) - icyfish"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/posts/favicon.png"><link rel="stylesheet" href="/posts/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://icyfish.github.io/posts/atom.xml" title="spicyfish"></head><body><div class="wrap"><header><a href="/posts/" class="logo-link"><img src="/posts/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/posts/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/posts/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/posts/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="http://twitter.com/icyfish_" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">React Internals(1)</h1><div class="post-info">Feb 13, 2019</div><div class="post-content"><p><a href="https://www.mattgreer.org/articles/react-internals-part-one-basic-rendering/" target="_blank" rel="noopener">React Internals</a></p>
<h2 id="背景-元素和组件"><a href="#背景-元素和组件" class="headerlink" title="背景: 元素和组件"></a>背景: 元素和组件</h2><p>React 核心, 包含三类实体: 原生 DOM 元素, 虚拟元素以及组件.</p>
<h3 id="原生-DOM-元素"><a href="#原生-DOM-元素" class="headerlink" title="原生 DOM 元素"></a>原生 DOM 元素</h3><p>不需要过多解释, React 内部调用浏览器原生 API<code>document.createElement()</code>创建, 使用<code>element.insertBefore()</code>, <code>element.nodeValue</code>等更新.</p>
<h3 id="虚拟-React-元素"><a href="#虚拟-React-元素" class="headerlink" title="虚拟 React 元素"></a>虚拟 React 元素</h3><p>在源码中直接称其为”element”(元素), 可以用来表示原生 DOM 节点, 也能表示<br>A virtual React element (just called an “element” in the source code), is an in memory representation of what you’d like a given DOM element (or entire tree of elements) to be for a particular render. An element can either directly represent a DOM element such as h1, div, etc. Or it can represent a user defined composite component, which is explained below.</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>在 React 中是个很常见的术语, 有各种不同类型, 不同用处. 例如, <code>ReactDOMComponent</code>在 ReactDOM 中用来关联 React 元素以及相应的 DOM 元素.</p>
<h3 id="用户定义的组合组件"><a href="#用户定义的组合组件" class="headerlink" title="用户定义的组合组件"></a>用户定义的组合组件</h3><p>实际上指的就是我们使用<code>React.createClass()</code>或<code>React.Component</code>创建的 React 组件. It turns out our view of the component lifecycle with methods like componentWillMount, shouldComponentUpdate is just one piece of the puzzle. 这些是生命周期函数是提供给用户使用的. React 组件本身其实还有其他的生命周期函数, 例如: <code>mountComponent</code>与<code>receiveComponent</code>. 我们不知道这些生命周期函数的存在, 因为我们没有必要使用它们, 这是 React 内部使用的生命周期钩子.</p>
<blockquote>
<p>用户所创建的组件其实是不完整的. React 会处理这些组件, 将其包裹在 <code>ReactCompositeComponentWrapper</code>中, 这之后我们的组件才有了完整的生命周期和能力.</p>
</blockquote>
<h2 id="React-是声明式的"><a href="#React-是声明式的" class="headerlink" title="React 是声明式的"></a>React 是声明式的</h2><p>当我们需要创建组件时, 会先定义组件<code>classes</code>. 不过并没有对其进行实例化. React 内部会帮我们执行实例化的操作.</p>
<p>同时我们也不会手动实例化元素, 不过实际上在我们使用 JSX 创建元素的时候, 已经对其进行实例化了:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;hello&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上会被编译器编译成以下代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="A-tiny-fake-React-called-Feact"><a href="#A-tiny-fake-React-called-Feact" class="headerlink" title="A tiny, fake React called Feact"></a>A tiny, fake React called Feact</h2><p>了解了一些基础之后, 我们实现一个自己版本的 React, 叫做”Feact”. 然后用我们的<code>Feact</code>来创建一个 app:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Feact.render(&lt;h1&gt;hello world&lt;/h1&gt;, <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>));</span><br></pre></td></tr></table></figure>
<p>我们暂时不使用 JSX, 后面会解释它是如何实现的, 在解释 JSX 之前, 我们先使用<code>Feact.createElement</code>来创建元素:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Feact.render(</span><br><span class="line">  Feact.createElement(<span class="string">"h1"</span>, <span class="literal">null</span>, <span class="string">"hello world"</span>),</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>现在看看, <code>createElement</code>这个 API 是如何实现的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">  createElement(type, props, children) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = &#123;</span><br><span class="line">      type,</span><br><span class="line">      props: props || &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (children) &#123;</span><br><span class="line">      element.props.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Elements(元素)实际上就是对象, 表示我们所想要渲染的内容.</p>
<h3 id="Freact-render"><a href="#Freact-render" class="headerlink" title="Freact.render()"></a>Freact.render()</h3><p>调用<code>Freact.render()</code>方法, 传入参数: 我们想要渲染的元素以及希望该元素展示的位置. 这是 Feact app 的起点. 首先, 我们试着实现<code>render()</code>方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">  createElement() &#123;</span><br><span class="line">    <span class="comment">/* as before */</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render(element, container) &#123;</span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> FeactDOMComponent(element);</span><br><span class="line">    <span class="keyword">return</span> componentInstance.mountComponent(container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当<code>render</code>方法执行结束之后, 我们就有了一个已完成页面. 基于此, 可以知道 FeactDOMComponent 是为我们创建 DOM 的底层方法. 我们试着实现这个方法.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeactDOMComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>._currentElement = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mountComponent(container) &#123;</span><br><span class="line">    <span class="keyword">const</span> domElement = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>._currentElement.type);</span><br><span class="line">    <span class="keyword">const</span> text = <span class="keyword">this</span>._currentElement.props.children;</span><br><span class="line">    <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(text);</span><br><span class="line">    domElement.appendChild(textNode);</span><br><span class="line"></span><br><span class="line">    container.appendChild(domElement);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._hostNode = domElement;</span><br><span class="line">    <span class="keyword">return</span> domElement;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>mountComponent</code> 在<code>this._hostNode</code>中存储了它所创建的 DOM 元素, 在第一部分中我们不需要 hostNode, 但在后面的章节中会用到.</p>
</blockquote>
<h2 id="添加自定义组件"><a href="#添加自定义组件" class="headerlink" title="添加自定义组件"></a>添加自定义组件</h2><p>要完成一个页面, 一个硬编码的节点肯定不足够. 我们现在要定义一个类给用户创建自定义组件.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">    createClass(spec) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.props = props;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor.prototype.render = spec.render;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Constructor;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render(element, container) &#123;</span><br><span class="line">        <span class="comment">// our previous implementation can't</span></span><br><span class="line">        <span class="comment">// handle user defined components,</span></span><br><span class="line">        <span class="comment">// so we need to rethink this method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyTitle = Feact.createClass(&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> Feact.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="keyword">this</span>.props.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Feact.render(&#123;</span><br><span class="line">    Feact.createElement(MyTitle, &#123; <span class="attr">message</span>: <span class="string">'hey there Feact'</span> &#125;),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们将组件类作为参数传入<code>createElement</code>. element 可以是原生的 DOM 节点, 也可以是复合组件. 两者的区别是: 如果<code>type</code>为字符串, 则是原生 DOM 元素, 如果<code>type</code>是函数, 则是复合组件.</p>
<h3 id="改进-Feact-render"><a href="#改进-Feact-render" class="headerlink" title="改进 Feact.render()"></a>改进 Feact.render()</h3><p>之前实现的<code>Feact.render()</code>已经无法满足我们现在的需求, 因为它无法处理用户自定义组件. 我们这样完善它:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Feact = &#123;</span><br><span class="line">  render(element, container) &#123;</span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> FeactCompositeComponentWrapper(element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> componentInstance.mountComponent(container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeactCompositeComponentWrapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>._currentElement = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mountComponent(container) &#123;</span><br><span class="line">    <span class="keyword">const</span> Component = <span class="keyword">this</span>._currentElement.type;</span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> Component(<span class="keyword">this</span>._currentElement.props);</span><br><span class="line">    <span class="keyword">const</span> element = componentInstance.render();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> domComponentInstance = <span class="keyword">new</span> FeactDOMComponent(element);</span><br><span class="line">    <span class="keyword">return</span> domComponentInstance.mountComponent(container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们给予用户自定义组件的能力, Feact 现在可以根据用户提供的属性值动态创建 DOM 节点. 这部分的完善改动有点大, 如果觉得难以理解的话, 可以从<code>componentInstance.render()</code>找到一点头绪.</p>
<blockquote>
<p>注意<code>FeactCompositeComponentWrapper</code>是如何直接创建<code>FeactDOMComponent</code>的. 但两者的耦合度太高, 我们后续会对这部分进行优化. If React was this tightly coupled, it’d only ever be able to build web apps. Keeping <code>ReactCompositeComponentWrapper</code> in the dark about other component types surely made building React Native easier.</p>
</blockquote>
<h3 id="对复合组件的优化"><a href="#对复合组件的优化" class="headerlink" title="对复合组件的优化"></a>对复合组件的优化</h3><p>现在我们的复合组件的返回值必须为原生 DOM 元素, 不可以使其他复合组件. 因此需要进行优化:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyMessage = Feact.createClass(&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.props.asTitle) &#123;</span><br><span class="line">            <span class="keyword">return</span> Feact.createElement(MyTitle, &#123;</span><br><span class="line">                message: <span class="keyword">this</span>.props.message</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Feact.createElement(<span class="string">'p'</span>, <span class="literal">null</span>, <span class="keyword">this</span>.props.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复合组件的<code>render()</code>函数会判断传入的属性以决定是返回原生 DOM 元素还是复合组件. 上面的代码片段利用<code>asTitle</code>的值作为判断标准, 但现在当<code>asTitle</code>为 true 的时候, <code>FeactDOMComponent</code>接收的参数并非原生 DOM 元素, 之前的实现就无法满足我们的需求. 因此我们来实现一个<code>FeactCompositeComponentWrapper</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeactCompositeComponentWrapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>._currentElement = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mountComponent(container) &#123;</span><br><span class="line">    <span class="keyword">const</span> Component = <span class="keyword">this</span>._currentElement.type;</span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> Component(<span class="keyword">this</span>._currentElement.props);</span><br><span class="line">    <span class="keyword">let</span> element = componentInstance.render();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">typeof</span> element.type === <span class="string">"function"</span>) &#123;</span><br><span class="line">      element = <span class="keyword">new</span> element.type(element.props).render();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> domComponentInstance = <span class="keyword">new</span> FeactDOMComponent(element);</span><br><span class="line">    domComponentInstance.mountComponent(container);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 我们当前的实现只是用于讲解便于理解概念, 实现方式上有很多优化空间. 在上述代码中, 我们重复调用 render 直到它返回的是原生 DOM 元素. 这种方法不够好, 因为这些子元素需要参与完整的生命周期. 例如, 我们需要提供<code>componentWillMount</code>这个生命周期的 API 给用户, 如果以上面的形式实现, 就没办法提供这个 API.</p>
</blockquote>
<h3 id="完善-Feact-render"><a href="#完善-Feact-render" class="headerlink" title="完善 Feact.render()"></a>完善 Feact.render()</h3><p>第一个版本的<code>Feact.render()</code>只能处理原生 DOM 元素, 第二个版本只能处理复合元素. 它应该有处理两种情况的能力. 我们现在实现一个”工厂”函数, 根据元素的类型创建为我们创建不同的元素类型. (这个实现方式与 React 本身的实现方式不一致). <code>FeactCompositeComponentWrapper</code>组件最终生成的还是<code>FeactDOMComponent</code>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TopLevelWrapper = <span class="function"><span class="keyword">function</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TopLevelWrapper.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Feact = &#123;</span><br><span class="line">  render(element, container) &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapperElement = <span class="keyword">this</span>.createElement(TopLevelWrapper, element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> componentInstance = <span class="keyword">new</span> FeactCompositeComponentWrapper(</span><br><span class="line">      wrapperElement</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>ToplevelWrapper</code>是用<code>Feact.createClass()</code>定义的复合组件. 它的<code>render</code>方法返回了用户提供的组件. 因为<code>ToplevelWrapper</code>被包裹在<code>FeactCompositeComponentWrapper</code>中, 不需要在意用户传入的是什么元素. </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Feact现在可以渲染一些简单的组件, 这篇文章大概概括了有关React的render的概念, 但是在实际的实现上有更多更完善的考虑, 比如: 事件绑定, 视窗的滚动距离, 性能等等. </p>
<h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><ul>
<li>constructor 0214</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/posts/2019/02/14/constructor/" class="prev">PREV</a><a href="/posts/2017/08/25/js-frameworks/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 <a href="https://icyfish.github.io/posts">icyfish</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>