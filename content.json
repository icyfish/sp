{"pages":[{"title":"","text":"404 Not Found","link":"/posts/404.html"},{"title":"About","text":"未经审视的人生不值得一过","link":"/posts/about/index.html"}],"posts":[{"title":"变量的作用域","text":"变量的作用域是程序源代码中定义这个变量的区域.全局变量拥有全局作用域,在JavaScript代码中的任何地方都有定义. 在一些类似C语言的编程语言中,大括号内的每一段代码都有各自的作用域,变量只在作用域之内有效,在其外部不可见,这种作用域叫做块级作用域,但JavaScript没有块级作用域的概念,只有函数作用域,即在函数内部声明的变量只在函数体内有定义,是局部变量,函数参数也是局部变量,只在函数体内有定义.在其他大括号内的变量并不是局部变量. 代码+解析: 1234var a = 1;window.a; // 1a; // 1window.a === a // true var a = 1;在全局环境下(此时为浏览器)声明了一个全局变量a,所以a是浏览器全局对象window的一个属性[注2],故window.a和a的值相等. 12345function foo(){ var b = 2;}foo();console.log(b); // b is not defined foo函数内部相当于子作用域,变量b只在foo函数内的作用域存在,在foo函数外部无法获取b的值,故返回not defined. 123456var a = 1;function foo(){ var b = 2; console.log(a);}foo(); // 1 函数内部可以获取外部的变量值.[注1]故输出a的值为1. 1234567var a = 1;function foo(){ var a = 2; console.log(a);}foo(); // 2console.log(a); // 1 上述代码出现了命名冲突,在全局环境和函数内都声明了a变量,这时在函数内执行console.log(a);不会到外部寻找a,因为内部已经声明了a. 如果想要获得外部变量a,可以在foo内执行console.log(window.a);这时返回值就是外部的a变量值.因此作用域的存在可以解决命名冲突问题. 而如果在函数foo外部(此时是全局环境)中输出a的值,输出的就是在全局环境中定义的a值,即为1. 123456var a = 1;function foo(){ a = 2;}foo();console.log(a); // 2 函数内部没有对a进行声明,所以调用foo();会跑到函数外部寻找var a=,此时函数外部声明了a变量,而函数内部的a=2因为缺少var关键字会修改外部函数中a的值.因为不对变量加关键词var相当于创建了一个全局变量,会污染全局环境.程序中的每个部分都能获取这个值.(用”use strict”能防止全局环境被污染,返回a is not defined.) 12345function foo(){ a = 2;};foo();console.log(a); // 2 这时调用foo,函数外部并没有声明a变量,如果第一层外部函数没有声明a,还会再跑到外部直至全局环境,如果多层函数均没有对a进行声明,那么内部函数就会自己创建一个a变量(全局变量)并将值设为函数内部未声明的a的值,上述情况就是2. 1234function foo(){ a = 2;}console.log(a); // a is not defined 函数内的变量在函数被调用之后才存在,在函数被调用之前,a变量是不存在的,所以返回a is not defined. 12345function foo(){ a = 2;}foo();console.log(a); // 2 函数在首次调用时,a变量会被创建,因为内部外部都没有对其进行声明,a就变成了全局变量 参数和作用域代码+解析: 1234567var a = 1;function foo(a){ console.log(a); a = 2;}foo(a); // 1console.log(a); // 1 foo(a)相当于foo(var = a), 调用foo(a),执行其内部的console.log(a)时,会在函数内部console.log语句之前寻找a的值,在这个情况下无法找到,因为此时还未对a进行赋值,但会跑到函数外部寻找a的赋值语句,于是找到了a = 1,因此foo(a)输出1. 而在foo函数外部的console.log(a);会直接在外部寻找a的值,尽管函数内部为a = 2没有var关键字而且被调用过,但是在foo(a)内传入参数a相当于声明了变量,所以不会污染全局环境,因此第二次弹出的也为1. 1234567var a = 1;function foo(a){ console.log(a); a = 2;}foo(); // undefinedconsole.log(a); // 1 这段代码与第一段代码唯一的不同是调用foo()时没有传入参数,而在对函数进行定义时设定了参数a,这时JavaScript引擎会自动将a设定为undefined[注3].第二句的console.log(a);中a就是指全局变量a的值,即为1. 1234567var a = 1;function foo(){ console.log(a); a = 2;}foo(); // 1console.log(a); // 2 foo函数在定义和调用时均没有声明a,但函数内部需要执行console.log(a),所以会跑到外部寻找a的值,正好外部声明了a其值为1,所以输出的就是1,接下来执行的a=2;污染了全局环境,将a值修改为2.因此第二句输出的值为2. 1234567var a = 1;function foo(a){ console.log(a); a = 2;}foo(a); //1console.log(a); //1 调用foo(a),在函数内部声明了var a;,但内部的console.log(a);之前没有赋值语句,所以会跑到外部获取a的值,因此输出1.第二句console.log(a);弹出的值就是全局变量a的值,因为函数内部声明了a,所以没有污染全局环境. 变量声明提前JavaScript函数内部声明的所有变量(不涉及赋值)都会被”提前”至函数体的顶部. 代码+解析: 12345678910var a = 123;function f() { console.log(a); var a = 1; console.log(a);}f();// undefined// 1 由于声明提前,可以将上述代码转换为: 1234567891011var a = 123;function f() { var a; console.log(a); a = 1; console.log(a);}f();// undefined// 1 那么第一次输出undefined就是因为声明了a但未对其赋值,第二次赋了值1之后自然就会弹出a为1. 外部声明的a值对输出值没有影响是因为在函数体内局部变量的优先级高于同名的局部变量. 由于变量提升,最好是在函数体的顶部声明函数中可能用到的所有变量. 参考 《JavaScript编程精解2》:函数的参数如同一个普通变量,但其初始值是由函数的调用者提供的,而不是函数自身的内部代码.函数有一个重要属性,就是其内部创建的变量以及参数,都属于函数的局部变量.但只有参数和在函数体内使用关键字var声明的变量才属于函数的局部变量.由于在函数外部生命的任何变量在整个程序当中都是可见的,因此我们把这些变量称为全局变量.在函数内部,我们同样可以访问这些变量,只要确保函数中没有声明过同名的局部变量即可. 《JavaScript权威指南》:当声明一个JavaScript全局变量时,实际上是定义了全局对象的一个属性.对局部变量没有如此规定. 《JavaScript面向对象编程指南2》:定义一个函数时,可以指定该函数调用时所需的参数,当然也可以不指定.但如果指定参数之后,却在调用时忘了传递相关参数值,JavaScript引擎就会将参数自动设定为undefined.","link":"/posts/2016/09/02/scope-of-variables/"},{"title":"JavaScript中四种函数调用模式","text":"在JavaScript中对函数进行调用有多种方式, 以下是对四种函数调用模式的介绍, 以及call, apply, bind的区别. 方法调用当一个函数被保存为对象的一个属性时,我们称它为一个方法,当一个方法被调用时,this被绑定到该对象. 123456789101112131415//创建myObject.它有一个value属性和一个increment方法.//increment方法接受一个可选的参数.如果参数不是数字,那么默认使用数字1.var myObject = { value: 0, increment: function (inc){ this.value += typeof inc === 'number' ? inc : 1; }};myObject.increment();console.log(myObject.value); // 1myObject.increment(2);console.log(myObject.value); // 3 this直接修改了该对象的value属性,所以第二次调用increment是在value == 1的基础上增加. 函数调用此模式为最常见的调用模式. 12345function showThis(){ return this;}showThis();//返回Window{...} 当函数以此模式调用时,this被绑定到全局对象.在浏览器中,全局对象为Window.this绑定到全局对象是语言设计上的一个错误,当内部函数被调用时,this应该仍然绑定到外部函数的this变量.这个设计错误的后果是方法不能利用内部函数来帮助它工作,因为内部函数的this被绑定了错误值,不能共享该方法对对象的访问权,不过有个很容易的解决方案,在对象的方法内定义一个变量并给它赋值为this,那么内部函数就能通过那个变量访问到this. 123456789101112131415161718192021222324252627var myObject = { value: 0, increment: function (inc){ this.value += typeof inc === 'number' ? inc : 1; }, getValue: function(){ return this.value; }};function add(a,b){ return a+b;};myObject.double = function (){ var that = this; //解决方法 var helper = function(){ that.value = add(that.value,that.value); //alert(this); //用以测试this的值,在浏览器中会弹出object Window }; helper(); //以函数形式调用helper}myObject.increment();myObject.increment(2);myObject.double();console.log(myObject.getValue()); //6 上例在给myObject增加double方法的函数中创建了一个内部函数helper,但helpler无法直接用this访问到myObject对象中的value属性,因为在helper中this为全局对象,可以在helper中添加alert(this)测试.为了让helper访问到外部函数myObject.double的this值,定义了一个变量that来保存this值,这个this值为myObject. 构造器调用如果在一个函数前面带上new来调用,那么将创建一个隐藏连接到该函数的prototype成员的新对象,同时this将会被绑定到那个新对象上. 12345678910111213//创建一个名为Quo的构造器函数,它构造一个带有status属性的对象.var Quo = function(string){ this.status = string;};//给Quo的所有示例提供一个名为getStatus的公共方法.Quo.prototype.getStatus = function(){ return this.status;}//构造一个Quo实例var myQuo = new Quo(\"confused\")console.log(myQuo.getStatus()); call调用和apply调用因为JavaScript是一门函数式的面向对象编程语言,所以函数也是对象,可以拥有方法. bind(), apply(), call() 123456789101112131415161718192021222324252627var person = { firstname: 'John', lastname: 'Doe', getFullName: function(){ var fullname = this.firstname + \" \" + this.lastname; return fullname; }}var logName = function(lang1, lang2){ console.log(this); console.log('Logged: ' + this.getFullName());}var logPersonName = logName.bind(person); // {1}// logName(); //Error: this.getFullName is not a function at logName // {2}logPersonName(); // Logged: John Doe// var logName = function(lang1, lang2){// console.log('Logged: ' + this.getFullName());// }.bind(person); // {3}logName.call(person, 'en', 'es');logName.apply(person, ['en', 'es']); 行{1}利用bind方法, 在参数内传入person对象, 将this值绑定到person, 此时getFullName()就可以正常执行. 如果像行{2}那样直接执行, 那么this指向的就是全局对象window, 而window中没有定义firstname,getFullName(),lastname, 因此会抛出错误. 还可以像行{3}那样绑定this. bind方法返回一个新的函数, 是原函数的拷贝. call和apply直接调用函数执行 在call和apply中传入的第一个参数为this需要绑定到的对象, 后面为传入函数的参数, call和apply唯一的区别就是传入apply中的参数为数组. call和apply第二个及之后的参数是可选参数, 也可以不传入直接执行. 应用 function borrowing123456789101112131415var person = { firstname: 'John', lastname: 'Doe', getFullName: function(){ var fullname = this.firstname + ' ' + this.lastname; return fullname; }}var person2 = { firstname: 'Jane', lastname: 'Doe'}console.log(person.getFullName.apply(person2));console.log(person.getFullName.call(person2)); 利用apply和call从person对象中’借’getFullName方法. function currying函数柯里化: 1234567891011121314151617181920212223function multiply(a,b){ return a*b;}var multiplyByTwo = multiply.bind(this, 2);var multiplyByThree = multiply.bind(this, 3);console.log(multiplyByTwo(2)); // 4//给bind()传入第二个参数,第二个参数成为函数对象第一个参数的默认值,// multiplyByTwo相当于:// function multiplyByTwo(b){// var a = 2;// return a * b;// }// 也可以传入多个参数console.log(multiply.bind(this, 2, 3)()); // 6 柯里化: 创建函数的拷贝, 在该拷贝中传入部分预设参数(creating a copy of a function but with some preset parameters), 常用于有许多有关数学计算的场景中.","link":"/posts/2016/08/20/function-invocation/"},{"title":"类型, 运算符","text":"JavaScript的变量类型是动态类型, 因此语言中会有很多强制转换的情况发生. 运算符实际上是一种特殊的函数. 动态类型 Dynamic Typing:在JavaScript中,定义一个变量时,不需要显式声明变量的类型,JS引擎在代码运行时会自动识别变量类型,所以在程序执行时,一个变量在不同时间可以拥有不同的类型. Java, C#的变量类型是静态的(Static Typing), 即需要显式声明变量类型,而且在程序执行过程中类型不可改变. Static Typing: bool isNew = &quot;hello&quot;; 会提示错误. Dynamic Typing: 123var isNew = true; // 没有错误isNew = 'yup!';isNew = 1; 原始类型 Primitive Types:原始类型(定义): A type of data that represents a single value. (在JS中也就是: 不是对象,不存在方法) JS中有6种原始类型: 1. undefined: (represents lack of existence), undefined是JavaScript语言中的一个特殊值,变量的值是undefined表明这个变量未被赋值. 不要手动将变量值设为undefined!! 因为在调试时会出现混乱,不知道是自己将变量设置为undefined还是变量未被赋值. 2. null: (also represents lack of existence), 可以手动将变量值设置为null. 3. boolean 4. number: 在JavaScript中只有这一种类型()来表示数字, 不像其他编程语言, 有整数, 浮点数, 定点数等. 5. string 6. symbol: ECMAScript 2015中新加入的类型 运算符 operators运算符实际上是一种特殊的函数, 只是在句法结构上与一般的函数不同, 一般来说, 运算符接受两个参数, 返回一个结果. 1var a = 3 + 4; +是运算符, 实际上是一个函数对于上述代码, JS引擎实际是这样执行的: 123function +(a,b){ return // 返回 a + b 的结果} 那么如果想要调用这个函数, 就该这样做 +(3,4);, 但是这样太过麻烦, 为了简便JS引擎实现了 中缀标记法(infix notation), 于是就可以用这种形式调用函数 3+4; 运算符优先级运算符优先级指哪个运算符会被先调用, 即最先执行. 关联性Associativity关联性决定了拥有相同优先级的运算符的执行顺序, 如果与左边关联性较强, 那么先执行左边的部分, 反之同理. 具体的优先级和关联性详见Operator Precedence中的表格. 强制转换 coercion将某一类型的变量强制转换成另一种类型, 因为JS是Dynamic Typing, 所以强制转换在语言中很常见. 强制转换包括隐式强制转换和显式强制转换. 详见 隐式强制转换: 123var a = 1 + '2';console.log(a);//'12' 在内存中1和'1'完全不同, 但在函数执行过程中JS引擎将数字1强制转换为字符. 在一些其他语言中会抛出错误. 123456789101112console.log(3 &lt; 2 &lt; 1);// true// 因为优先级相同, `&lt;`是左关联性较强的操作符, `3 &lt; 2`返回false// 所以实际上是 `false &lt; 1` 的比较, 布尔值会被强制转换为数字// false被强制转换为0, `0 &lt; 1` 自然返回trueconsole.log(1 &lt; 2 &lt; 3);// true// 返回true的原因并不是1小于2小于3// 而是 `1 &lt; 2` 返回true// true被强制转换为1, `1 &lt; 3`// 因此最终结果为true 12345678910null == 0;// falsenull &lt; 1;// truefalse == 0;// true\"\" == 0;// true\"\" == false;// true 强制转换功能强大, 但也很危险. 用 ===(严格相等) 来比较值不会进行强制转换, 因此在比较值时, 多用 === 而不是 ==. JavaScript中的相等性判断 显式强制转换: 123456789101112Number(true);// 1Number(false);// 0Number(undefined);// NaN Number(null);// 0Boolean(0);// falseBoolean(1);// true 存在性和布尔值表示不存在含义的值会被强制转换为false, 如undefined, null, &quot;&quot;.因此可以利用coercion判断某个变量的存在性. 123456var a;if (a) { console.log('something is there.');}// 不会有输出, 因为a被强制转换为false. 如果a为undefined, null, &quot;&quot;中任意一个, 程序就不会有输出, 有个例外情况, 若a的值为0, 程序也不会有输出, 但0并不是不存在. 可以这样改进: 1234567var a;a = 0;if (a || a === 0) { console.log('something is there.');} 默认值123456789function greet(name){ console.log('Hello '+ name);}greet('Tony');// 'Hello Tony';greet();// 若不传入参数, 很多其他编程会抛出错误// 但是JavaScript这样输出:// 'Hello undefined'; 可以这样改进: 12345function greet(name){ name = name || '&lt;Your name here&gt;'; console.log('Hello '+ name);}greet(); 运用ES6的改进方式: 1234const greet = (name='&lt;Your name here&gt;') =&gt; { console.log(`Hello ${name}`);}greet(); 参考 JavaScript: Understanding the Weird Parts","link":"/posts/2016/10/25/types-and-operators/"},{"title":"执行环境, 执行栈, 作用域","text":"JavaScript中执行环境, 执行栈, 作用域的介绍及实例. 执行环境和词法环境执行环境(Execution Context): 执行环境包括全局执行环境和函数执行环境. 当JavaScript代码最初开始运行时,全局执行环境被创建. 当某个函数被调用时,函数执行环境被创建. 词法环境(Lexical Environment): 描述变量名与特定变量或函数的关系 基于词法嵌套结构 词法环境一般来说和作用域(scope)同义,详见. 全局环境和全局对象当JavaScript代码开始刚开始运行时,全局执行环境就会被创建.在JavaScript中全局指代码或变量不包含在某个function对象中.在全局执行环境中,JavaScript引擎会创建全局对象和一个特殊的变量this,全局执行环境下两者的值相同.在一般的执行环境中,还会有outer environment,全局环境是处于最外层的outer environment.在全局环境中定义变量和函数会自动将变量和函数与全局对象关联. 以浏览器为例:a === window.afunc() === window.func() 函数调用和执行栈函数每被调用一次,都会创建一个执行环境置于执行栈顶部,调用自己本身也会创建. 1234567function b(){};function a(){ b();};a(); 这段代码执行过程: 编译器编译源代码; 全局执行环境被创建, b和a保存于内存空间; 代码一行行执行; 执行到a();时,新的执行环境被创建; 新的执行环境在执行栈中全局环境上方,执行栈顶部的执行环境处于运行状态; 函数a中调用b(),此时在执行栈顶部的执行环境又变成b; 当b执行结束时,跳出执行栈,然后是a,然后是全局. 作用域变量名相同,在不同的作用域中,就是不同的变量,在内存空间中占用的是不同的位置. 1234567891011121314151617181920function b(){ var myVar; console.log(myVar);}function a(){ var myVar = 2; console.log(myVar); b();}var myVar = 1;console.log(myVar);a();console.log(myVar);// 1// 2// undefined// 1 变量声明提前 Hoisting12345678910b();console.log(a);var a = 'Hello';function b(){ console.log('called b')}// 'called b';// undefined 在大多数编程语言中,会出现错误,因为代码一般是一行一行执行的,但是由于JavaScript中存在变量声明提前,所以出现上述结果.而a的结果是undefined的原因是var a = 'Hello';中提前的只有var = a;,赋值的部分并未被提前. 相当于: 12345678var a;function b(){ console.log('called b')}b();console.log(a); 上述代码只是为了便于理解,实际上并不是真正以这样的方式执行. 实际原因是执行环境的创建存在两个阶段: 1. 创建阶段 在这个阶段,JS引擎为变量和函数设置内存空间,在代码开始一行一行执行时,就可以获取内存空间中存在的变量或函数.其中函数整体保存于内存空间,而变量只有声明存在,所赋的值不会保存于内存中,因此在这个阶段,所有的变量值都为undefined.在JavaScript中,所有变量的初始值都为undefined. 2. 执行阶段 在这个阶段,代码开始一行一行执行. 作用域链12345678910function b(){ console.log(myVar);}function a(){ var myVar = 2; b();}var myVar = 1;a();//1 每个执行环境都可以获取其外部环境中存在的变量,b的外部环境是全局环境,因此可以获取到全局环境中声明的myVar.这里的外部环境是词法意义上(lexical environment)的. 在不同的作用域调用同一个函数,变量的值也可能会有差异. 1234567891011121314function a(){ function b(){ console.log(myVar); } var myVar = 2; b();}var myVar = 1;a();//2 此时函数b的外部词法环境是a,因此会从a中获取myVar的值. 作用域与ES6中的let在执行环境的创建阶段,变量依然会被初始化为undefined被保存在内存空间,但只有在执行阶段执行到那一行代码时,变量才可以被使用. 1234console.log(c);let c = 28;// Uncaught ReferenceError: c is not defined 1234console.log(c);var c = 28;// undefined 用了let,js引擎就有了块级作用域. 12345if (true){ let c = 2;}console.log(c)// Uncaught ReferenceError: c is not defined 12345if (true){ var c = 2;}console.log(c)//2 参考 JavaScript: Understanding the Weird Parts","link":"/posts/2016/10/15/execution-context/"},{"title":"Internet基础","text":"介绍一些网络相关的基础概念, 对经典问题「在浏览器中输入网址敲下回车之后发生了什么」的解答. 一些术语的解释 服务器(server): a. 是具有IP地址的计算机 b. 内部运行着服务器软件 c. 配置有各种数据文件或应用程序等 IP地址: a. 计算机只要连接上Internet,就会获得一个IP地址 b. 是唯一的,计算机的IP地址就像人的身份证号码 DNS(域名系统): a. 将域名和IP地址对应起来 (zh.wikipedia.org作为一个域名与IP地址208.80.154.225相对应) 在浏览器中输入网址敲下回车之后发生了什么？ 以google为例,我们在浏览器中输入www.google.com之后,向服务器发送请求访问google的主页页面,但是我们输入的是域名,可是服务器具有的是IP地址,因此需要浏览器和服务器之间的网络服务供应商(ISP)的帮助来执行DNS查询服务,将我们所输入的域名转化为便于机器识别的IP地址,这样就会连接到具有特定IP地址的服务器. 浏览器向服务器发送请求(request)之后,服务器会根据相关的request做出响应(response),根据浏览器的请求发送给浏览器其所需的文件. 上图包括了请求报文的主要部分,请求头和请求体,请求体也可省略.服务器根据请求头中的信息判断需要给浏览器发送哪个文件.上图中服务器会根据Path(/posts/images/logo.jpg)这个信息给浏览器发送在images文件夹中的logo.jpg文件.图中其他部分的含义: Host(www.google.com): 域名为www.google.com Method:请求方法(括号中为几个常用方法) a. GET:请求服务器发送某个资源给浏览器. b. POST: 向服务器输入数据,如登录操作输入用户名及密码,发一条新微博等. c. PUT:对服务器中已经存储的内容进行修改,如修改密码. d. DELETE: 删除服务器中的内容. Cookies:网站为了辨别用户身份在用户的计算机中所存储的数据. user-agent: 用户的浏览器信息. Content Type:请求体的数据格式. 服务器的响应报文主要内容见下图. 响应报文中最重要的内容是Content-Type,因为浏览器只能根据Content-Type知道服务器发送来的文件是何种类型.Status/Code表示服务器HTTP的响应状态: a. 1XX 信息性状态码b. 2XX 成功状态码c. 3XX 重定向状态码d. 4XX 客户端错误状态码e. 5XX 服务器错误状态码 如果浏览器接收到的是HTML文件,就会对其进行解析,一旦碰到需要assets(css,js或者img等格式的文件)的标签之后,就会暂停解析重新向服务器发出另一个请求,如下图,浏览器会根据link标签中的内容向服务器请求main.css文件,获取所需文件后继续解析后面的HTML,此时的解析与之前不同的是:会根据main.css中的样式对下面的HTML添加样式,为用户呈现添加了样式之后的网页.因此,最好将请求css的link标签放在HTML的head标签内. 但对于JavaScript文件,如果在文档的head标签中包含所有JavaScript文件,意味着必须等到全部JavaScript代码都被下载、解析和执行完成以后,才能开始呈现页面的内容,对于需要很多JavaScript代码的页面来说,这会导致浏览器在呈现页面时出现明显的延迟,而延迟期间的浏览器窗口中将是一片空白.所以,最好把全部JavaScript引用放在body标签中页面内容的后面这样,在解析包含的JavaScript代码之前,页面的内容将完全呈现在浏览器中.而用户也会因为浏览器窗口显示空白页面的时间缩短而感到打开页面的速度加快. 如第一张大图所示,能请求assets文件的除了HTML还有JavaScript,但JavaScript不直接发送HTTP请求的,而是通过XMLHttpRequest接口来发送请求,AJAX编程一般都是利用这个接口来实现. 服务器响应并将所需的文件发送给用户之后,页面就在浏览器中呈现了. 参考 How the Internet Works for Developers","link":"/posts/2016/10/12/internet-basics/"},{"title":"编程语言","text":"编译型语言与解释型语言的区别, 编译器与解释器, 源代码与机器码. 一些基本概念编程语言是人类和计算机进行沟通的工具,我们用特定编程语言写出的指令集合就是源代码,但计算机的CPU无法直接识别这些源代码(source code),CPU只能识别机器码(machine code).因此需要将源代码转换成CPU可以识别的机器码. 源代码转换为机器码的方式1. 编译器(compilers) 编译器直接将源代码文件全部编译为机器码文件,生成的文件可以在计算机中直接执行,例如我们安装新程序时经常会见到的以.exe为扩展名的文件,exe就是executable的缩写.只利用编译器转换源代码的编程语言叫做编译型语言(compiled language),编译型语言有C,C++,objective-c等. 2. 解释器(interpreters) 解释器获取的是源代码的拷贝,实时地将源代码一行一行地解释为机器码,JavaScript是解释型语言,我们计算机中的浏览器就是解释器.php也是解释型语言. 3. 即时编译器(JIT-compilers) 即时编译器混合了这二者,先将源代码一句一句编译为中间语言比特码(byte code),但是会将翻译过的代码缓存起来以降低性能损耗.运用了即时编译器的编程语言Java,C#,VB.NET,Python 编译型语言与解释型语言优缺点编译型语言 优点: 编译可直接在自己的计算机中执行 不需要发送源代码 执行速度更快 缺点: 无法跨平台,如.exe文件PC可识别,但MAC不可,不同的CPU识别的可执行文件类型有时也会有差异 测试时需要多一步编译的过程 解释型语言 优点: 跨平台,如JavaScript文件依靠浏览器运行. 测试更容易 能够获取源代码,调试更容易 缺点: 机器需要有解释器才能运行文件 程序每次运行多需要进行解释,速度慢 源代码公开有安全风险 各自适用场景如果程序只在一个平台运行,追求效率和性能,用编译型语言,如用objective-c写ios app只在ios系统中运行;如果程序需要跨平台运行,就用解释性语言,如用JavaScript写web app. 参考 Foundations of Programming Fundamentals","link":"/posts/2016/09/11/programming-languages/"},{"title":"JavaScript知识点在框架中的应用","text":"介绍一些重要的JavaScript知识点在框架中的应用, 不完整, 之后再学习到会继续更新. 默认值123456//lib1.jsvar libraryName = 'Lib1';//lib2.jsvar libraryName = 'Lib2';//app.jsconsole.log(libraryName); 12345&lt;body&gt; &lt;script src=\"lib1.js\"&gt;&lt;/script&gt; &lt;script src=\"lib2.js\"&gt;&lt;/script&gt; &lt;script src=\"app.js\"&gt;&lt;/script&gt;&lt;/body&gt; 尽管代码分别在三个文件中, 但实际上都处于全局作用域, 等同于: 1234567&lt;body&gt; &lt;script&gt; var libraryName = 'Lib1'; var libraryName = 'Lib2'; console.log(libraryName); &lt;/script&gt;&lt;/body&gt; 可以将lib2.js中的代码改为: window.libraryName = window.libraryName || 'Lib2'; 如果全局作用域已经存在libraryName这个变量且有值, 那么libraryName的值不会变化, 否则就会被赋值为'Lib2' 在框架中运用这个方法来确定变量名是否在之前已经被使用, 防止其被改变. ES6中引入了const, 也可以解决这个问题, 利用const声明变量, 变量就不可被改变. 创建命名空间命名空间: 变量和函数的container, 分离具有相同变量名的变量和函数名的函数. JavaScript中没有命名空间的概念, 因为在JavaScript中, 可以利用对象实现命名空间的功能(faking namespaces). 12345678910var greet = 'Hello';var greet = 'Hola';console.log(greet);var english = {};var spanish = {};english.greet = 'Hello';spanish.greet = 'Hola'; 不可以直接定义属性的属性: 123var english = {};english.greetings.greet = 'Hello';// Error 因为点操作符的优先级高于赋值操作符, 关联性是从左到右, 因此会先执行english.greetings, 结果为undefined, 所以会抛出错误. 应该这样做: 123var english = {};english.greetings = {};english.greetings.greet = 'Hello'; 或者: 1234567var english = { greetings: { basic: 'Hi' }};english.greetings.greet = 'Hello'; 参考 操作符优先级 函数重载在Java或C++中有函数重载(function overloading)的概念,即可以定义多个同名函数,但接受不同的参数, 而JavaScript语言中没有这个概念, 因为函数是对象, 所以无法定义多个同名函数, 但因为在JavaScript中函数是一等公民(first class function),可以通过以下方法实现类似的函数重载的功能: 12345678910111213141516171819202122function greet(firstname, lastname, language){ if (language === 'en'){ console.log('Hello ' + firstname + ' ' + lastname); } if (language === 'es'){ console.log('Hola ' + firstname + ' ' + lastname); }}greet('John', 'Doe', 'en');greet('John', 'Doe', 'es');function greetEnglish(firstname, lastname){ greet(firstname, lastname, 'en');}function greetSpanish(firstname, lastname){ greet(firstname, lastname, 'es');}greetEnglish('John','Doe');greetSpanish('John','Doe'); WhitespacesWhitespaces包括回车,制表符,空格. JavaScript is very liberal about whitespaces, 即使是这样用⬇️, 也完全合理: 1234567891011121314151617181920var //first name of the person firstname, //last name of the person lastname, // the language language;var person = { // the first name firstname: 'John', // the last name // (always required) lastname: 'Doe'}console.log(person); 在许多框架的源代码中这样的格式十分常见,开发者利用JavaScript引擎对待whitespace的特性将评注性文字以更加可读的形式呈现. 立即调用函数表达式(IIFE)函数声明不可匿名: 1234function (name){ console.log('Hello ' + name);};//SyntaxError: unknown: Unexpected token 上面这段代码会抛出错误, 因为语法分析器(Syntax Parser)看到关键词function之后会认为这是个函数声明, 但函数声明必须有名字,所以会抛出错误. 为了避免这个错误,在function前加上括号, 语法分析器就不会将其解析成函数声明. 括号在JS中是操作符, JS引擎将在括号内的代码都看作表达式. 1234// 加上括号之后相当于创建了一个函数对象(function (name){ console.log('Hello ' + name);}); ⬆️是函数表达式, 创建之后可以立即调用. 下面是 立即调用函数表达式的几种形式: 123456789101112131415var greet = function(name) { console.log('Hello ' + name);}('John');(function (name){ console.log('Hello ' + name);})('John');(function (name){ console.log('Hello ' + name);}('John'));(function greet(name){ console.log('Hello ' + name);}('John')); 当图片上这段代码开始执行, JS引擎看到第一行时, 将这部分代码看作函数表达式, 将其作为对象保存在内存空间, 直到执行到('John')这部分时, 匿名函数(即之前的对象)的执行环境被创建, 匿名函数内的greeting变量也被保存在这里, 而不是全局环境. 因为这个特点, IIFE在框架中有广泛的应用. IIFE在框架中的应用: 12&lt;script src='greet.js'&gt;&lt;/script&gt;&lt;script src='app.js'&gt;&lt;/script&gt; greet.js1var greeting = 'Hola'; app.js1234(function(name){ var greeting = 'Hello'; console.log(greeting + ' ' + name);}('John')); 上面部分的几段代码执行时相当于: 12345678var greeting = 'Hola';(function(name){ var greeting = 'Hello'; console.log(greeting + ' ' + name);}('John'));console.log(greeting); 在IIFE中定义的greeting变量在局部作用域中,不会污染全局作用域的greeting变量. 如果想在IIFE中使用全局作用域的变量,可在IIFE中声明并传入, 还可在其中改变全局作用域变量的值: 12345678910var greeting = 'Hola';console.log(greeting); // \"Hola\"(function(global, name){ global.greeting = 'Hello'; console.log(global.greeting + ' ' + name);}(window,'John')); // \"Hello John\"console.log(greeting); // \"Hello\" 工厂函数123456789101112131415161718function makeGreeting(language) { return function(firstname,lastname){ if (language === 'en'){ console.log('Hello ' + firstname + ' ' + lastname); } if (language === 'es'){ console.log('Hola ' + firstname + ' ' + lastname); } }}var greetEnglish = makeGreeting('en');var greetSpanish = makeGreeting('es');greetEnglish('John','Doe');greetSpanish('Jane','Doe') 传入外层函数, 在内层函数返回, 尽管在内层函数执行时makeGreeting函数已经跳出执行栈, 但language变量依然存在于内存空间. 调用不同的language, 创造的是不同的执行环境, 因此变量存在于不同的内存空间. 参考 JavaScript: Understanding the Weird Parts","link":"/posts/2016/11/02/js-frameworks/"},{"title":"I/O","text":"学习Node时对I/O的理解有一点困惑, 于是学习并整理了一些相关的知识. I/O定义: I/O即Input/Output 输入/输出,是信息处理系统(计算机)和外部世界(人类或其他信息处理系统)之间的通信.输入: 信息处理系统接收到的信号或信息.输出: 信息处理系统发出的信号或信息. I/O设备和I/O操作人类或其他处理系统可以通过I/O设备与计算机进行交互,比如,键盘鼠标是一台计算机的输入设备,执行输入操作,显示器和打印机是输出设备,执行输出操作.有些I/O设备可以同时执行输入和输出操作,比如调制解调器(modem,我们常说的猫就属于调制解调器中的一种类型),它执行对数字信号和模拟信号的输入输出操作. 编程语言中的I/O和大多数编程语言不同,JavaScript语言本身没有I/O(输入输出)的概念.它是运行在宿主环境中的脚本语言,由宿主环境提供与外部通信的机制.最常见的宿主环境是浏览器,这些宿主环境中都含有JavaScript解释器,在Node和浏览器中的解释器是V8引擎.而在Node中有I/O的概念. File I/O我们常用文本编辑器或Office软件等创建文件,但很多时候也需要利用应用程序创建文件,修改文件内容.(概念问题:所以并不是编程语言操作文件,而是利用编程语言写出的程序操作文件) 文件输入指被写入文件的信息,文件输出指从文件中读取的信息.将输入输出这两个概念与屏幕的输入输出联系起来会更容易理解. 文件的类型文件是物理硬盘中存储信息的地方.执行文件的I/O操作时应了解以下两种类型: a. 文本文件(Text Files) 扩展名为.txt,可以通过文本编辑器创建,修改或删除其中的文本,极易维护,很容易阅读,但安全性低,占用内存大. b. 二进制文件(Binary Files) 扩展名为.bin, 数据以二进制的形式存储,可以存储大量的信息,但不易阅读,安全性比文本文件高. 文件操作a. 创建新文件b. 打开已存在计算机中的文件c. 关闭文件d. 从文件中读写信息 待解决问题 标准I/O与非标准I/O的区别？ High-level I/O(Stream-level I/O)和Low-level I/O, Node中是否都是High-level I/O? 参考 Wikipedia I/O A re-introduction to JavaScript Computer Programming - File I/O C Programming Files I/O","link":"/posts/2016/10/30/io/"},{"title":"闭包","text":"闭包的概念以及相关应用. 定义12345678910function greet(whattosay){ return function(name){ console.log(whattosay + ' ' + name); }}// greet('Hi')('Joe');var sayHi = greet('Hi');sayHi('Joe'); 调用sayHi函数时,greet函数已执行完成,跳出执行栈(execution stack),但greet函数内定义的whattosay变量的值依然能被sayHi函数获取, 这样的情况可能发生是因为 JavaScript中存在 闭包. 代码开始执行时创建了一个全局执行环境, 当执行到var sayHi = greet('Hi')时, 调用greet()函数, 新的执行环境被创建, 传给greet函数的whattosay变量处于greet()执行环境中, 一边执行一边创建了所返回的函数, 函数返回之后, greet()函数跳出执行栈,这个执行环境不再存在, 但存储变量的内存空间以及变量依然存在. 当调用sayHi()时,又创建了一个新的执行环境, 但这个执行环境中没有whattosay变量,于是JavaScript引擎通过作用域链在sayHi函数外部寻找该变量. 闭包定义: The phenomenon of closing in all the variables that it is supposed to have access to is called a closure. 闭包是JavaScript语言本身的特性. 应用闭包与for循环1234567891011121314151617function buildFunctions(){ var arr = []; for(var i = 0; i &lt; 3; i++){ arr.push( function(){ console.log(i); } ) } return arr;}var fs = buildFunctions(); // {1}fs[0](); // 3fs[1](); // 3fs[2](); // 3 代码执行到行{1}时, buildFunctions被调用, 执行环境被创建, 执行之后赋值给fs, fs是个数组, 其中包含3个元素的均为函数function(){ console.log(i) }. 当调用数组中的函数时, 由于闭包, i值从函数定义时的外部获取, 即在buildFunctions中, 因为循环到i=3时结束, 所以i=3被保存于内存空间, 因此三次调用数组内函数的结果均为输出3. 如何让函数输出预期的结果: 1. ES6的解决方式 for循环执行时,因为let关键字创建了块级作用域,i在每次循环中都是内存中的一个新变量. 1234567891011121314151617function buildFunctions2(){ var arr = []; for(let i = 0; i &lt; 3;i++){ arr.push( function(){ console.log(i); } ) } return arr;}var fs2 = buildFunctions2();fs2[0](); // 0fs2[1](); // 1fs2[2](); // 2 2. ES5的解决方式 运用IIFE使函数在创建的时候执行, 这样每次执行都会创建新的执行环境, 于是每个被push到数组中的函数执行时都处于不同的执行环境, 因此数组中的函数每次执行时都会输出预期的不同值, j值从所创建的闭包中获取, 而不是再外一层的循环中. 123456789101112131415161718function buildFunctions2(){ var arr = []; for(var i = 0; i &lt; 3;i++){ arr.push( (function(j){ return function(){ console.log(j); } }(i)) ) } return arr;}var fs2 = buildFunctions2();fs2[0](); // 0fs2[1](); // 1fs2[2](); // 2 利用闭包创造工厂函数工厂函数 Function Factories 123456789101112131415161718function makeGreeting(language) { return function(firstname,lastname){ if (language === 'en'){ console.log('Hello ' + firstname + ' ' + lastname); } if (language === 'es'){ console.log('Hola ' + firstname + ' ' + lastname); } }}var greetEnglish = makeGreeting('en');var greetSpanish = makeGreeting('es');greetEnglish('John','Doe');greetSpanish('Jane','Doe') 传入外层函数, 在内层函数返回, 尽管在内层函数执行时makeGreeting函数已经跳出执行栈, 但language变量依然存在于内存空间. 调用不同的language, 创造的是不同的执行环境, 因此变量存在于不同的内存空间. 闭包与回调函数123456789function sayHiLater(){ var greeting = 'Hi'; setTimeout(function(){ console.log(greeting); },3000)}sayHiLater(); 在JavaScript中, 函数是一等公民并且可以即时创建函数表达式 所以可以将函数function(){ console.log(greeting); }作为参数传入setTimeout函数, 又因为闭包, greeting的值从sayHiLater执行时保存在内存空间的greeting变量中获取. 因此上述代码成立. 这里的函数function(){ console.log(greeting); }是回调函数.","link":"/posts/2016/11/15/closure/"},{"title":"理解Event Emitter","text":"Node中很多模块都运用了Event Emitter, 以下是对Event Emitter的介绍及在Node中的实现方式, 还介绍了在JavaScript中实现继承的几种方式. Node中的事件Node需要处理两种类型的事件. 1.系统事件(System Events)(C++ Core [libuv]) It comes from the c++ side of node.js core, thanks to a library called libuv. 操作系统相关的事件, 例如: 读取文件 获取来自互联网的数据 2.定制事件(Custom Events)(JavaScript core [Event Emitter]) When a event occurs in libuv, it generates a Custom JavaScript event to make it easier for us to decide what code should run when that event happens. Actually JavaScript is faking event because it does not have event object. EventEmitter的实现原理(简化版)emitter.js 12345678910111213141516171819202122232425function Emitter(){ this.events = {};}Emitter.prototype.on = function(type, listener){ // 在事件对象中加入新的属性 // 确保新的属性以数组的形式保存 this.events[type] = this.events[type] || []; // 在数组中加入事件处理函数 this.events[type].push(listener);}// {// gotSomthingFromInternet: [function(){}, function(){}]// }Emitter.prototype.emit = function(type){ if(this.events[type]) {// 如果事件对象中含有该属性 this.events[type].forEach(function(listener){ listener(); }) }}module.exports = Emitter; app.js 1234567891011121314var Emitter = require('./emitter');// var Emitter = require('events'); Node内置模块eventsvar emtr = new Emitter();emtr.on('greet', function(){ console.log('Somewhere, someone said hello.');});emtr.on('greet', function(){ console.log('A greeting occurred!');}); emtr.emit('greet'); Magic String 代码中含有特殊含义的字符串, 传入emit和on方法中的第一个参数就是Magic String, 上例中为’greet’. 直接以字符串的形式传入会使调试变困难. 可以这样解决该问题(不容易犯错, 更易控制): 添加一个配置文件config.js: config.js 1234567module.exports = { events: { GREET: 'greet', FILESAVED: 'filesaved', FILEOPENED: 'fileopened' }} app.js 1234567891011121314var Emitter = require('events');var eventConfig = require('./config').events;var emtr = new Emitter(); emtr.on(eventConfig.GREET, function(){ console.log('Somewhere, someone said hello.');}); emtr.on(eventConfig.GREET, function(){ console.log('A greeting occurred!');}); emtr.emit('greet'); 从EventEmitter继承继承的方法inherits实现 1234567891011121314151617exports.inherits = function(ctor, superCtor) { if (ctor === undefined || ctor === null) throw new TypeError('The constructor to \"inherits\" must not be ' + 'null or undefined'); if (superCtor === undefined || superCtor === null) throw new TypeError('The super constructor to \"inherits\" must not ' + 'be null or undefined'); if (superCtor.prototype === undefined) throw new TypeError('The super constructor to \"inherits\" must ' + 'have a prototype'); ctor.super_ = superCtor; Object.setPrototypeOf(ctor.prototype, superCtor.prototype);}; 使用inherits继承EventEmitter Node中许多内置对象都从EventEmitter继承 123456789101112131415161718192021222324var EventEmitter = require('events');var util = require('util');function Greetr(){ EventEmitter.call(this); // super constructor // 确保从该函数构造器中创建出的对象继承所有EventEmitter的属性, 因为inherits只使对象继承prototype中的属性, 没有继承构造器本身的属性(下面有示例) this.greeting = \"Hello World!\";}// 使Greetr继承EventEmitter的prototype的属性 util.inherits(Greetr, EventEmitter); Greetr.prototype.greet = function(data){ console.log(this.greeting + ': '+ data); this.emit('greet',data);}var greeter1 = new Greetr();greeter1.on('greet', function(data){ console.log('Someone greeted!: ' + data);});greeter1.greet('Tony'); 确保继承完整性 inherits只使对象继承prototype中的属性, 没有继承构造器本身的属性, 利用构造器.call(this)确保继承完全. 1234567891011121314151617181920var util = require('util');function Person() { this.firstname = 'John'; this.lastname = 'Doe';}Person.prototype.greet = function() { console.log('Hello ' + this.firstname + ' ' + this.lastname);}function Policeman() { //Person.call(this); this.badgenumber = '1234';}util.inherits(Policeman, Person);var officer = new Policeman();officer.greet(); // Hello undefined undefined 在Policeman构造器中调用Person.call(this);后, 从Policeman中实例化出的对象的属性就不只继承自原型链, 还有Person构造器中定义的属性, 这样再调用office.greet(), 结果就是: `Hello John Doe’. 1234567891011121314151617181920var util = require('util');function Person() { this.firstname = 'John'; this.lastname = 'Doe';}Person.prototype.greet = function() { console.log('Hello ' + this.firstname + ' ' + this.lastname);}function Policeman() { Person.call(this); this.badgenumber = '1234';}util.inherits(Policeman, Person);var officer = new Policeman();officer.greet();//Hello John Doe 使用ES6 class重构上述代码 class只是语法糖, 并不是其他编程语言中的”类”. 12345678910111213141516171819class Person { constructor(firstname, lastname){ this.firstname = 'John'; this.lastname = 'Doe'; } greet(){ console.log(`Hello ${this.firstname} ${this.lastname}`); }} class Policeman extends Person { constructor( ){ super(); // 相当于Person.call(this) this.badgenumber = '1234'; }} var officer = new Policeman();officer.greet(); 12345678910111213141516171819var EventEmiiter = require('events');class Greetr extends EventEmiiter { constructor(){ super(); // 相当于EventEmitter.call(this) this.greeting = \"Hello World!\"; } greet(data){ console.log(`${this.greeting}: ${data}`); this.emit('greet', data); }}var greeter1 = new Greetr();greeter1.on('greet', (data) =&gt; { console.log(`Someone greeted!: ${data}`);});greeter1.greet('Tony'); class使用module.exports: 12345678var EventEmitter = require('events');module.exports = class Greetr extends EventEmiiter { constructor(){ super(); this.greeting = \"Hello world\"; }} 参考 Learn and Understand NodeJS","link":"/posts/2016/11/20/event-emitter/"},{"title":"异步与事件","text":"异步与事件队列的初步介绍. 理解同步和异步同步: 当你在玩游戏时,肚子突然饿了,于是花了20分钟自己做了一个披萨.之后开始吃然后继续玩游戏. 异步: 当你在玩游戏时,肚子突然饿了,于是拿起手机点了一份20元的披萨.之后开始吃然后继续玩游戏. 首先明确,你的主要目的是完成两件事,玩游戏,吃披萨. 在同步的事件中,你用了20分钟玩游戏的时间自己做了一个披萨,吃到了披萨.在异步的事件中,你花费了20元买了一个披萨,吃到了披萨. 参考来源 JavaScript是单线程,同步的单线程(single-threaded): 一次只执行一条指令.线程是CPU顺序执行指令的一个调度单位. JS引擎中的行为是单线程,同步的,但在浏览器中,不仅仅只有JS引擎存在,还存在其他部分(如渲染引擎),JS引擎和外部的交流是异步的. 事件队列JS引擎工作时除了有执行栈,还存在一个事件队列(Event Queue),如果用户触发了JS引擎能够处理的事件,这个事件就会被放置于事件队列中等待JS引擎处理,当执行栈为空时,JS引擎开始处理队列中的事件.只有执行栈空时才会开始处理.JS引擎检查事件队列的持续行为称为 Event Loop . 所以异步指的是浏览器异步将事件置于事件队列,是JS引擎外的行为,代码依旧是一行一行执行. 123456789101112131415161718192021function waitThreeSeconds() { var ms = 3000 + new Date().getTime(); while (new Date() &lt; ms){} console.log('finished function');}function clickHandler() { console.log('click event!'); }document.addEventListener('click', clickHandler);waitThreeSeconds();console.log('finished execution');// finished function// finished execution// ('click event!')// 顺序不会改变 console.log('finished execution');这段代码结束执行之后,执行栈才空,开始处理点击事件. Ps: js文件的位置 app.js必须放在body的关闭标签之前,如果放在&lt;head&gt;标签之内,三秒之内无论点击多少次,click事件都不会执行. 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- Don't do this: --&gt; &lt;!-- &lt;script src='/app.js'&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;script src='/app.js'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 原因: 浏览器加载含有&lt;script&gt;标签的网页过程: 获取HTML 开始解析HTML 解析器解析到连接外部JS文件的&lt;script&gt;标签 浏览器请求外部JS文件,同时暂停解析HTML 一段时间后JS文件加载完成然后成功执行 之后解析器开始解析余下部分的HTML 因此如果script在head标签内,表示浏览器的页面还没有渲染,无论如何点击,都获取不到这一事件.","link":"/posts/2016/11/29/async-n-event/"},{"title":"innerText与几种DOM方法","text":"介绍innerText, textContent, innerHTML的区别, 引起重排的几种情况, 以及几种常用的DOM方法. innerText, textContent, innerHTML: textContent可以获取所有元素节点的文本内容, 包括&lt;script&gt;和&lt;style&gt;中的, 而IE专属属性innerText不会获取. innerText受样式影响, 不返回隐藏元素的文本, 而textContent会. 因为innerText受样式影响, 所以改变后会触发重排(reflow), 而textContent不会触发. innerHTML获取的是元素节点, 但很多人用innerHTML来获取或改变某个DOM元素的文本内容, 但实际上应该使用textContent, 这样就不会被解析为HTML, 对性能的影响较小, 还能避免XSS恶意程序的攻击. 重排重排会重新安排页面的布局, 在一个元素节点中的重排指重新计算该元素的尺寸和位置, 并且会触发该元素子节点, 祖先元素的重排, 以及在出现在该元素之后的DOM元素的重排(下面有示例), 最后进行一次重绘(repaint). 重排是个很容易引起的现象, 但是对性能的影响很大, 在很多情况下相当于对整个页面的布局进行重新安排, 因此要尽量避免重排. &lt;重绘: 元素在页面中显示出来的样式发生改变, 就会引起重绘, 但此时元素的布局并未发生改变. 样式的改变的一些例子: 轮廓线(outline), 可见性(visibility), 背景颜色(background color).&gt; 下列情况会引起重排: 插入, 移除, 更新DOM中的元素 改变页面内容, 如改变输入框中的文本 移动DOM元素 给DOM元素加动画效果 计算元素的样式值, 如offsetHeight或getComputedStyle 改变CSS样式 改变元素的className 添加或移除样式表 改变视窗大小 滚屏 1234567891011&lt;body&gt;&lt;div class=”error”&gt; &lt;h4&gt;My Module&lt;/h4&gt; &lt;p&gt;&lt;strong&gt;Error:&lt;/strong&gt;Description of the error…&lt;/p&gt; &lt;h5&gt;Corrective action required:&lt;/h5&gt; &lt;ol&gt; &lt;li&gt;Step one&lt;/li&gt; &lt;li&gt;Step two&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;/body&gt; 在以上部分代码中, &lt;p&gt;&lt;/p&gt;的重排会引起子节点&lt;strong&gt;&lt;/strong&gt;, 祖先元素&lt;div class=”error”&gt;&lt;/div&gt;(和&lt;body&gt;&lt;/body&gt;[取决于浏览器]), 紧接其后的元素&lt;h5&gt;&lt;/h5&gt;和&lt;ol&gt;&lt;/ol&gt;的重排, 在Opera浏览器中, 大部分重排会引起页面的重新渲染. 几种常用DOM方法appendChildnode.appendChild(newnode); 在父节点node下添加一个子节点newnode, 添加位置在原有子节点的末尾, 返回新添加的节点; insertBeforenode.insertBefore(newnode, existingchild); 在父节点node下, 已存在的子节点existingchild前添加一个子节点newnode, 返回插入的节点; 将新建子节点置于父节点下首位:(父节点下需至少含有一个子节点) parent.insertBefore(new, parent.firstChild); 将新建子节点置于父节点下末尾:(相当于appendChild) parent.insertBefore(new, null); nodeTypevar type = node.nodeType; 节点类型, 用数字标识, 共有12种节点类型, 其中Element(元素)的nodeType为1, Attr(属性) = 2, Text(文本) = 3. childNodesvar kids = node.childNodes; 获取父节点node的第一层所有类型的子节点集合, 返回的是NodeList, 并非数组, 如果要转化成数组需要用Array.from()或者...(spread operator). childrenvar children = node.children; 获取父节点node下的所有第一层元素子节点. firstChildvar child = node.firstChild; 获取父节点node的第一层第一个子节点, 若不存在则返回null. firstElementChildvar element = node.firstElementChild; 获取父节点node的第一层第一个元素子节点. lastElementChildvar element = node.lastElementChild; 获取父节点node的第一层最后一个元素子节点. childElementCountvar count = node.childElementCount; 获取父节点node的第一层元素子节点个数, 相当于 node.children.length removeChildnode.removeChild(oldnode); 从父节点node中移除某个子节点oldnode, 返回被移除的节点. replaceChildnode.replaceChild(newchild, existingchild); 在父节点node下用newchild替换已存在子节点existingchild, 返回被移除的节点; createElementdocument.createElement([tagname]); 在document下创建元素; createTextNodedocument.createTextNode('some text'); 在document下创建一个内容为’some text’的文字节点; 用法: 12345var element = document.createElement('h1');element.appendChild(document.createTextNode('some text'));// 结果: &lt;h1&gt;some text&lt;/h1&gt; 参考 innerText和textContent的区别 MDN - textContent reflow是什么 reflow和repaint的区别 reflow, repaint与性能 DOM Core","link":"/posts/2017/03/04/innertext-reflow-dom/"},{"title":"[转]如果互联网被切断，你还可以怎么办？","text":"即便互联网已无法访问，但每个人的电脑实际上还是互相连接的。换句话说你们仍处于同一个巨型局域网之中，甚至仍有公网IP。所以理论上通过某种方式，你或许能再度利用那些被荒废的网线和电缆。这里有三个方法，你只需要一个U盘： 无服务器、永远在线的网站——ZeroNet 网址：https://zeronet.io/ZeroNet是一个免费、开源、使用Bitcoin加密技术和BT技术的全平台分布式网络工具，他的原理比较像我们熟悉的BT下载：当我们通过种子(torrent）下载电影和音乐时，这些资源的来源并非某个机房中的服务器，而是其他用户的电脑硬盘，只要在网络中还存在任何一台电脑『做种』，资源就能够被持续下载，同时提供资源的设备量也会迅速增长，因此BT下载无法被单点封禁。 ZeroNet的工作原理与BT大致相同。在你通过ZeroNet搭建一个网站后，处于同一个网络中的用户即可通过ZeroNet将你的网络论坛下载到他的硬盘里，同时进行浏览。当第三个用户访问这个站点时，你和第二个用户会同时向他上传网站。如果用户基数足够大，那么即便你的电脑关机甚至硬盘损坏，只要别人的电脑上仍保存有网站的文件，这个网站就能永远『存活』下去。是不是很酷？ 目前ZeroNet提供论坛、博客、社交网站、加密邮件、即时聊天等，几乎覆盖了大多数的互联网服务。在断网时期，网民实际上有能力以极低成本来为彼此搭建这些基础服务。不仅如此，ZeroNet还可以通过Tor网络隐藏自己的身份，ZeroNet绝对是你对抗外星人的工具包中的一件利器。 断网后我们照样聊天——Tox 网址：https://tox.chat/Tox是一个开源免费的分布式加密通讯协议，诞生于『棱镜计划』被斯诺登曝光之后，对用户的通讯内容进行端到端加密，中间不经过任何中央服务器，还可以用于局域网内通讯。你发给好友的聊天内容不会像其他聊天软件一样先发送到中央服务器、再转发给收件人，而是直接发送到目标用户。 Tox和ZeroNet一样，也使用了BT技术，将用户点对点的连接起来。在你使用Tox的时候，会生成一个独一的用户名，只要你的朋友知道你的用户名，即可开始聊天。 目前Tox已经支持全平台，并有很多版本的客户端，界面简单易用不需要复杂配置，绝对是逃离外星人监控、实现安全通讯的不二选择 虽然断网，但我还有几个G的学习资料想传给远方的你——Resilio SyncResilio Sync是一个分布式同步工具，同样不需要服务器，且支持全平台（但并不开源）。当你把一个文件夹加入Resilio Sync中时，可以生成一串密钥，如果在另一台设备的Resilio Sync中输入该密钥，就能将你的文件夹远程同步到这台设备中。之后加入的所有同步节点，都可以在下载资源的同时向其他用户上传资源。 由于文件存储在本地硬盘而非服务器上、对传输内容进行了加密、又以BT基础为依托，Resilio Sync实际上是一个高安全度、无存储空间限制、无下载流量限制、无审查、无法被封杀的超级网盘。资源拥有者甚至还可以通过设置权限来控制资源的分发和更改。例如你和你的朋友希望分发你们的音乐专辑，那么你可以分配给他读写权限，然后将只读权限通过各种方法公开出去，此时你们二人可以远程协作共同编辑专辑，而其他网友则可自由下载，当文件被修改的时候，所有同步节点都会被更改。 Resilio Sync还有很多很强大的使用方法，发挥想象力，它能成为对抗外星人的制胜法宝。（来自：WeThinker） Resilio Sync一些有用的只读密钥: BTLZ4A4UD3PEWKPLLWEOKH3W7OQJKFPLG 爬牆梯 ​B65PQLBRKMZFH7TXZVCGFXGM5V5SLIJBH 各種紀錄片（不定期更新）BNPVUPEWI63726IUBGWAFUSTG45WEJEUW 被下架書單BKRC7UBK2IVKILMGA77T36ZYHM3YKFWST 趙氏族譜 参考 如果互联网被切断，你还可以怎么办？ Resilio Sync(原名BT Sync)一款防封鎖的文件分享軟件 扫盲 BT Sync——不仅是同步利器，而且是【分布式】网盘","link":"/posts/2017/04/09/without-internet/"},{"title":"git常用指令","text":"学习过程中一些比较经常用到的git指令, 持续更新.(updated at 2017-07-11) 在某个分支修改了部分内容之后发现需要这部分内容应该要在另一个分支修改1.首先暂存在该分支的全部改变 git stash 2.checkout到另一分支, 将暂存起来的改变添加到该分支 git checkout another-branch git stash pop 删除所有commit历史记录,保存现在的代码1.Checkout另一个branch git checkout --orphan branch_name 2.stage所有文件 git add -A 3.提交 git commit -am &quot;commit message&quot; 4.删除master分支(本例假定删除master分支的commit历史, 如果要删除其他分支的历史, 把master改为所需分支名即可, 步骤5, 6同理) git branch -D master 5.将新创建的分支名改为master git branch -m master 6.强制更新repo git push -f origin master 本地,远程删除分支方法本地: git branch -d branch_name 远程: git push origin --delete branch_name 更详细 与远程库分离git remote rm origin","link":"/posts/2017/03/11/git-commands/"},{"title":"网站视频下载及Mac录屏","text":"前两天想下载一些B站的视频, 找到了一些相关工具. 视频下载硕鼠可以下载包括B站在内的许多国内网站视频, 详见官网. ibilibili因为B站有些视频需要注册会员才能看, 用硕鼠没办法解析这些视频, 后来发现用ibilibili可以下载这些视频, 但是下载过来的是up主最初发布的那个版本, 如果后续更新了那个视频(比如加上了字幕), 用ibilibili是无法下载到更新版本的视频的. 现在暂时还没找到可以直接下载更新版本视频的方法. 使用方法: 比如这个视频: http://www.bilibili.com/video/av2411035/, 如果想要下载可以直接在网址的bilibili前加个i: http://www.ibilibili.com/video/av2411035/, 根据网站提示下载即可. 详见官网 Video Downloader目前暂时支持下载优酷，土豆，搜狐，A站，B站，爱奇艺这几个网站的视频. 自己还没用过, 据说不如硕鼠好用, 不过可以当做硕鼠的备用.详见介绍页面 Mac录屏QuickTime Player上面说到没办法直接下载B站中更新过的视频, 但是如果实在需要, 可以用录屏软件实现, Mac下内置的QuickTime Player, 可以满足这个需求, 打开程序后选择File &gt; New Screen Recording, 点击开始录制的红点后根据文字提示操作即可. 除了录屏, 还可以录制音频(New Audio Recording)和视频(New Movie Recording), 根据需求选择即可. 现在需要录制网页上播放的视频, 仅仅使用Screen Recording无法同时录制视频的声音, 可以下载声音辅助插件Soundflower. Soundflower(声音辅助)以下是从知乎上复制的内容: 1.先装Soundflower: 下载地址 2.在 应用程序 -&gt; 实用工具 里面找到“音频 MIDI 设置”点左下角“+”，新建一个“聚集设备”，勾选右边的“内建麦克风”和“Soundflower(2ch)”。 3.再新建一个“多输出设备”，勾选“内建输出”和“Soundflower(2ch)”。 4.系统偏好设置 -&gt; 声音，输出，选“多输出设备”。 5.输入，选“聚集设备”。 6.打开QuickTime，文件 -&gt; 新建屏幕录制，点小三角，麦克风选“聚集设备” 然后录的时候就既有系统的声音也有麦克风的声音。 如果想只录系统的声音，则最后一步那里，选择Soundflower（2ch）就只有系统发出的声音而没有麦克风声音了。 参考 Mac技巧之苹果电脑下载各大视频网站和电视台节目视频的免费软件：硕鼠 for Mac Mac技巧之又一个把视频网站视频下载到苹果电脑本地的免费软件：Video-Downloader 知乎: Mac OS 下怎么录屏，能同时保留声音？","link":"/posts/2017/04/15/video-download-record/"},{"title":"Redux-不可变更新","text":"在Redux中, reducer函数遵循不可变更新模式, 而对象和数组在JavaScript中是通过引用传递(pass by reference), 因此如果直接修改对象和数组, 原对象和数组就会改变, 于是我们需要对对象和数组的拷贝进行修改, 下面整理了一些修改时要避免以及推荐使用的方法. 可以在jsbin中输入代码用以测试效果. 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width\"&gt; &lt;script src=\"https://unpkg.com/expect/umd/expect.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://wzrd.in/standalone/deep-freeze@latest\"&gt;&lt;/script&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 在html模板中引入expect库用以断言, deep-freeze库用以避免可变数据(avoid mutation). 数组插入元素❎ push123456789101112131415161718const addCounter = (list) =&gt; { list.push(0); return list;};const testAddCounter = () =&gt; { const listBefore = []; const listAfter = [0]; deepFreeze(listBefore); expect( addCounter(listBefore) ).toEqual(listAfter); };testAddCounter();console.log('All tests passed'); 上述代码中, 使用push在list中添加元素, 尽管达到要求插入了元素, 但是修改了listBefore, 无法通过deepFreeze那一部分的测试, 这在redux应用中是不被允许的, 我们应该要避免初始state的改变, 有两种方法可以解决这个问题: 用concat方法代替push方法, 修改的是原数组的拷贝 使用ES6扩展运算符(...) 代码如下: ✅ concat或spread operator(扩展运算符...)123456const addCounter = (list) =&gt; { // 1. concat() return list.concat([0]); // 2. spread operator // return [...list, 0];}; 移除元素❎ splice12345678910111213141516171819const removeCounter = (list, index) =&gt; { list.splice(index, 1); return list;};const testRemoveCounter = () =&gt; { const listBefore = [0, 10, 20]; const listAfter = [0, 20]; deepFreeze(listBefore); expect( removeCounter(listBefore, 1) ).toEqual(listAfter); };testRemoveCounter();console.log('All tests passed'); 使用splice方法直接改变listBefore, 不可取, 改进版本: ✅ slice和...1234567const removeCounter = (list, index) =&gt; { return [ ...list.slice(0, index), ...list.slice(index + 1) ]; // 拷贝index之前和之后的元素并将两者合并}; 使用扩展运算符和slice方法, 拷贝index之前和之后的元素, 并将两者合并后返回, 不改变原有的list, 其中扩展运算符也可以用cancat方法代替实现, 但扩展运算符更简便. 修改数组中某个元素值❎ 直接修改元素 12345678910111213141516171819const incrementCounter = (list, index) =&gt; { list[index]++; return list;};const testIncrementCounter = () =&gt; { const listBefore = [0, 10, 20]; const listAfter = [0, 11, 20]; deepFreeze(listBefore); expect( incrementCounter(listBefore, 1) ).toEqual(listAfter); };testIncrementCounter();console.log('All tests passed'); 修改某个元素值所使用的方法和移除元素所使用方法类似, 都是用slice和…创建数组的拷贝后再进行相应操作. ✅ 修改拷贝 1234567const incrementCounter = (list, index) =&gt; { return [ ...list.slice(0,index), list[index] + 1, ...list.slice(index + 1) ];}; 对象❎1234567891011121314151617181920212223242526const toggleTodo = (todo) =&gt; { todo.completed = !todo.completed; return todo;};const testToggleTodo = () =&gt; { const todoBefore = { id: 0, text: 'Learn Redux', completed: false }; const todoAfter = { id: 0, text: 'Learn Redux', completed: true }; deepFreeze(todoBefore); expect( toggleTodo(todoBefore) ).toEqual(todoAfter); };testToggleTodo();console.log('All tests passed.'); 有一种解决方法是手动对原对象进行拷贝, 然后仅修改需要修改的那一部分属性, 尽管能通过测试, 但是如果之后在对象中添加属性, 有可能会忘记更新拷贝的对象, 所以这种方法不可取.1234567const toggleTodo = (todo) =&gt; { return { id: todo.id, text: todo.text, completed: !todo.completed };}; ✅ ES6语法: Object.assign() 12345const toggleTodo = (todo) =&gt; { return Object.assign({}, todo, { completed: !todo.completed });}; ✅ spread operator(...) 123456const toggleTodo = (todo) =&gt; { return { ...todo, completed: !todo.completed };}; 参考 Redux: Avoiding Array Mutations Redux: Avoiding Object Mutations","link":"/posts/2017/04/17/redux-avoid-mutation/"},{"title":"[译]热重载与时间旅行调试","text":"原文: Hot reloading and time travel debugging作者: Lin Clark原文发布时间: 2015.10.21 Redux有两个很棒的特性: 热重载和时间旅行调试. 那么这两个特性究竟是什么呢? 热重载在我们开发的过程中, 对应用的某一部分做出微小改变是常有的事, 越早看到这些变化的效果, 开发的效率就越高. 热重载的好处就是当我们对应用的一部分做出改变时, 应用的state不会被重置. 举个例子, 我们在测试一个todo应用时, 已经手动加入了一些测试的todo条目, 然后将其中几个条目勾选表示已完成. 可是测试完后你突然发现需要改变一些UI文本. 比如要将占位符中出现的笔误”New toto”修改为正确的”New todo”. 如果没有热重载, 就必须: 修改代码 刷新浏览器页面 重新添加数据测试功能 但如果有热重载的特性, 我们就不需要再重新添加数据了, 因为应用的state不会被重置, 测试时添加的那些todo条目依然存在于state中, 这样调试效率就会大大提高. 尽管React应用没有使用Redux来管理state, 在调试时我们依然可以实现热重载, 只是可以执行热重载的部分有所限制: 在view和action creator中可以执行热重载, 而在store中则不行. 因为store扮演着两种角色: 1.根据action改变state; 2.存储state各个版本并保持其更新. 如果重载了改变state的代码, 就会失去store当前所存储的state. Redux给予应用热重载state变化逻辑的能力, 它是这样实现的: 将任务分离, 让两个部分负责, 这两个部分分别是store和reducer, 其中store负责保存state, 而state改变的逻辑由另一个对象reducer负责. 这样我们就可以热重载state变化的逻辑(reducer)而不丢失store中所存储的state信息. 时间旅行调试有了热重载, 即使在代码发生改变的情况下, 应用依然能够保持state不被重置. 而有了时间旅行调试, 我们可以将应用的状态调整至之前任何一个阶段. (译注: 以下内容没有完全理解, 所以翻译的意思可能有偏差, 待改进.) 这样一来, 对应用的某部分执行测试的效率就会变高. 比如我们现在发现应用中有个bug, 当我们将某个已完成的todo条目勾选, 然后添加另一个条目时, 这个bug就会出现. 有了时间旅行调试, 应用会从头开始执行整个流程重新设置state. 然后在之后的测试中, 就可以只回退一步再添加todo条目, 不需要重新从头开始整个流程. 这个功能还有很多其他用处, 在QA测试中, 我们能够记录下所有action. 遇到bug时可以将action和state的历史记录打包进行调试, 而且还能进行适当处理执行自动化测试. 从技术上来说, 在Flux中实现时间旅行调试也是可行的, 但实现过程十分复杂, 在Redux中实现方式更简单. 推荐阅读: 看漫画理解Redux(英文, 中文) 注: 初学redux时看到的文章, 想要通过翻译深入理解, 因此翻译的质量可能不是太好, 内容会在学习的过程中不断改进.","link":"/posts/2017/05/01/hot-reloading-time-travel/"},{"title":"Small Tips","text":"记录一些琐碎的知识点, 多了之后会重新分类, 持续更新… server 在任意文件夹开启本地服务器 python -m SimpleHTTPServer 8000 Start a Simple Web Server Any Directory on Your Mac 同时开启本地和外部服务器 browser sync Mac OSX 命令行指令 Tricks for terminal in Mac OSX","link":"/posts/2017/05/07/small-tips/"},{"title":"Why webpack","text":"介绍了webpack产生的最主要原因. 服务器端模板与单页面应用服务器端模板Server Side Templating(利用服务器端渲染server side rendering) 后端服务器创建HTML文件, 将其发送给用户, 这个HTML文件是fully-rendered HTML document(组成一个完整页面所有需要的内容都在这个文件中, 包括图片, css文件, js文件等). 依赖服务器整合所有内容到HTML文件中. 在浏览器中输入网址之后, 向服务器发送HTTP请求, 服务器发送HTML文件到客户端, 用户浏览HTML网页时如果点击了某个链接, 浏览器又会向服务器发送HTTP请求, 然后接受到新的HTML文件. 使用服务器端渲染, 每一次HTTP请求都会收到一个包含所有内容新的HTML文件. 单页面应用Single Page App(利用客户端渲染clien side rendering) 服务器只发送HTML文件的一个模板给用户, 所有需要的内容由JavaScript在客户端负责整合并渲染以创建一个完整的应用. 依赖JavaScript文件整合所有内容. 用户请求页面, 浏览器向服务器发出HTTP请求, 服务器向客户端发送包含了js文件的HTML文件, 然后前端框架React/Vue/Angular等就会开始发挥作用整合一些HTML页面展示给用户. 当用户点击某个链接时, 比如转换到另一个页面, 这时并不会向服务器发送HTTP请求, 请求HTML文件, 而是由前端框架负责渲染新的内容到页面. 两者JavaScript代码量的对比 JS代码量大所带来的问题假设有个比较大的项目, 所有的JS代码都在以下三个文件中, 每个文件的代码有几千多行. 假如我们现在需要对项目的header进行修改, 改变导航栏的一部分功能, 在几千多行代码中找出负责这部分的代码并执行修改十分不容易. 为了解决这个问题, 引入了module(模块)的概念, 将巨大的JS文件分成多个负责页面不同部分的模块文件. 这样, 修改某部分的功能就变得更容易. 然而, 分成多个模块也会带来一些问题. 1.加载顺序 不同的JS文件之间有依赖, 因此加载顺序是个比较重要的问题. 我们需要确保应用的每一次执行, 模块的加载顺序都正确且一致. webpack如何确保各个模块的执行顺序现在有两个文件sum.js以及index.js sum.js: 12const sum = (a, b) =&gt; a + b;export default sum; index.js 12345import sum from './sum';import './image_viewer';const total = sum(10, 5);console.log(total); 如果使用webpack将两者整合, 具体过程不再详述, 分析生成的bundle.js文件, 可以发现webpack的工作原理, 以下是进行简化之后的bundle文件, 可以清楚地了解webpack是如何确保执行顺序的: 1234567891011121314var myModules = [ function() { const sum = (a, b) =&gt; a + b; return sum; }, function() { const sum = myModules[0](); const total = sum(10, 10); console.log(total); }];var entryPointIndex = 1;myModules[entryPointIndex](); 2.性能损耗 使用HTTP请求多个JS文件对性能损耗较大, JS文件越多, 加载所花去的时间就越长, 在移动设备上这个问题更甚. webpack最主要功能webpack的存在, 解决了上面提到的问题: webpack的最主要功能就是将多个模块的JS文件打包成一个文件: bundle.js 并且确保每一个模块文件的执行顺序正确. 参考 webpack 2: The Complete Developer’s Guide","link":"/posts/2017/05/15/why-webpack/"},{"title":"webpack2基础","text":"webpack简单介绍, webpack-dev-server的使用, css-loader, style-loader, loader与plugin. 这里是教程需要用到的代码示例 webpack简单介绍当项目中js文件和css文件很多时, 手动整理这些文件很容易产生混乱和错误, 因此我们可以利用webpack这个构建工具帮我们整理好这些文件. 不使用webpack下载代码示例, 查看01-starting-app分支, 可以看到index.html引入了两个js文件, app.js和dom-loader.js. 打开中的index.html查看效果, app正常运行. 但是如果我们调换两者在index.html中的引入位置, 会发现app无法正常运行, 因为dom-loader.js中的内容为获取DOM节点, 如果不先于app.js执行, app.js中的一些变量就为undefined. 这个例子比较简单, 可以不使用webpack进行构建, 这里只是将其作为例子说明webpack的基本使用方法, 可是当项目较大, 需要比较多的js文件时, webpack就很有用了. 现在看看在这个例子中如何使用webpack. 使用webpack 在项目文件夹命令行执行: npm init, 如果不需要额外修改配置可以一路回车, 也能这样简写: npm init -y 设置全部配置为默认值. 上述步骤执行后会在项目根目录自动创建package.json文件 npm install webpack --save-dev, 也可以这样简写 npm i -D webpack. (国内使用npm速度很慢, 可以使用cnpm) 执行上述指令后package.json文件会多出下面几行内容: 123\"devDependencies\": { \"webpack\": \"^2.5.1\"} 然后在package.json下添加下面内容, 声明webpack的入口及输出文件, 这里入口是app.js. 123\"scripts\": { \"build\": \"webpack src/js/app.js dist/bundle.js\"} 同时需要在app.js文件中使用import引入其他依赖的js文件(这里是dom-loader.js), 具体这样修改: 在app.js顶部输入: 1import { secretButton, secretParagraph } from './dom-loader' 然后在dom-loader.js中: 12export var secretButton = document.querySelector('#secret-button');export var secretParagraph = document.querySelector('#secret-paragraph'); 这样, app.js中就引入了dom-loader.js中声明的变量. 我们还没有加入babel来编译ES6的语法, 因此声明变量暂时无法使用let或const. 之后, 执行npm run build之后就会将所有需要的js文件打包整合到bundle.js中, 在index.html中引入bundle.js文件, 应用就可以正常运行. 加入-p会优化压缩bundle.js: 1234\"scripts\": { \"build\": \"webpack src/js/app.js dist/bundle.js\", \"build-prod\": \"webpack src/js/app.js dist/bundle.js -p\"} 直到现在, 我们打开index.html的方式还是直接打开, 利用file协议, 但是在file协议下, 检查Network时, 所有asset的size都为0, 因为所有这些asset都是通过文件系统获取, 如果想要获取真正的size, 需要开启一个服务器, 在localhost或者是http协议下打开. 可以利用webpack-dev-server. webpack-dev-server先执行npm install --save-dev webpack-dev-server; 将package.json中”build”的值改成下面这样: 123\"scripts\": { \"build\": \"webpack-dev-server --entry ./src/js/app.js --output-filename ./dist/bundle.js\"} 由于我们对webpack的配置会越来越多, 因此现在开始将webpack的配置信息存储到另外的文件中, 在根目录下创建webpack.config.js, 一般来说是使用该名称, webpack会直接识别. 也可以使用其他名称, 但记得要在命令行的执行指令webpack-dev-server后添加--config FILENAME额外声明配置文件的名称. 现在就可以将package.json中webpack的配置转移: webpack.config.js 123456789var path = require('path'); // 输出路径需要是绝对路径, 因此要引入Node的path模块来帮助解决这个问题.module.exports = { entry: './src/js/app.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' }}; entry: 值可以是表示单个入口的字符串, 包含多个入口的数组, 也可以是含有多个alias的对象. path: path.resolve(__dirname, 'dist'): 输出路径必须是绝对路径. filename: 'bundle.js': bundle.js是习惯用名, 也可以是任何其他名字. package.json中这样修改: 1234\"scripts\": { \"build\": \"webpack-dev-server\", \"build-prod\": \"webpack -p\"} 但是执行npm run build不能正常运行, 因为webpack-dev-server只关注webpack.config.js中”filename”的值, 会忽略前面的路径path的值, 因此还需要在配置文件中声明publicPath: 12345678module.exports = { entry: './src/js/app.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', publicPath: '/dist' }}; 这样配置之后, 使用webpack与webpack-dev-server, 程序就都可以正常运行了. module-loadermodule-loader的作用是转换代码并确保项目中的文件正确加载. 下面以css-loader和style-loader为例简单说明loader的作用. css-loader &amp; style-loader使用webpack, 我们可以利用css-loader和style-loader为页面添加样式, css-loader的作用是处理import '../css/main.css';, 因为在默认情况下webpack无法理解对于css文件的引入, style-loader的作用是将引入的css样式以内联样式的形式添加到HTML中. 1.首先npm install --save-dev css-loader style-loader 2.在webpack.config.js中加入module-loader: 1234567891011module: { rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] } ]} 上述代码的意思是, 对于扩展名为css的文件, 使用’style-loader’和’css-loader’. loader的顺序很重要, 如果把css-loader放在style-loader之前, 样式就无法正常渲染, 因为webpack的执行loader的顺序是从后往前, 因此css-loader应该在style-loader之后. 3.添加正确loader之后的webpack.config.js: 123456789101112131415161718192021var path = require('path');module.exports = { entry: './src/js/app.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', publicPath: '/dist' }, module: { rules: [ { test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] } ] }}; 4.同时在app.js中引入css文件: 12import '../css/main.css';import '../css/input-elements.css'; plugin(插件)module-loader和plugin的作用看似很相似, 其实不然, 在上面的例子中, module-loader作用于每一个css文件, 但是plugin的作用范围只有bundle.js, 确切地说, 作用于bundle.js产生之前. 一个典型的插件是压缩插件, 尽管我们可以在npm scripts中对webpack的声明加入-p来执行压缩, 但是如果想要对压缩的规则进行进一步配置, 就需要用到插件. 在webpack.config.js中加入 1var webpack = require('webpack'); // 顶部 123456// 与module同一层级:plugins: [ new webpack.optimize.UglifyJsPlugin({ // ... })] 加入上述代码之后再执行npm run build, bundle.js与之前的执行生成的bundle.js相比文件体积就小了很多. 参考 webpack 2 Basics Tutorial","link":"/posts/2017/05/13/webpack2-basics/"},{"title":"[译]babel-preset-env","text":"看了两个webpack2基础的视频教程, 发现两位老师所用的babel-preset的差异, 于是查了一下两者的区别, 看到了一篇相关的文章, 尝试将其翻译. 原文: babel-preset-env: a preset that configures Babel for you. 使用babel-preset-env, 可以另外声明环境, 然后该preset根据你的声明自动激活必要的插件. 存在的问题现在, 有多个preset让我们选择, 以决定Babel应该支持编译具有哪一些特性的代码: babel-preset-es2015, babel-preset-es2016等: 增量支持不同版本的ECMAScript. babel-preset-es2015将含有ES6新特性的代码编译为ES5下的代码, babel-preset-es2016则将含有ES2016新特性的代码编译为ES6下的代码. babel-preset-latest: 支持编译所有ECMAScript版本下特性或处于stage4阶段的特性的代码(实际上两者是差不多的). 这些preset的问题就是: 它们都太”重”了, 即包含了过多在某些情况下不需要的功能. 比如, 现代的浏览器大多支持ES6的generator, 但是如果你使用babel-preset-es2015, 它会将generator函数编译为复杂的ES5代码, 这是没有必要的. 解决方案babel-preset-env和babel-preset-latest的功能很相似, 但使用babel-preset-env, 我们可以声明环境, 然后该preset就会只编译包含我们所声明环境缺少的特性的代码. 要注意, 这就意味着我们需要自己另外去安装激活某些插件或preset以处理某些实验性特性(这些特性往往不是babel-preset-latest的一部分). 使用babel-preset-env的好处是: 你不再需要es20xx preset. 浏览器对于特定的浏览器, 你也可以添加相关的配置: 根据browserslist对浏览器相关信息执行配置. 例如: 支持大部分浏览器最新的两个版本以及IE 7+: 123456789101112\"babel\": {\"presets\": [ [ \"env\", { \"targets\": { \"browsers\": [\"last 2 versions\", \"ie &gt;= 7\"] } } ] ]}, 支持超过市场份额5%的浏览器: 123\"targets\": { \"browsers\": \"&gt; 5%\"} 某个固定版本的浏览器: 123\"targets\": { \"chrome\": 56} Node.js如果你想要使用Babel实时编译Node的代码, babel-preset-env就特别有用, 因为它支持在配置中将Node的版本声明为当前版本, 这样每一次都会对Node的最新版本执行编译. 123456789101112\"babel\": {\"presets\": [ [ \"env\", { \"targets\": { \"node\": \"current\" } } ] ]}, 想看实例可以查看这个GitHub repo: async-iter-demo 配置babel-preset-env这部分简单介绍babel-preset-env的配置选项, 更多细节详见该preset的README文件. 模块系统(字符串, 默认为”common.js”)配置你想要将ES6模块编译为哪一种模块系统: 编译为其他流行的模块系统: “amd”, “commonjs”, “systemjs”, “umd” 不编译, 还是使用ES6模块系统, 则将值声明为false. include, exclude(数组, 默认为”[ ]”) 在include中声明的值一般是元素为插件名的数组, 表示在项目中使用这些插件(如改写有缺陷的原生特性的插件), 在include中一起声明和分别另外声明插件的效果是一样的. 在exclude中声明的值也是元素为插件名的数组, 但表示的是在项目中不可以使用这些插件. useBuiltIns(布尔值, 默认为false)Babel标准库本身含有针对新特性的polyfill. 使用babel-preset-env可以配置是否需要某一部分的polyfill. 使用polyfill有两种方式: 使用core-js polyfills(动词) ES5, ES6+的代码 安装该polyfill: npm install core-js --save 激活该polyfill: import &quot;core-js&quot;; 使用babel-polyfill polyfills core-js和regenetator runtime(在ES5中模拟generator) 安装该polyfill: npm install babel-polyfill --save 激活: import &quot;babel-polyfill&quot;; 两个中任何一个import声明都会被编译为针对特定环境的几个更细节的按顺序引入的import声明. 例如: 12345import \"core-js/modules/es7.string.pad-start\";import \"core-js/modules/es7.string.pad-end\";import \"core-js/modules/web.timers\";import \"core-js/modules/web.immediate\";import \"core-js/modules/web.dom.iterable\"; 需要注意的几点: 要确保某个需要的polyfill在项目中被激活一次, 比如在”main”模块中 使用useBuiltIns后, 浏览器下载的代码量就会变少(bundle.js文件更小). However, it does not save RAM, because the polyfill only installs what is missing. 要了解关于标准库中polyfill的更多信息, 可以查看”Setting up ES6”中的”Babel: configuring standard library and helpers“章节. 调试(布尔值, 默认为false)通过console.log()输出以下信息: 目标环境 使用的的转换规则 使用的插件 使用的polyfill 示例详见下一节. 示例以下例子从babel-preset-env的README文件中截取: 123456789101112{ \"presets\": [ [ \"env\", { \"targets\": { \"safari\": 10 }, \"modules\": false, \"useBuiltIns\": true, \"debug\": true }] ]} 在以上示例中, 设置了不编译模块, 我们可以使用webpack来处理import与export. 调试的输出结果如下: 123456789101112131415161718Using targets:{ \"safari\": 10}Modules transform: falseUsing plugins: transform-exponentiation-operator {} transform-async-to-generator {}Using polyfills: es7.object.values {} es7.object.entries {} es7.object.get-own-property-descriptors {} web.timers {} web.immediate {} web.dom.iterable {} babel-preset-env如何获取并判断配置信息 不同的JavaScript引擎支持哪些特性的根据来源: kangax’s compat-table plugin-features.js内声明了不同插件所含的特性 使用browserslist使preset理解”&gt; 1%”和”last 2 versions”等所表明的浏览器信息 接下来要实现的功能给予插件获取”环境”信息的权限接下来的计划是给予插件检视在当前”环境”下可以实现哪些功能的能力. 这将带来两个好处: 某些插件(比如针对对象的扩展运算符插件)现在需要对其配置决定是使用原生的功能还是polyfill. 如果该插件可以获取环境信息, 就不再需要手动进行配置. 基于Babel的压缩插件有能力决定是否要对某些特性执行转换(如箭头函数). 简化preset babel-preset-env中不再支持大多数基于ECMAScript版本的preset(如babel-preset-es2015, babel-preset-es2016). Babel团队现在正考虑在将来的Babel release中淘汰这些preset(比如通过弃用的方式(deprecation process)) 基于TC39进程(如stage-3等)的preset也因stage的不稳定性即将被淘汰, 某个提案的stage很有可能在2个月就发生变化. 因此, 直接通过插件来添加某些实验性特性是个更好的方法. 扩展阅读 Readme file of babel-preset-env Setting up ES6(如何配置Babel 6+) 参考 babel-preset-env: a preset that configures Babel for you","link":"/posts/2017/05/18/babel-preset-env/"},{"title":"相邻兄弟选择器","text":"在minimal主题的样式文件中发现了下面的代码, 对”+”号有点不理解, 于是在《CSS权威指南》里查了一下, 发现这是相邻兄弟结合符Adjacent Sibling Combinator, 也叫 相邻兄弟选择器. 1234header ul li + li + li { border-right:none; width:89px;} 语法因为之前在看这本书时就发现中文版有挺多错误, 而且很多解释都十分费解, 所以中英版的内容都看了, 果然发现中文版的翻译有一部分是错误的, 书中说明该结合符的功能时用了下面的例子: 选择紧接着, 具有共同父元素的元素123h1 + p { margin-top: 0;} 中文版对其的解释是: “选择紧接在h1元素后出现的所有段落, h1与p有共同的父元素. “ 英文原版是这样的: “selects any paragraph that immediately follows an h1 ele\u0002ment that shares a parent with the p element.” any在这里并不是所有的意思, 我认为这句话的意思应该是: 紧接在h1元素之后的一个p元素, 同时h1和p有共同的父元素. 经过测试, 也证实了我的想法. 不作用于第一个’+’前的元素然后又给出了另一个例子, 看到这个例子之后我发现, 有可能是因为这个例子对译者造成了影响, 这个例子是这样的: 123456789101112&lt;div&gt; &lt;ol&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;A list item&lt;/li&gt; &lt;li&gt;Another list item&lt;/li&gt; &lt;li&gt;Yet another list item&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123li + li { font-weight: bold;} 看到上述的样式, 我下意识地认为只有第二个li应该加粗, 因为我把li + li中的前一个当做第一个li了, 但实际上并没有这样指明, 因此li可以指任意li. 书上举出这个例子, 想要指明的概念是: 第一个li元素, 不会被这个选择器影响, 因此, 除了第一个以外的li, 其他li元素均加粗. 没有标签的纯文本不算是兄弟元素接下来书上举出了第三个例子, 在上述ul与ol之间插入一段文本, 说明了不使用任何标签的文本不能被当做兄弟元素, 相邻兄弟结合符会自动忽略文本. 可以结合其他选择器使用同时该结合符可以和其他选择器结合使用: 123html &gt; body table + ul{ margin-top: 1.5em;} 该选择器选择的是: html的子元素body下含有的table元素下紧接着的具有共同父元素的ul元素 理解了该选择器的功能之后, 就可以知道header ul li + li + li选择的是header元素下的ul元素下的第3个li元素. 应用现在有这样一种情况: 我手头上有一个公司的列表, 列表中的几乎每一个公司都有这样的这样的信息: 表示该公司的一幅图片以及描述图片的文本. 但是并不是所有公司都有图片, 而文本是全部都有的. 现在需要在页面上呈现这些内容, 有图片的公司只显示图片不显示文本, 对于没有图片的公司, 就显示文本. 这时, 就可以利用”+”选择器来达到隐藏某些文本的目的. 1234567891011121314&lt;div id=\"page-wrap\"&gt; &lt;img src=\"images/image-110.png\" alt=\"image\"&gt; &lt;span&gt;Text&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;img src=\"images/image-110.png\" alt=\"image\"&gt; &lt;span&gt;Text&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;span&gt;Text&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;img src=\"images/image-110.png\" alt=\"image\"&gt; &lt;span&gt;Text&lt;/span&gt; &lt;br&gt;&lt;br&gt; &lt;span&gt;Text&lt;/span&gt;&lt;/div&gt; 1234567891011img { vertical-align: middle; z-index: 9999; position: relative;}span { z-index: 1;}img+span { margin-left: -110px;} 设置负值外边距将紧接在img元素之后具有共同父元素的span元素”踢”到图片下方将其隐藏, 而对于不与img相邻的span元素, 不执行这样的操作. 仅设置外边距难以确保span被隐藏, 因此还需要再设置两者的z-index值保证span在img下方, 在img下设置position: relative;以确保z-index正常作用. 这个方法的好处在于即使图片出现问题, 我们还是能够获取文本信息. 但也有一些坏处: 被隐藏的文本如果过长就无法被图片覆盖, 如果图片是透明的, 也会出现问题. 这时就要考虑用visibility: hidden;或者display: none的方法了, 缺点是易用性没有设置负值外边距强. 参考 The CSS Definitive Guide(英文版49页, 中文版55页) CSS Specifications CSS Tricks: Fine Use for the Adjacent Sibling (“+”) Selector","link":"/posts/2017/05/18/adjacent-sibling/"},{"title":"操作DOM","text":"操作DOM练习, updating… Example 1 为 &lt;ul&gt; 添加一个类 bar: addClassToUl 为 &lt;li&gt; 添加颜色: addColorToLi 删除第 10 个 &lt;li&gt;: deleteListItem 在第 11 个 &lt;li&gt; 后面增加一个 &lt;li&gt; , 其文字内容为 “inserted element”: addListItem 点击任意 &lt;li&gt; 弹窗显示其为当前列表中的第几项以及列表的文字内容: clickAlert Demo 123456789101112131415161718&lt;body&gt; &lt;ul id=\"list\" class=\"foo\"&gt; &lt;li&gt;#0&lt;/li&gt; &lt;li&gt;&lt;span&gt;#1&lt;/span&gt;&lt;/li&gt; &lt;li&gt;#2&lt;/li&gt; &lt;li&gt;#3&lt;/li&gt; &lt;li&gt;&lt;ul&gt;&lt;li&gt;#4&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a target=\"_blank\" href=\"https://icyfish.github.io\"&gt;#5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;#6&lt;/li&gt; &lt;li&gt;#7&lt;/li&gt; &lt;li&gt;#8&lt;/li&gt; &lt;li&gt;#9&lt;/li&gt; &lt;li&gt;#10&lt;/li&gt; &lt;li&gt;#11&lt;/li&gt; &lt;li&gt;#12&lt;/li&gt; &lt;li&gt;#13&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function addClassToUl(classText){ // document.getElementById('list').className += (' '+ classText); document.getElementById('list').classList.add(classText);}addClassToUl('bar');function addColorToLi(index, color){ Array.from(document.getElementById('list').children)[index].style.backgroundColor = color;};addColorToLi(2, 'lightgreen');addColorToLi(4, 'lightblue');addColorToLi(6, 'lightpink');function deleteListItem(index) { document.getElementById(\"list\").children[index].remove();}deleteListItem(10);function addListItem(index, content){ var newElement = document.createElement('li'); var newContent = document.createTextNode(content); newElement.appendChild(newContent); var parentElement = document.getElementById('list'); var currentElement = parentElement.children[index]; parentElement.insertBefore(newElement, currentElement);}addListItem(11, 'inserted element');function clickAlert(){ var parentElement = document.getElementById(\"list\"); function alertTarget(e){ if(e.target &amp;&amp; e.target.nodeName === \"LI\") { alert(`The index is ${Array.from(parentElement.children).indexOf(e.target)}, the content is ${e.target.innerText}`); } } parentElement.addEventListener('click', alertTarget);}clickAlert();","link":"/posts/2017/06/05/dom-manipulation/"},{"title":"处理数组和字符串","text":"处理字符串和数组的一些方法(updated at 2017-06-04) 多维数组转换为一维数组123var arr = [[1],[2,3],[4]];var result = [].concat.apply([], arr);console.log(result); // [ 1, 2, 3, 4 ] 1234567891011121314151617var arr1 = [1, [2, [3, 4]], 5, [6]];var arr2 = [1, 2, 3, 4, [5, 6,[7,[8,[9,10]]]]];function mergeArray(arr, dimension){ if(!dimension || dimension &lt; 2){ console.log('Dimension should be greater or equal to 2'); return; } while(dimension &gt;= 2){ arr = [].concat.apply([], arr); dimension --; } return arr;}mergeArray(arr1,3)mergeArray(arr2,5) Merge an array of arrays 从数组中随机获取某个元素直接获取: var rand = myArray[Math.floor(Math.random() * myArray.length)]; 原型链中添加方法获取: 123Array.prototype.randomElement = function () { return this[Math.floor(Math.random() * this.length)]} 在原型链中手动添加了一个属性, 因此如果要获取内置数组方法时, 注意需要使用hasOwnProperty: 12345for (var prop in myArray) { if (myArray.hasOwnProperty(prop)) { //... }} 从数组中随机获取多个元素可以先将数组打乱, 再获取其中连续的一段: 123456var numbers = ['1','2','4','5','6','7','8','9','10'];numbers.sort(() =&gt; 0.5 - Math.random());var sliced = numbers.slice(0, 4);console.log(sliced);console.log(numbers); 将类数组对象转化为数组开发过程中有时会遇到需要操作类数组对象(array-like objects)的情况, 但无法对其使用数组方法, 因此很多时候需要把类数组对象转化为数组以便于操作, 常见的类数组对象有: arguments(函数参数), NodeList… 可以利用以下三种方法对类数组对象进行转化: Array.from() ... (spread operator) Array.prototype.slice.call() 例: 12345678910111213function listFrom() { return Array.from(arguments);}function listSpread() { return [...arguments];}function listSlice() { return Array.prototype.slice.call(arguments);}const list1 = listFrom(1, 2, 3); // [1, 2, 3]const list2 = listSpread(1, 2, 3); // [1, 2, 3]const list3 = listSlice(1, 2, 3); // [1, 2, 3] 使用数组方法的另一种方式例: 12345function square(n) { return n * n;}const arr = [4, 8] 现在要对数组arr中的每一个元素执行平方操作, 常用的操作方式是: arr.map(square);如果想要像underscore.js或者lodash中那样的方式使用数组方法, 可以使用以下方式: Array.prototype.map.call() [].map.call() 应用到例子中就是: Array.prototype.map.call(arr, square) [].map.call(arr, square) 组合字符串最快的方式根据JSPerf上的标准, +=是组合字符串最快的方式. 不过或许不适用于所有浏览器版本. 如果要在DOM中实现字符串的组合, 似乎事先将字符串组合好, 再添加到DOM中是比一个一个添加更好的选择. 不过最好还是根据实际情况, 自己进行测试. 参考 Best way to concatenate strings in JavaScript? jsperf - concat/join-with-push/join-without-push jsperf - String building 扩展 Why is string concatenation faster than array join? 在字符串中替换部分字母在JavaScript, 字符串不可变(immutable), 因此不可以直接在原字符串本身执行替换.可以手动在String的原型链中定义replaceAt()方法: 1234567String.prototype.replaceAt = function(index, replacement) { return this.substr(0, index) + replacement + this.substr(index + replacement.length); // return this.substr(0, index) + replacement + this.substr(index + 1, this.length);} var greet=\"Hello World\";console.log(greet.replaceAt(2, \"!!\")); // 输出: He!!o World 重复输出字符串内容1234567891011String.prototype.repeatify = String.prototype.repeatify || function(times) { var str = ''; for (var i = 0; i &lt; times; i++) { str += this; } return str;};console.log('hello'.repeatify(3)); // hellohellohello 加入String.prototype.repeatify ||以测试是否已定义过该方法, 如果没有, 则添加, 如果已定义, 则不添加, 使用原定义内容.","link":"/posts/2017/05/26/dealing-with-string/"},{"title":"Mac下安装npm包出现错误","text":"在Mac下安装某些npm包时会返回这样的错误信息:env: node\\r: No such file or directory. 从错误信息的\\r中可以推测出可能是代码行末字符的原因. 编辑文本文件时, 在我们按下回车键之后, 虽然从编辑器中看不出什么不同, 但是实际上插入了一个隐藏的字符, 我们称其为”line ending”(行末字符). 不同的操作系统处理行末字符的方式不同. DOS/Windows下, 行末字符为\\r\\n, 而在Unix下, 行末字符是\\n. 那么, 问题就可以这样解决, 假设你在全局安装了xxx包: 首先从Terminal进入该npm包可执行文件所在的目录, 我是在: /usr/local/lib/node_modules/xxx/bin 然后在命令行中执行sudo vim xxx 进入vim后输入命令: :set ff=unix 除了上述解决方式, 还可以使用dos2unix. 参考 GitHub Issue Dealing with line endings DOS vs. Unix Line Endings Convert DOS line endings to Linux line endings in vim","link":"/posts/2017/07/06/npm-mac-problems/"},{"title":"cookie基础","text":"cookie是服务器贴到客户端, 由客户端维护的状态片段, 并在下一次向同一个服务器发送请求时一同发送这段数据. cookie常用于保存用户的登录信息或其他不便于保存在服务器端数据库的size较小的数据. cookie简单介绍HTTP请求是stateless的, 下一次请求无法得知上一次HTTP请求所包含的状态数据, cookie使得HTTP请求变得stateful. 过去常使用cookie来存储客户端的数据, 但实际上这样的用法并不是那么合适, 因为cookie会跟着每一次http请求一同被发送, 对web app的性能有较大的影响. 比较推荐的方式是使用Web storage API(localStorage 和 sessionStorage)或IndexDB. 创建cookie服务器接受到HTTP请求之后, 可以在传送回HTTP响应的报文中添加Set-Cookie首部. 使用Set-Cookie创建的cookie一般存储在客户端(浏览器), 然后在客户端下一次向同一个服务器发送请求时一并发送cookie. 可以对cookie设置过期时间, 域名, 路径, secure, HttpOnly等属性. Node.js下使用”Set-Cookie”: 1response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']); cookie的类型有两种, 一是会话cookie, 关闭浏览器cookie就被删除, 不对其设置Expires或Max-Age属性, 该cookie就是会话cookie, 不过浏览器可以使用session restoring把会话cookie转化为持久cookie. 持久cookie存储在硬盘, 计算机重启之后依然存在. 在超出Expires日期或Max-Age的时间后才被删除. Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; cookie还有secure属性, 添加了secure属性的cookie只有在HTTPS或SSL协议下才会被发送到服务器. 不过尽管声明secure属性, 一些敏感信息还是不应该存储在cookie中, 因为cookie本身是不安全的, 虽然加了secure属性, 但是无法真正保护cookie信息. 从Chrome 52和Firefox 52开始, http协议下的站点不允许在cookie中添加secure属性. 在默认情况下, 通过HTTPS协议传输的请求默认包括secure属性. HttpOnly也是cookie中的一个重要属性, 在cookie中添加这一属性可以防止XSS攻击, 因为添加该属性后, 就不能通过Document.cookie API获取cookie的值, cookie只能被发送到服务器. 维持服务器端会话的cookie没有必要通过JavaScript获取, 因此可以对这种类型的cookie设置HttpOnly属性. Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly cookie的作用域cookie存在作用域, domain和path属性定义了cookie的作用域: 即cookie应该被发送到哪一个URL. domain属性中声明了哪些host可以接收到该cookie, 如果不声明domain的属性值, 其默认值就是document.location.host的值, 但不包括其下的子域名. 如果声明了domain属性值, 其下的子域名也会被包括. path属性则声明URL的路径, 默认值为发送Set-Cookie首部所在URL的path值. 如果设置了path=/docs, 任何以/docs为开头的path均会被包括, 如: /docs /docs/Web/ /docs/Web/HTTP /docsforcookies 如果想要重写某个cookie, 除了匹配name之外, 还需要匹配需要被重写的cookie的domain, path的值. 否则只会将该cookie添加到document.cookie字符串中. 假设现在有个cookie: foo=hello; 已知其domain值为.icyfish.github.io, path值为/. 我们要将该cookie值修改为foo=hi: 12345// ✖️错误的方式✖️document.cookie = \"foo=hi\";// ✔️应该这样做✔️document.cookie = \"foo=hi; path=/;domain=.icyfish.github.io\"; Subcookies由于每个域名下可使用的cookie数量有限制, 因此开发者想出了使用subcookie的方法以突破这个限制, 常见的形式是: name=a=b&amp;c=d&amp;e=f&amp;g=h 这样的话, 单个cookie就能够存储多个名值对信息, 不会超过浏览器cookie数量限制. 不过这样做有一个缺陷, 需要自己实现一种解析方式以解析这种形式的cookie. 一些服务端框架, 例如YUI的Cookie辅助工具, 就支持读写subcookie. cookie 和 session 服务器利用cookie实现session(会话), session指的是客户端(浏览器)与服务器之间处于激活状态的一次连接所关联的一系列数据. 一般来说, 每个web app的cookie, 对于每一次session, 都存在一个独一无二的识别码, 通常叫做session id. Web框架Ruby on Rails负责处理大部分session和cookie的相关内容: Rail提供了一个session对象, 可以在其中存储任何你想要存储的数据. 同一个客户端之后的请求可以获取存储在其中的数据 在每一次请求之始, Rails会自动检查session cookie的情况 如果cookie存在, 就据此来查找session数据 如果cookie不存在, 创建新的session和cookie 请求结束时, 保存session数据, 以便未来的请求获取这些数据 管理session状态: 方法1: 将session状态保存在服务器内存中 获取数据快速高效 session数据可能过大影响服务器性能 影响web服务器之间的负载均衡 方法2: 将session 状态保存在硬盘的文件中 方法3: 将session 状态保存在数据库 大部分web框架会提供方法用以控制session的存储: 提供一个对象存储和恢复session数据 服务器最终会删除过期的session数据 参考 What is HTTP? Sessions &amp; Cookies Sessions Cookies and Sessions MDN: HTTP cookies MDN: Set-Cookie 3 Things About Cookie You May Not Know HTTP cookies explained Browser Cookie Limits","link":"/posts/2017/07/10/cookie-the-basics/"},{"title":"移动设备300毫秒延迟问题","text":"过去, 移动端浏览器对于touchend和click事件添加了300-350毫秒的延迟, 以检测用户是否要执行两次点击. 移除300毫秒延迟从安卓设备第一个版本的Chrome开始, 如果用户禁用捏合双指缩放, 该延迟就不会生效. 然而捏合双指缩放是个重要的辅助特性. 在Chrome 32(2014年的版本)中, 为了使站点在移动端有更好的体验, 浏览器添加了移除300毫秒延迟的功能, 不过捏合双指缩放依然可用. Firefox和IE/Edge很快在这之后也做出了同样的实现, safari则在2016年3月的ios9.3中实现. 这样的改变对用户体验来说是极大的提升, 关于用户动作响应时间与web性能的关系详见: introduction to RAIL 想要移除300-350毫秒延迟, 只需在HTML的&lt;head&gt;标签中添加以下标签: 1&lt;meta name=\"viewport\" content=\"width=device-width\"&gt; 以上标签将视窗宽度设置为与设备宽度相同, 对于移动端优化的站点, 是最佳实践. 如果添加了这部分标签, 在移动设备上, 浏览器会优化文本的可读性, 也不再需要捏合双指缩放, 此时点击就不会有延迟. 如果无法添加上述标签, 可以使用touch-action: manipulation达到上述效果, 可以在整个页面添加, 也可以在某个元素上添加. 123html { touch-action: manipulation;} 不过Firefox不支持touch-action: manipulation, 因此添加&lt;meta&gt;标签是更好的方式. 无法执行捏合双指缩放是否对可用性造成影响并不会, 捏合双指缩放依然可用, 操作系统会提供相类似的功能. 在安卓设备上, 可以使用Magnification gestures(放大手势). 适配旧版浏览器FT Labs的FastClick库捕捉touch事件, 就不会延迟触发, 同时还移除了两次点击手势. 该库通过对比触发touchstart事件时屏幕上的手指个数以及触发touchend事件时屏幕上的手指个数以区分滑动和点击. 不过添加touchstart事件处理器会对性能有所影响, 类似滑动等底层的交互会因调用该事件处理器被延迟, 因为要检查事件默认行为是否被禁用(event.preventDefault()). 不过FastClick库内部做了一些实现, 在浏览器没有300毫秒延迟时, 不会添加touch事件处理器. 参考 300ms tap delay, gone away Fastclick ios延迟 Stackoverflow - fastclickjs","link":"/posts/2017/08/11/300-ms-delay/"},{"title":"模块模式","text":"Mastering the Module Pattern(2014) 阅读笔记 模块模式可以帮助开发者更好地组织代码, 在代码中不再过度使用this和prototype. 创建模块123(function () { // code})(); 使用IIFE创建新的作用域, JS本身不存在”私有”的概念, 用IIFE可以模拟”私有”, 包围所有的业务逻辑, 只返回所需的部分, 避免其他部分暴露在全局作用域. 123var Module = (function () { // code})(); 对所创建的模块进行命名, 可以在任何时候调用, 也能将其传到另一个模块. 私有方法可以在模块内部创建私有方法: 1234567var Module = (function () { var privateMethod = function () { // do something };})(); “return”如果想在模块内部定义可供外部使用的公有方法, 可以将方法以对象字面量的形式return, 这样在所创建的模块的命名空间中就存在该方法, 例: 123456789var Module = (function () { return { publicMethod: function () { // code } };})(); 以这样的形式调用: 1Module.publicMethod(); 返回匿名对象字面量最简单的模式就是以上所提及的模式, 在模块中返回匿名对象字面量: 1234567891011121314151617var Module = (function () { var privateMethod = function () {}; return { publicMethodOne: function () { // 此处可以调用 privateMethod() }, publicMethodTwo: function () { }, publicMethodThree: function () { } };})(); Locally scoped Object Literal12345678910111213var Module = (function () { var myObject = {}; // 私有对象字面量 var privateMethod = function () {}; // 私有方法 myObject.someMethod = function () { // 暴露在外部的方法 }; return myObject;})(); 最后一行返回了myObject, 我们定义的模块Module并不在意私有对象字面量是否匿名, 因此对其命名是个好方法, 在最后一行返回, 可以更好地组织代码. Stacked locally scoped Object Literal和前一个示例很像, 不过使用了”传统”的对象字面量声明形式: 12345678910111213141516var Module = (function () { var privateMethod = function () {}; var myObject = { someMethod: function () { }, anotherMethod: function () { } }; return myObject;})(); locally scoped Object Literal 在使用函数之前先定义该函数以避免变量提升(因为function myFunction () {}会遇到变量提升的问题). 使用var myFunction = function () {}'语法就不用在意这个问题, 因为我们必须在使用前定义, 同时这个方法也使调试变得更容易, JS解释器会根据我们在代码中定义的顺序渲染各行代码. “stacked”对象字面量的方法还会降低代码可读性, 使其看起来十分冗余. and there is no obvious locally scoped Object namespace for me to bolt public methods onto. 暴露式模块模式1234567891011121314151617181920var Module = (function () { var privateMethod = function () { // private }; var someMethod = function () { // public }; var anotherMethod = function () { // public }; return { someMethod: someMethod, anotherMethod: anotherMethod };})(); 调用”私有”方法12345678910111213141516171819var Module = (function () { var privateMethod = function (message) { console.log(message); }; var publicMethod = function (text) { privateMethod(text); }; return { publicMethod: publicMethod };})();// Example of passing data into a private method// the private method will then `console.log()` 'Hello!'Module.publicMethod('Hello!'); 不仅限于私有方法, 私有数组和私有对象也可使用这样的方法获取: 12345678910111213var Module = (function () { var privateArray = []; var publicMethod = function (somethingOfInterest) { privateArray.push(somethingOfInterest); }; return { publicMethod: publicMethod };})(); 添加模块利用实现扩展模块: 下例中ModuleTwo为Module的扩展模块, 添加了extension方法 123456789101112131415161718192021var Module = (function () { var privateMethod = function () { // private }; var someMethod = function () { // public }; var anotherMethod = function () { // public }; return { someMethod: someMethod, anotherMethod: anotherMethod, };})(); 12345678910var ModuleTwo = (function (Module) { Module.extension = function () { }; return Module; })(Module || {});// Module || {} 防止Module为undefined 私有方法命名惯例下划线_以标示私有方法: 123456789101112131415var Module = (function () { var _privateMethod = function () { // private stuff }; var publicMethod = function () { _privateMethod(); }; return { publicMethod: publicMethod };})();","link":"/posts/2017/08/24/module-pattern/"},{"title":"Session相关","text":"Session相关知识点(笔记) Session是什么from: Session 是什麼 Session机制类似: 顾客在饮料店点单后获取号码牌, 号码牌上有你点饮料的相关信息, 根据号码牌向店员索取自己所点的饮料 让Client取得号码牌: 使用Cookie 直接輸出並嵌入頁面之中的方法（就是要你把號碼背起來) 拿號碼牌去 Server 要資料: 使用Cookie 運用標準的 Query string/POST body方法(只要能把號碼傳到 Server 上，任何方法都行) 就算沒有 Cookie 的存在，Session 機制也可以正常運作(传递sessionid) 因为大多数浏览器实现了Cookie机制, 因此大多数网站预设采用Cookie发号码牌和兑换资料, 建立连接时把Cookie上传到Server, Server传回资料时带上Cookie 不使用Cookie实现session通过隐藏表单传递sessionid - Hidden Form Fields1&lt;input type = \"hidden\" name = \"sessionid\" value = \"12345\"&gt; 服务器发送含有sessionid的隐藏表单, 表单提交后该信息通过浏览器的GET/POST请求传递到服务器. 缺陷: 点击&lt;a&gt;标签不会发送表单 使用URL重写传递sessionid - URL Rewriting类似以下形式: http://tutorialspoint.com/file.htm;sessionid=12345 缺陷: 无法共享URL(个人信息同时也被共享) 破坏缓存 第三方也能看到sessionid, 可能造成会话劫持, 不安全 额外服务器负荷 跳转其他站点/请求特定URL丢失信息 访问同一站点若不存在特定值会导致信息丢失 php中: session.use_trans_sid = 1Cookie-based Session这里的cookie, 指的是存储资料方式的不同, 不是指領號碼牌時, 是否有用到 cookie. 最原始session: 资料都存在server, 对于流量大的网站服务, 存在无数台server, 而client由哪个server提供服务是随机的, 因此不适合将资料放在server cookie-based session 将资料暂存于cookie, client自己负责保存. 但是cookie 4kb size limit, 因此很多网站服务选择cookie-based与服务端存储并行. 这类cookie会被加密, 只有server能解, client无法存取, 因此安全性较高, 但还是有风险, 这也是采用并行存储的另一原因. Session传值利用session机制存储资料, 让不同页面间互传资料, 通常使用Query String或POST body等方法, 把资料往server传之后, 在server端将client上传的资料存在session中(?), 之后的连线后开启其他页面, 因为使用同一个号码牌(?), 所以在不同页面依然能读到前一次存储于session的状态. (?) 不理解 &gt;&gt;&gt; url传值，cookie传值，session传值的笔记 PHP实现Session传值Session通过为每个访问者创建一个独立的ID（UID）并储存基于UID的变量来运行。UID既存储在cookie中，又在URL中展现出来。 将用户信息存入PHP Session之前，必须先启动Session 1234&lt;?php session_start(); ?&gt; &lt;html&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; 存储Session变量 123456789101112&lt;?php session_start(); // store session data $_SESSION['views']=1;?&gt;&lt;html&gt;&lt;body&gt;&lt;?php//retrieve session dataecho \"Pageviews=\". $_SESSION['views'];?&gt;&lt;/body&gt;&lt;/html&gt; 1234567&lt;?phpsession_start();if(isset($_SESSION['views']))$_SESSION['views']=$_SESSION['views']+1;else$_SESSION['views']=1;echo \"Views=\". $_SESSION['views'];?&gt; 删除session 释放指定session变量: 123&lt;?php unset($_SESSION['views']);?&gt; 将session全部删除: 123&lt;?phpsession_destroy();?&gt; 参考 Fred’s blog HTTP the definitive guide Session Tracking Beware of URL rewriting 3种 web 会话管理的方式","link":"/posts/2017/08/30/session/"},{"title":"webpack tips","text":"观看视频: Totally Tooling Tips: Webpack Tips笔记, 视频发布时间: 2017-08-11. 内容大多为性能相关. uglifyJsPlugin 压缩ES5代码1234567const webpack = require('webpack');module.exports = { plugins: [ new webpack.optimize.UglifyJsPlugin() ]}; BabiliPlugin 压缩ES2015代码不编译到ES5的情况下使用该插件 12345678const webpack = require('webpack');const BabiliPlugin = require('babili-webpack-plugin\");module.exports = { plugins: [ new BabiliPlugin() ]}; 压缩CSS如果不使用 ExtractTextPlugin, 记得加上minimize: true 123456789101112131415161718const webpack = require('webpack');module.exports = { module: { rules: [ { test: /\\.css$/, use: [ \"style-loader\", { loader: \"css-loader\", options: { minimize: true } } ] } ] }}; 使用 ExtractTextPlugin: 12345678910111213141516171819const webpack = require('webpack');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = { module: { rules: [ { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: 'css-loader' }) } ] }, plugin: [ new ExtractTextPlugin('styles.css') ]}; 使用 ExtractTextPlugin 的好处是不需要parse两次代码, 同时还会有缓存的机制提升一部分性能. tree-shaking处理import和export, 只export所需的import. remove your dead code in terms of your imports and exports unused code is not removed by webpack, it is done by a minifier like uglifyjs 使用webpack的生产模式1webpack -p 或者利用插件: 1234567const webpack = require('webpack');module.exports = new webpack.DefinePlugin({ \"process.env\": { \"NODE_ENV\": JSON.stringify(\"production\") }}) source-map-explorersource map explorer分析项目中各部分模块的组成情况 处理Vendors12345678910111213141516const webpack = require('webpack');module.exports = { context: __dirname, entry: { app: './src/app.js', vendor: ['react', 'react-dom'] }, output: { path: __dirname + '/dist', filename: 'bundle.js' }, plugins: [ new webpack.optimize.CommonsChunkPlugin('vendor', 'vendor.js') ]}; 大部分vendor多个JS文件共用, 可以提取出来以便浏览器缓存, 提升程序性能. CommonsChunkPlugin 与code splitting相关 1234567// before// static import所有模块import { renderProduct } from './components/product';import { renderReview } from './components/review';renderProduct();renderReview(); 123456789// 引入&amp;打包最少的所需模块(static imports)import { renderProduct } from './components/product';renderProduct();// 动态引入部分模块(dynamic import)import('./review.js) .then((module) =&gt; { module.renderReview(); }) Dynamic Imports 类似moment.js的库moment.js常用于处理时间相关的操作, 如果引入moment.js的默认配置, 代码size很大, 大部分代码是localization相关的代码, 除非是国际化的站点, 否则其实不需要加载全部这类相关的代码, 即使需要, 也可以使用动态加载的方式. 使用ContextReplacementPlugin只加载所需的代码. 123456789101112const webpack = require('webpack');module.exports = { plugins: [ new webpack.ContextReplacementPlugin( // path to directory which should be targeted by the plugin /moment[\\/\\\\]locale/, // regular expression matching locales that should be included /(en-gb|en-us)\\.js/ ) ]}; lodashlodash是个模块化的库, 可以只引入所需的模块. 使用 lodash-webpack-plugin和babel-plugin-lodash 相关资源 Webpack for Real Tasks: Decreasing Front-End Size and Improving Caching Getting the Most out of CommonsChunkPlugin Vendor and Code Splitting in Webpack 2","link":"/posts/2017/09/12/webpack-tips/"},{"title":"Code Snippets","text":"代码片段收集 else-if123456789101112131415161718// 过去 else-if 形式function customerValidation(customer) { if (!customer.email) { return error('email is require') } else if (!customer.login) { return error('login is required') } else if (!customer.name) { return error('name is required') } else { return customer }}// ES6 中使用三目运算符const customerValidation = customer =&gt; !customer.email ? error('email is required') : !customer.login ? error('login is required') : !customer.name ? error('name is required') : customer 利用argumentsfrom: Interviewing a front-end developer: 实现log函数 输出参数的值: log('hello'); // hello log('hello', 'world');// hello world 输出自定义字符串+参数: logWith('hello', 'world'); // (app) hello world 兼容bind 123456Function.prototype.bind = Function.prototype.bind || function(context) { var self = this; return function(){ return self.apply(context, arguments); };} touch 事件模拟 scroll 事件12345678910111213141516171819202122232425'touchstart': 'handleTouchStart','touchmove': 'handleTouchMove','touchend': 'handleTouchEnd', handleTouchStart: function(event) { this.startClientY = event.touches[0].clientY this.startScrollTop = _scroll_dom.scrollTop()},handleTouchMove: function(event) { this.currentClientY = event.touches[0].clientY this.currentScrollTop = _scroll_dom.scrollTop() // if handleTouchEnd is not triggered clearTimeout(this.touchTimer) this.touchTimer = setTimeout(function() { self.handleTouchEnd() }, 5)},handleTouchEnd: function() { clearTimeout(this.touchTimer) var isSwipeUp = this.currentClientY &lt; this.startClientY var isNoScroll = this.currentScrollTop === this.startScrollTop if (isSwipeUp &amp;&amp; isNoScroll) { doSomething() }} 从 url 中获取参数值123function getUrlParam(name) { return decodeURIComponent((new RegExp('[?|&amp;]' + name + '=' + '([^&amp;;]+?)(&amp;|#|;|$)').exec(location.search) || [null, ''])[1].replace(/\\+/g, '%20')) || null;}","link":"/posts/2017/09/12/code-snippets/"},{"title":"Quotes","text":"Something valuable privilege-awareness There are things that I have had in my life that have been privileges that have allowed me to get where I am and other people getting to the same part have same spot who have to work a lot harder and it’s not fair. I have a daughter and a son and I don’t want them to come up in an industry where my daughter has to work harder than my son where she’s going to be second-guessed, so the fact that I’m white and I’m male and I’m heterosexual and I’m an American and I’m employed and I’m educated. Those are my privileges. So I’m simply talking about myself to say we need to be aware of our own privileges so that we can be more empathetic of other people that have a more difficult path to get to the same spot. I don’t have a solution to the problems, but I know it starts with talking about it more and I would like for each of you to take a challenge away from this to ask yourselves what is my privilege, what is my story and what is my priviledge and talk about it more. So I am given an opportunity to say it and I think we need to declare out privilege.","link":"/posts/2017/12/02/quotes/"},{"title":"Iterators 与 for-of 循环","text":"Iterators 与 for-of 循环 循环遍历数组的几种方式for循环1234var myArray = [1, 2, 3]for (var index = 0; index &lt; myArray.length; index++) { console.log(myArray[index]);} ES5 forEach1234var myArray = [1, 2, 3]myArray.forEach(function (value) { console.log(value);}); forEach的内部函数无法使用 break 或 return(?) for-in1234var myArray = [1, 2, 3]for (var index in myArray) { console.log(myArray[index]);} 用for–in循环遍历数组不可取: index是字符串而不是数字: &quot;0&quot;, &quot;1&quot;, &quot;2&quot;等 有时候不以正常的顺序循环遍历 无法正常遍历某些数组, 如: 1234567891011121314var a = [] a[5] = 3 for (var i = 0; i &lt; a.length; i++) { console.log(a[i]);}/* 正常for循环结果: undefined undefined undefined undefined undefined 3*/ 12345678910var a = []a[5] = 3for (var x in a) { // 忽略了数组元素中的前5个元素, 只有3被输出 console.log(a[x])}/* for-in结果: 3*/ 数组中若有可枚举属性(enumerable property)?,也会被遍历 12345678910111213Array.prototype.foo = 1var a = [1, 2, 3, 4, 5]for (var x in a){ console.log(x)}/* 输出: 0 1 2 3 4 foo*/ for-of 遍历数组最简单直接的方式 没有 for-in, forEach存在的那些缺陷 与for-in的区别:for-in循环遍历对象属性for–of循环遍历数据(如数组中的各个元素) for-of还可以循环遍历其它类型的集合, 如类数组对象: NodeLists, 字符串等: 123for (var chr of \"😺😲\") { console.log(chr)} 也可以用于遍历Set和Map对象: 12345var words = ['a', 'b', 'c']var uniqueWords = new Set(words)for(var word in uniqueWords){ console.log(word)} 对于Map对象, 需要先解构再遍历: 123for (var [key, value] of phoneBookMap) { console.log(key + \"'s phone number is: \" + value);} 不过for-of不可直接用于遍历一般的对象(plain object), 如果想要遍历这种对象的属性, 应该借助for-in或者Object.keys(): 1234var someObject = { 0: 'a', 1: 'b', 2: 'c', 'hello': 'world' };for (var key of Object.keys(someObject)) { console.log(key + \": \" + someObject[key]);} for-of的原理for-of通过调用对象方法起作用, Array, Map, Set等可遍历的对象都有个共同特点, 它们有遍历器(iterator)方法. for-of无法遍历一般的对象是因为一般对象的属性中没有遍历器方法, 不过我们可以手动在对象原型中添加该方法myObject[Symbol.iterator](), 就能够使该对象可以被for-of循环遍历: 使用for–of循环遍历对象, 首先调用了[Symbol.iterator]()方法, 调用后的结果是返回一个新的可遍历的对象, 这个对象的属性中有个next()方法, for-of在每一次循环中都会调用一次该方法. 以下是一个简单的可遍历对象的例子: 12345678var zeroesForeverIterator = { [Symbol.iterator]: function () { return this; }, next: function () { return {done: false, value: 0}; }} 对于以上的对象, 每次next()被调用, 都会返回同样的结果, 告诉for-of循环: 1).遍历还未结束; 2). 下一个值是0.此时,for (value of zeroesForeverIterator) {}就是个无限循环. 含有遍历器方法的对象还实现了可选的.return()方法和.throw(exc)方法. 如果循环由于抛出异常或break或return声明过早退出, for-of会调用.return(). 不过大部分情况下, 不需要用到.return()方法, .throw(exc)更特殊, for-of从不调用该方法. (more about it?) 123for (VAR of ITERABLE) { STATEMENTS} 以上for-of循环, 实际上执行的操作是(简单版本): 1234567var $iterator = ITERABLE[Symbol.iterator]();var $result = $iterator.next();while (!$result.done) { VAR = $result.value; STATEMENTS $result = $iterator.next();} 以上只是简单的版本, 大致体现了for-of是如何实现的, 实际上更复杂, 但对于理解上并没有太大的帮助, 因此省略某些方法的实现(例如是如何处理return()的). for-of很好用, 但是底层的实现比较复杂. 使用for-of截至原文完成的时间(2015-04-29), 某些浏览器还不支持for-of, 在Chrome中, 可打开chrome://flags找到“Experimental JavaScript”并进行启用. 在服务端想要使用该特性, 在执行Node指令时加上--harmony选项. Resources Iterators and the for-of loop Next articles will be: Generators in ES6 In Depth. CSS Modules Questions In This Article: cmd + f + ?","link":"/posts/2018/01/02/iterators-and-the-for-of-loop/"},{"title":"Collection of Web Tools","text":"updating… Object &amp; Array ExplorerJavaScript Object Explorer JavaScript Array Explorer","link":"/posts/2018/01/09/collection-of-web-tools/"},{"title":"判断元素是否在可视区域","text":"元素是否在可视区域initial version: 12345678910111213function isElementInView(element) { if (!document) return false; let viewHeight = document.documentElement.clientHeight; // 容器可见区域高度 let elemTopToViewTop = element.getBoundingClientRect().top; //元素顶端到可见区域顶端的距离 if ( elemTopToViewTop &lt;= viewHeight &amp;&amp; elemTopToViewTop &gt;= 0 &amp;&amp; elementHasHeight ) { return true; } return false;} 需要完善的点: 判断 left 值 DOM 要有宽高 display: none &amp; visibility: hidden 时应该是不可见的 final version: 123456789101112131415161718192021222324252627282930313233343536373839404142function isVisible(el) { let { display, visibility } = getComputedStyle(el); return display !== \"none\" &amp;&amp; visibility !== \"hidden\";}function getWindowHeight() { return window.innerHeight || document.documentElement.clientHeight;}function getWindowWidth() { return window.innerWidth || document.documentElement.clientWidth;}function elHasWidthHeight(el) { return el.clientHeight &gt; 0 &amp;&amp; el.clientWidth &gt; 0;}function isPartOfElementInViewport(el) { const rect = el.getBoundingClientRect(); const windowHeight = getWindowHeight(); const windowWidth = getWindowWidth(); const vertInView = rect.top &lt;= windowHeight &amp;&amp; rect.top + rect.height &gt;= 0; const horInView = rect.left &lt;= windowWidth &amp;&amp; rect.left + rect.width &gt;= 0; return vertInView &amp;&amp; horInView &amp;&amp; elHasWidthHeight(el) &amp;&amp; isVisible(el);}function isElementAllInViewport(el) { const rect = el.getBoundingClientRect(); const windowHeight = getWindowHeight(); const windowWidth = getWindowWidth(); return ( rect.top &gt;= 0 &amp;&amp; rect.left &gt;= 0 &amp;&amp; rect.bottom &lt;= windowHeight &amp;&amp; rect.right &lt;= windowWidth &amp;&amp; elHasWidthHeight(el) &amp;&amp; isVisible(el) );} DOM 元素各种高度值clientHight VISIBLE content (CSS height) &amp; padding offsetHeight VISIBLE content (CSS height) &amp; padding + border + scrollbar (no margin) scrollHeight ENTIRE content &amp; padding (visible or not) Reference Is Element In Viewport DOM height","link":"/posts/2019/06/27/element-in-view/"},{"title":"2017年度React开源项目推荐","text":"via. 25 Amazing Open Source React.js Projects for the Past Year (v.2018) No.1 React NavigationReact Native开发中实现移动端页面的导航, 具体见文档. No.2 LottieReact Native开发中实现页面动画效果的库, 由Airbnb的工程师开发. No.3 Reactide首个专用于React应用开发的IDE No.4 ReactXPReact Native开发中实现跨平台(Android, IOS)开发的库, 文档地址, 由微软工程师开发. No.5 React-vr帮助开发者使用React创造VR应用的框架, 由Facebook工程师开发. No.6 Redux-offline使用React/React Native和Redux创建离线优先的应用 No.7 Formik在React中处理表单. Introducing Formik 0.9.0 No.8 Joplin使用React Native开发的todo-app, 可在PC, MacOS, Linux, Android, IOS平台之间同步. No.9 React CosmosReact组件的调试工具. 作者是Ovidiu Cherecheș No.10 Git Point使用React Native开发的GitHub移动客户端, ios与安卓端均可用. No.11 React MoveReact 动画库, 示例: Circle Inferno Draggable List Animated Mount/Unmount No.12 downshiftReact input 组件(包括autocomplete/dropdown/select等), 由paypal工程师Kent C. Dodds开发 示例 介绍 No.13 Razzle无需复杂配置创建同构的React应用 No.14 hackernews同构版本利用 React 和 GraphQL 开发的同构版本的 Hacker News No.15 React Datasheet类似Excel的React表格组件 No.16 React flight利用React创建组合动画, Dotan Nahum的作品 No.17 React-overdrive实现动画转换效果. Tal Bereznitskey的作品 No.18 React-fns将浏览器命令式的API转化为声明式的React组件 No.19 Haul开发 React Native App 的命令行工具, Mike Grabowski的作品 No.20 React-imgpro用于处理图片的React组件, Nitin Tulswani的作品 No.21 React Sight使用React开发的可视化工具 No.22 Prop-types实现运行时类型检查, Dan Abramov的作品. No.23 Sketch-to-react-native将 sketch 文件转化成 React Native 组件 No.24 React-tv使用React创建电视应用, Raphael Amorim的作品 No.25 Create-react-kotlin-app无需复杂配置使用 Kotlin 创建 React 应用","link":"/posts/2018/01/09/react-projects-in-2017/"},{"title":"JavaScript Inside 1 - engine, runtime, callstack","text":"How JavaScript works: an overview of the engine, the runtime, and the call stack JS引擎JavaScript 引擎: 最出名的是 V8 引擎, Chrome 和 Node.js 内部使用的就是 V8 引擎. V8 引擎大概长这样: 从图片中可以看出, V8引擎由两部分组成: 内存堆 – 主要控制内存的分配 调用栈 – 代码执行时栈是如何被构造的 执行环境 (The Runtime)浏览器提供了一些API (如: setTimeout). 这些API不是由JS引擎提供的. 因此, 编写浏览器环境下的JS代码时, 不仅依赖JS引擎, 还依赖 Web API (如 DOM, AJAX, setTimeout) 提供给我们的能力. 于是, 我们需要 Event Loop 与 callback queue. 调用栈JavaScript 是单线程的编程语言, 这意味着它只有一个调用栈, 因此一次只能做一件事. 调用栈是一种数据结构, 记录了我们的程序执行到了哪一个位置. 当执行到某个函数的时候, 这个函数就位于执行栈的顶部. 从函数中return意味着该函数从执行栈顶部弹出. 下面看一个代码实例: 12345678function multiply(x, y) { return x * y;}function printSquare(x) { var s = multiply(x, x); console.log(s);}printSquare(5); 当引擎开始执行上述代码时, 调用栈首先是空的, 之后的步骤则如下图所示: 执行栈的每一个入口被叫做栈帧(Stack Frame). 当函数抛出错误时, 引擎会根据调用栈的顺序抛出错误: 12345678910function foo() { throw new Error('SessionStack will help you resolve crashes :)');}function bar() { foo();}function start() { bar();}start(); 爆栈指的是超出了调用栈可以接受的最大size. 这种场景很容易发生, 特别是当我们在代码中使用递归时: 1234function foo() { foo();}foo(); 当引擎开始执行这段代码时, foo函数被调用. 因为foo函数内部调用了本身, 同时并没有终止条件. 因此每一次foo被调用, 它就被加调用栈中, 超过一定次数之后就会爆栈. 单线程语言, 处理代码相对比较简单, 因为我们不需要处理多线程语言中才会出现的复杂情景, 比如: 死锁(deadlocks). 然而单线程带来的限制也比较多, 当在主线程的函数运行太慢怎么办呢? 并发与事件循环(Concurrency &amp; the Event Loop)当调用栈中的函数执行事件太长, 阻住了下一个函数的执行, 怎么办呢? 比如, 当我们使用JavaScript在浏览器环境下执行复杂的图片转换程序. 你也许会问, 这哪里算是问题? 但实际情况是, 在执行图片转换程序时, 浏览器的主线程被阻塞, 无法处理其他事件. 这意味着浏览器进行渲染, 无法执行其他代码, 体验差到极致. 如果你对产品的流畅性有比较高的要求, 这就是个很大的问题了. 当然这并不是唯一的问题. 一旦调用栈中有过多的任务需要执行, 会有很长一段时间, 浏览器无法处理用户交互. 大多数浏览器会采取相应的抛异常措施, 询问用户是否需要关闭网页. 那么要如何解决这个阻塞的问题呢? 答案是异步回调.","link":"/posts/2019/06/30/JavaScript-Inside-1/"},{"title":"CSS定位笔记(MDN)","text":"阅读MDN - CSS定位学习笔记 没有z-index属性的元素堆叠层级 元素没有z-index属性的情况下, 各个元素在z轴从底部到顶部的顺序如下: 背景及根元素的border 后代没有定位属性的block, 根据其在HTML中的顺序排列 后代有定位属性的元素, 根据其在HTML中的顺序排列 CSS定位的各个属性 各个属性: (均为计算后属性) static: 默认的定位, 相当于没有定位属性, top, right, bottom, left, z-index在此情况下均无效. relative: 相对定位属性, 含有该属性的元素, 其top/left/bottom/right的值表明该元素相对正常位置(static情况下的位置)的距离. 根据文档的正常流进行定位, 因此元素会被默认添加space, 不会影响任何其他元素的定位. 如果z-index的值不是默认值auto, 会创建一个新的堆叠层, relative属性不作用与含有这些属性的元素: table-*-group, table-row, table-column, table-cell, table-caption absolute: 脱离正常文档流, 不会被默认添加space. 元素相对于其最近的含有定位元素的祖先元素进行定位, 如果没有符合条件的祖先元素, 则相对于其最初的包含块进行定位. 最终的位置由top, right, bottom, left决定. 如果z-index的值不是默认值auto, 会创建一个新的堆叠层. 这种元素可以有外边距且不和其他外边距重叠. fixed: 脱离正常文档流, 不会被默认添加space. 相对于屏幕视口的位置, 不会随着页面滚动而改变位置. 最终的位置由top, right, bottom, left决定, 通常会创建一个新的堆叠层. 当祖先元素含有这些属性之一时: transform, perspective, filter, 那么相对位置的对象就不是视口而是这些祖先元素. In printed documents, the element is placed in the same position on every page.? (absolute/fixed: 绝对定位属性, 元素top/left/bottom/right的值表明该元素相对其包含块的距离. 如果元素存在margin外边距, 其相对距离也要相应地变化.) sticky: 粘性定位属性, 不脱离正常文档流, 相对于文档流根元素和包含块的位置, 包括表格相关的元素, 相关的距离不会影响任何其他元素的位置. 通常会创建一个新的堆叠层. 根据规范, sticky 属性不作用于含有overflow: hidden或auto的元素. 大部分情况下, 绝对定位元素height和width值为auto以适应元素内部内容的显示. 不过, non-replaced 绝对定位的元素可以通过声明top和bottom的值, 保存height为默认值auto来补足垂直方向的空间. 水平方向通过改变left和right亦然. Note: 如果top和bottom均声明了值, 以top为准; 如果left和right均声明了值, 在有从左到右（LTR）阅读习惯的国家, 以left为准, 在有从右向左（RTL）阅读习惯的国家, 以right为准. 浮动块影响元素堆叠 浮动块的位置处于定位块和非定位块之间: 有浮动块的情况下, 各个元素在z轴从底部到顶部的顺序如下: 背景及根元素的border 后代没有定位属性的块级元素, 根据其在HTML中的顺序排列 浮动块 后代有定位属性的元素, 根据其在HTML中的顺序排列 浮动块不会影响没有定位属性的块级元素的层级, 但是会影响元素内部的内容. 因此更加确切的z轴顺序是: 背景及根元素的border 后代没有定位属性的块级元素, 根据其在HTML中的顺序排列 浮动块 后代没有定位属性的内联元素 后代有定位属性的元素, 根据其在HTML中的顺序排列 本例(点击子标题链接进入MDN文章查看)中, 除了未定位的所有块级元素都是半透明的, 以更好地说明层叠的顺序, 如果未定位块(DIV #4)的不透明值改变, 就会发生奇怪的现象: 背景和该块级元素会变成在浮动块和定位块的上层. 这是因为规范比较奇特: 给元素添加opacity值会创建一个新的堆叠层, 详见What No One Told You About Z-Index 理解z-index 我们可以在定位元素上添加z-index属性, 属性值可以是正整数, 零或负整数, 表明了元素在z轴上的层级. z-index属性没有声明值时, 默认该元素在0层. 如果多个元素的z-index值相同, 元素堆叠层级规则遵循没有z-index属性的元素堆叠层级规则","link":"/posts/2018/02/07/css-position/"},{"title":"对象与函数","text":"在JavaScript中, 一切皆对象, 函数也是特殊的对象. 对象在JavaScript中, 对象 是名值对的集合, 值可以由多个名值对组成. 名值对是互相关联的一对名和值 Name/Value Pair. 名可以被定义多次,但在特定的 执行环境 中只能匹配一个值. 12345678910Address:{ Street: 'Main', Number: 100, Apartment: { Floor: 3, Number: 301 }} 对象的属性对象及其属性(将属性和方法统称为属性, 下同)都存在于内存空间, 对象可以获取到与其相关联的属性(have a reference to them, 即获取到的是指向属性所在内存空间的地址). 有两种操作符可以获取属性值: object[&quot;property&quot;]: 括号(Computed Member Access Operator) object.property: 点号(Member Access Operator) 多用点号操作符, 因为更简洁也更利于调试. 对象字面量(Object Literals)var person = {}: 用对象字面量方法创建对象. 123456789var person = { firstname: 'John', lastname: 'Doe', address: { street: '111 Main St.', city: 'New York', state: 'NY' }}; 123var person = new Object();person.firstname = 'John';person.lastname = 'Doe'; 两种方法中, 对象字面量创建对象的方法更好, 比new更简洁, 用处更大. 比如: 12345678910111213141516171819202122var john = { firstname: 'John', lastname: 'Doe', address: { street: '111 Main St.', city: 'New York', state: 'NY' }};function greet(person){ console.log('Hi ' + person.firstname);}greet(john);greet({ firstname: 'Jane', lastname: 'Doe'});// 可以直接传入对象作为参数 尽管语法不一致, 实际的原理是一样的, 都是在内存空间中创建对象及属性. JSON与对象字面量过去传输数据常用XML格式: 1234&lt;object&gt; &lt;firstname&gt;Mary&lt;/firstname&gt; &lt;isAProgrammer&gt;true&lt;/isAProgrammer&gt;&lt;/object&gt; 但因为XML格式包含太多额外的标记, 在传输过程中会浪费很多带宽, JSON的出现解决了这样的问题.JSON实际上是对象字面量语法的一个子集. 并不属于JavaScript, 但因为格式和JS对象十分相似, 所以JavaScript解析JSON格式的数据十分容易. JavaScript中内置了JSON.stringify()将JS对象转化为JSON, JSON.parse()将JSON解析为JS对象. 1234{ \"firstname\": \"Mary\", \"isAProgrammer\": true} 函数也是对象JavaScript中, 函数是一等公民 任何其他数据类型可以做的事, 函数也能做到, 如: 将函数赋给变量 作为参数传递给其他函数 可以被即时创建 1234567function log(a) { a();};log(function(){ console.log('hi');}); 函数也是对象, 因此可以为函数关联属性. 其中两个比较特别的属性是函数名和代码. 而函数名并不是必要的, 不存在函数名的函数是匿名函数. 我们所写的那段代码实际上是函数作为对象的其中一个属性, 并不是函数本身, 同时这个属性是可以被调用的. 123456function greet(){ console.log('hi');}// 给函数(对象)greet关联language属性greet.language = 'English'; console.log(greet.language); 当函数greet被创建时, 该函数被置于内存空间, 在上述情况下, 该函数是全局对象的属性. 函数声明与函数表达式表达式(expression): 会返回值, 可以将其储存在一个变量中, 但并非必要. 123456a = 3;// 31 + 2;// 3a = {greeting: 'hi'};// Object {greeting: \"hi\"}; 以上三者都为表达式, 因为都返回了值, 表达式返回的可以是任何类型的值. 声明(statement): 不会返回值. 12345var a;if(a === 3){} 以上代码中a === 3是表达式, 返回布尔值, if语句是声明. 函数声明: 12345greet();function greet(){ console.log('hi');}; 函数声明直到执行时才返回值, 在执行环境的创建阶段(creation phase)被置于内存空间, 即被提升(hoisting), 因此在声明之前的位置可以调用函数. 函数表达式: 1234567anonymousGreet(); // 不可以在这里调用var anonymousGreet = function(){ console.log('hi');};// anonymousGreet();//在这里调用才能够执行// 函数表达式不会被提升(no hoisting), 因为事先置于内存空间的是var anonymousGreet;, 因此上述代码会抛出错误. 值(by value)与引用(by reference)变量(原始类型)通过值传递 123456789// by valuevar a = 3;var b;b = a;a = 2;console.log(a); // 2console.log(b); // 3 将某个原始类型值(primitive value)赋值给变量a, 此时a就指向了那个值在内存空间所在的地址; b = a: 变量b指向一个新的内存空间地址, 那个地址所存储的值是a变量所指向值的拷贝, 因此b的值为3; 因为存储在不同的地址, 因此之后再改变a的值不会影响到b的值. 变量(对象)通过引用传递 12345678910111213141516171819202122var c = {greeting: 'hi'};var d;d = c;c.greeting = 'hello'; // mutateconsole.log(c); // Object {greeting: 'hello'};console.log(d); // Object {greeting: 'hello'};function changeGreeting(obj) { obj.greeting = 'Hola'; // mutate};changeGreeting(d);console.log(c); // Object {greeting: 'Hola'};console.log(d); // Object {greeting: 'Hola'};c = { greeting: 'howdy'};console.log(c); // Object {greeting: 'howdy'};console.log(d); // Object {greeting: 'Hola'}; 将对象(包括函数)赋值给变量a时, a指向对象在内存空间所在地址; b = a: 变量b不会指向新的内存空间地址, 而是指向a所指向的地址, 没有新的对象被创建; 因此改变a和b的值都会影响到对方. changeGreeting(d);通过传入函数的方式改变d的行为同样也会影响到c. 所有对象都是通过引用传递. c = { greeting: 'howdy'}; 赋值操作符会在内存空间创建一个新地址, 此时c就不再指向原地址, 而d的指向不变, 因此出现c和d值不同的情况. 参数(arguments) 当函数的执行环境被创建时, JS引擎除了创建变量环境(container for variables), this, 外部环境(for reference), 还创建了另一个特殊的变量arguments.arguments是所有参数值的集合, 是类数组元素, 并非数组. 设置参数默认值: 12345678910function greet(firstname, lastname, language){ console.log(firstname); console.log(lastname); console.log(language);}greet();// undefined// undefined// undefined 尽管greet函数在定义时有三个参数, 但还是可以不传递任何参数调用greet函数, 这是JavaScript的特性, 在大多数编程语言中不可以这样调用, 由于变量声明提升(Hoisting), 结果出现三个undefined, 但这不是我们想要的结果, 可是实际过程中不传递参数直接调用函数的情况很可能出现, 可以通过以下方法避免出现undefined的情况. 1234567891011121314151617181920212223242526272829function greet(firstname, lastname, language){// 1. 为参数设定默认值 language = language || 'en';// 2. 通过arguments变量获取参数数量// 如果没有参数, 在控制台中提示// 并直接返回, 中断函数的执行 if(arguments.length === 0){ console.log('Missing parameters'); return; } console.log(firstname); console.log(lastname); console.log(language); console.log(arguments);}greet(); // \"Missing parameters\"greet('John', 'Doe');// John// Doe// en// [\"John\", \"Doe\"]greet('John', 'Doe', 'es');// John// Doe// es// [\"John\", \"Doe\", \"es\"] 在ES6中可以这样设定默认值: 123456789101112function greet(firstname='John', lastname='Doe', language='en'){ console.log(firstname); console.log(lastname); console.log(language); console.log(arguments);}greet();// John// Doe// en// [] ‘this’this的值取决于函数是如何被调用的. 123456789101112131415var c = { name: 'The c object', log: function(){ this.name = 'Updated c object';// 这里的this执行对象c, 因此this.name改变的是对象c的name属性 console.log(this); // Object {name: \"Updated c object\"} var setname = function(newname){ this.name = newname; // console.log(this); // Window } setname('Updated again'); console.log(this); // Object {name: \"Updated c object\"} }}// c.log();console.log(name); // \"Updated again\" 对于上述代码的第二个console.log(this);, 因为在对象c内定义了函数表达式setname, 并在内改变了name的值, 因此预期输出的是Object {name: &quot;Updated again&quot;}, 但实际上并非如此, 通过在setname函数中输出this值发现, 这个this指向全局对象(浏览器中是Window), 因此setname实际上是在全局环境中定义了name变量, 在全局环境输出name可以发现这里的name值才是”Updated again”. 为了避免发生这样的错误, 可以预先定义this的值: 1234567891011121314var c = { name: 'The c object', log: function(){ var self = this; self.name = 'Updated c object'; console.log(self); // Object {name: \"Updated c object\"} var setname = function(newname){ self.name = newname; } setname('Updated again'); console.log(self); // Object {name: \"Updated again\"} }}c.log(); 因为对象通过引用传递, self与this一样指向对象c, 可以通过self改变对象的属性. 在setname函数中, 没有声明self的值, 通过作用域链到外部寻找self变量, 于是找到了在log方法内定义的指向对象c的self. 参考 JavaScript: Understanding the Weird Parts","link":"/posts/2016/10/28/objects-functions/"},{"title":"创建对象与原型继承","text":"继承指使某个对象 关联 另一个对象的属性和方法. 大多数编程语言中运用的继承类型为基于类的继承(Classical Inheritance), 而JavaScript中的继承类型为基于原型的继承(Prototypal Inheritance). 原型假设现在有一个对象obj, obj有prop1属性, 可以通过.操作符获取这个属性值: obj.prop1. 在JavaScript中, 所有对象(包括函数)都有一个隐藏的属性(无法直接获取的属性):原型属性. 原型属性的作用是关联到另一个对象proto(The property is simply a reference to another object proto). proto还能关联另一个proto. 形成了一个原型链(Prototype Chain) 如上图所示, 我们想通过obj.prop2获取prop2的值, 但obj本身并没有这个属性, 那么就会通过原型链寻找proto中是否有需要的属性. 如果有另一个对象obj2, obj2可以与obj1共享同一个原型对象, 甚至同一条原型链, 如下图, 如果调用obj2.prop2, 返回的是与obj1.prop2同样的属性值, 指向的是内存空间的同一位置. 可以通过__proto__为对象设置原型对象, 但在 实际应用中不应该这样做,对性能不利. 123456789101112131415161718192021222324var person = { firstname : 'Default', lastname : 'Default', getFullName: function(){ return this.firstname + ' ' + this.lastname; }}var john = { firstname: 'John', lastname: 'Doe'}// don't do this EVER! for demo purpose only!!!john.__proto__ = person;console.log(john.getFullName()); // John Doevar jane = { firstname: 'Jane'}// share the same proto objectjane.__proto__ = person;console.log(jane.getFullName()); // Jane Default 一切皆对象在JavaScript中, 一切皆对象(或原始类型) Everything is an object(or a primitive). 它们都有原型对象, 除了base object(对象的原型对象), 下例中的a.__proto__. 12345678910var a = {};var b = function(){};var c = [];console.log(a.__proto__); // Object {}console.log(a.__proto__.__proto__); // nullconsole.log(b.__proto__); // function () {}console.log(b.__proto__.__proto__); // Object {}console.log(c.__proto__); // [Symbol(Symbol.unscopables): Object]console.log(c.__proto__.__proto__); // Object {} 对象的内省Reflection: An object can look at itself, listingand changing its properties and methods. Reflection: 在传统的面向类环境中，检查一个实例（JavaScript中的对象）的继承祖先（JavaScript中的委托关联）通常被称为内省（或者反射）。 – You Don’t Know JS for-in: 以任意顺序迭代对象中的可枚举属性. for-in与数组: 1234567Array.prototype.myCustomFeature = \"cool\";var arr = ['John', 'Jane', 'Jim'];for(var prop in arr){ console.log(prop + ': ' + arr[prop]);} 从上述代码看出, 数组的索引实际上是属性名, 但在原型对象中加入自己定义的属性之后, 用for-in也迭代出了该属性, 因此不要在数组中使用for-in, 应该用一般的for循环或forEach. hasOwnProperty: 用这个方法判断属性是否只存在于对象本身, 而不是在原型链的原型对象中. 123456789101112131415161718192021222324252627282930313233var person = { firstname: 'Default', lastname: 'Default', getFullName: function(){ return this.firstname + ' ' + this.lastname; }}var john = { firstname: 'John', lastname: 'Doe'}john.__proto__ = person;john.getFullName(); // \"John Doe\"for (var prop in john){ console.log(prop + ': ' + john[prop]);}// firstname: John// lastname: Doe// getFullName: function(){// return this.firstname + ' ' + this.lastname;// }for (var prop in john){ if(john.hasOwnProperty(prop)){ //运用`hasOwnProperty`方法获取只存在于对象内的属性 console.log(prop + ': ' + john[prop]); }}// firstname: John// lastname: Doe Underscore库中的extend方法(运用了对象的内省), 见下例👇, 执行_.extend(john, jane, jim);之后, john就有了jane和jim的属性, 除了exdend方法, 还有extendOwn方法: 12345678910111213141516171819202122232425262728293031323334var person = { firstname: 'Default', lastname: 'Default', getFullName: function(){ return this.firstname + ' ' + this.lastname; }}var john = { firstname: 'John', lastname: 'Doe'}var jane = { address: '111 Main St.', getFormalFullName: function(){ return this.lastname + ', ' + this.firstname; }}jane.__proto__ = person;var jim = { getFirstName: function(){ return firstname; }}_.extend(john, jane, jim);// _.extendOwn(john, jane, jim);for (var prop in john){ console.log(prop + ': ' + john[prop]);} 1234567891011121314151617181920212223// extendfirstname: Defaultlastname: Defaultaddress: 111 Main St.getFormalFullName: function (){ return this.lastname + ', ' + this.firstname;}getFullName: function (){ return this.firstname + ' ' + this.lastname;}getFirstName: function (){ return firstname;}// extendOwnfirstname: Johnlastname: Doeaddress: 111 Main St.getFormalFullName: function (){ return this.lastname + ', ' + this.firstname;}getFirstName: function (){ return firstname;} extend方法中首个参数对象接受其后参数对象的属性, 包括后面的对象的原型属性, 而且如果有相同属性, 后面对象的属性会覆盖第一个参数对象属性. extendOwn与extend相似, 但不包括后面对象的原型属性. 1234567891011121314151617181920212223// An internal function for creating assigner functions.var createAssigner = function(keysFunc, undefinedOnly) { return function(obj) { var length = arguments.length; if (length &lt; 2 || obj == null) return obj; for (var index = 1; index &lt; length; index++) { var source = arguments[index], keys = keysFunc(source), l = keys.length; for (var i = 0; i &lt; l; i++) { var key = keys[i]; if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key]; } } return obj; };};// Extend a given object with all the properties in passed-in object(s)._.extend = createAssigner(_.allKeys);// Assigns a given object with all the own properties in the passed-in object(s)_.extendOwn = _.assign = createAssigner(_.keys); 创建对象构造器函数与new操作符123456function Person(){ this.firstname = 'John'; this.lastname = 'Doe';}var john = new Person();console.log(john) new 创建一个空对象 调用Person函数, 新的执行环境被创建 将 this 指向所创建的空对象 Person内定义的firstname和lastname成为新创建对象的属性 如果在构造器函数中没有声明返回的值, 返回的就是新创建的对象 123456789function Person(firstname, lastname){ this.firstname = firstname; this.lastname = lastname;}var john = new Person('John', 'Doe');console.log(john);var jane = new Person('Jane', 'Doe');console.log(jane); 利用构造器函数(Function Constructor)和new创建对象时, 会给创建出的对象自动关联一个原型对象, 上述对象的原型对象是constructor为👇的Object{}:1234function Person(){ this.firstname = 'John'; this.lastname = 'Doe';} __proto__与prototype1234567891011121314151617181920function Person(firstname,lastname){ this.firstname = firstname; this.lastname = lastname;}var john = new Person('John','Doe');var jane = new Person('Jane','Doe');console.log(john.__proto__ === Person.prototype); // true// 因为上述声明成立, 所以可以通过下面👇的方法给john的原型对象定义属性Person.prototype.greet = function(){ console.log('Hello, '+ this.firstname + ' ' + this.lastname);};john.greet();console.log(john.__proto__); 一般利用.prototype给对象定义方法, 在构造器函数中定义属性, 其实也可以直接在构造器函数中定义方法, 但因为在JavaScript中, 函数是对象, 会占用内存空间, 见上例, 如果在构造器内定义greet方法, 那么由这个构造器所创建出的每个对象中都含有greet方法的拷贝, 这样就占用更多的内存空间. 而如果在.prototype内定义方法, 不管创建出多少个对象, 这个方法在内存空间只存在一次. 内置构造器函数123456var a = new Number(3);console.log(a); // Number {[[PrimitiveValue]]: 3}var b = new String('john');console.log(b);// String {0: \"j\", 1: \"o\", 2: \"h\", 3: \"n\", length: 4, [[PrimitiveValue]]: \"john\"} 利用内置构造器函数创建出的变量a, b是形式为原始类型的对象, 不同的类型有不同的内置属性和方法, 也可以自己定义属性和方法: 12345678910111213141516171819202122String.prototype.isLengthGreaterThan = function(limit){ return this.length &gt; limit;};console.log('John'.isLengthGreaterThan(3)); // true// JavaScript会自动将字符串转换为对象, 因此上述声明成立, 但不会自动转换数字Number.prototype.isPositive = function(){ return this &gt; 0;};// console.log(3.isPositive()); // SyntaxError// 除非必要, 否则不要用构造器函数创建原始类型var a = Number(3);console.log(a.isPositive()); // truevar b = 3;console.log(a == b); // falseconsole.log(a === b); // true Object.create与原型继承用构造器函数所实现的继承是模仿其他语言中的类式继承, 而用Object.create实现的是真正的原型继承. 12345678910111213141516var person = { firstname: 'Default', lastname: 'Default', greet: function(){ return 'Hi ' + this.firstname + ' ' + this.lastname; }}var john = Object.create(person);console.log(john); // Object {}john.firstname = 'John';john.lastname = 'Doe';console.log(john); // Object {firstname: \"John\", lastname: \"Doe\"} polyfill: 对于不支持某些特性的浏览器, 使用polyfill来实现同样的功能. (Code that adds a feature which the engine may lack.) Object.create的polyfill简化版: 12345678910if(!Object.create){ Object.create = function (o){ if(arguments.length &gt; 1){ throw new Error('Object.create implementation only accepts the firstparameter'); } function F() {}; F.prototype = o; return new F(); };} 参考 JavaScript: Understanding the Weird Parts","link":"/posts/2016/11/12/object-creation-prototype/"},{"title":"Node相关知识点","text":"学习Node过程中需要了解的一些相关基础概念, 包括文件处理, 网络相关概念, 以及npm的一些知识点. 文件处理二进制数据Binary Data: 以二进制形式存储的数据(通常是数字, 由0和1组成), 每个1或0是1bit(1 binary digit). 二进制与十进制数据: 字符集 字符集(Character Set): 以数字的形式表示字符, 每个字符用一组不同的数字集合来表示. 常见的字符集有Unicode, ASCII. Unicode示例: h-104e-101l-108l-108o-111 字符编码 字符编码(Character Encoding): 以二进制的形式存储字符, 最常见的字符编码是UTF-8. 在处理服务器端数据时, 需要处理二进制数据, 字符集以及进行字符编码. JavaScript可以处理字符集和数字之间的转化, 但是无法对字符编码以及二进制数据进行处理. 因此Node扩展了处理二进制数据以及字符编码的功能. BufferBuffer是暂时存取需要转移的数据的区域, 存储容量有限制. (a temporary holding spot for data being moved from one place to another[Intentionally limited in size]). Node中的Buffer对象内置了许多方法用以处理二进制数据, Buffer内存储的数据形式默认是二进制. 1234567891011var buf = new Buffer('Hello','utf8');console.log(buf); // &lt;Buffer 48 65 6c 6c 6f&gt;// 数据以16进制的形式显示, 但实际是以二进制的形式存储console.log(buf.toString()); // Helloconsole.log(buf.toJSON()); // { type: 'Buffer', data: [ 72, 101, 108, 108, 111 ] }console.log(buf[2]); // 108buf.write('wo');console.log(buf.toString()); // wollobuf.write('wowoworld');console.log(buf.toString()); // wowow Buffer是有限的数据集合, 上例中的buf被初始化为存储5个字符, 存储的容量不能被改变, 最多只能占用初始化时的那些内存空间. ES6 Typed Arrays 原来JavaScript无法处理二进制数据, 但ES6中引入了处理的机制. 不过在Node中依然是libuv处理二进制数据. 123456789var buffer = new ArrayBuffer(8); // 创建一个字节长度为8(8bytes)的Buffervar view = new Int32Array(buffer); // 每个整型数字占用32bits空间, view是类型数组, 在这里只可以存储两个元素, 因为buffer的存储空间只有64bits. view[0] = 5;view[1] = 15;console.log(view);console.log(buffer); fs.readFile 12345678910111213var fs = require('fs')var greet = fs.readFileSync(__dirname + '/greet.txt');// 同步读取文件: 直到buffer被填满, 再进行下一步操作 // 配置文件使用同步读取, 对于较大的文件使用异步读取速度更快console.log(greet);var greet2 = fs.readFile(__dirname + '/greet.txt', 'utf8',function(err, data){ console.log('Async: ' + data);});console.log('Done!'); Error-First Callback: Node中的回调函数大多将error对象作为第一个参数 读取文件时, 会首先将文件内容转换为二进制数据存入buffer再进行处理, 但使用buffer有个问题,如果一下子处理过多的buffer, 会占用太多的内存空间, 耗费较多时间, 为了解决这个问题, 引入了stream的概念. StreamStream: A sequence of data made available over time. Pieces of data that eventually combine into a whole. 直播的英文是Live-Streaming, 利用stream分段传输影片内容. Chunk: A piece of data being sent through a stream. Data is split in ‘chunks’ and streamed. buffer和stream stream继承自EventEmitter. stream是抽象的父类(Abstract[Base] Class),不直接操作stream函数构造器, 操作继承自stream的对象(Custom Stream). 有多种类型的stream: Writable Stream Readable Stream Duplex Stream Transform Stream Duplex Stream与Transform Stream的区别 可读(readable)和可写(writable)都是对于Node来说的, 比如浏览器与服务器之间的request和response, request对于Node是可读的, response是可写的. fs.createReadStream ReadStream继承自Readable, Readable继承自Stream, Stream继承自EventEmitter 12345678910var fs = require('fs');var readable = fs.createReadStream(__dirname + '/greet.txt', {encoding:'utf8', highWaterMark: 32 * 1024});var writable = fs.createWriteStream(__dirname + '/greetcopy.txt');readable.on('data', function(chunk){ console.log(chunk.length); writable.write(chunk);}); 读取文件, 然后把文件内容填充入buffer, 如果文件内容小于buffer的存储容量, 会输出所有数据至一个buffer, 如果超过一个buffer的容量, 会分成多个buffer输出. 默认一个buffer容量为64kb, highWaterMark: 32 * 1024将一个buffer的容量设置为32kb. Pipe Pipe: 连接两个stream, 一个可读stream和一个可写stream. Connecting two streams by writing to one stream what is being read from another. In Node you pipe from a Readable stream to a Writable stream. pipe方法在所有readable stream的prototype上. 123456789var fs = require('fs');var readable = fs.createReadStream(__dirname + '/greet.txt');var writable = fs.createWriteStream(__dirname + '/greetcopy.txt');// readable.on('data', function(chunk){// writable.write(chunk);// });readable.pipe(writable); pipes can be chained: Method Chaining: a method returns an object so we can keep calling more methods. (Sometimes it returns the parent object(called ‘cascading’) and sometimes some other object.) 12345678var fs = require('fs');var zlib = require('zlib'); // 创建gzip文件的模块, 功能是压缩文件 var readable = fs.createReadStream(__dirname + '/greet.txt');var compressed = fs.createWriteStream(__dirname + '/greet.txt.gz');var gzip = zlib.createGzip(); // 创建transform stream(既可读又可写), 接收文件中的chunk, 将其压缩.readable.pipe(gzip).pipe(compressed); 处理文件和数据时应首先想到使用stream和异步操作, 有利于性能提升. 网络TCP/IP 客户端发出的请求和服务器作出的响应数据本身需要遵循某种标准(HTTP, FTP, SMTP), 它们之间的信息传输方式也需要遵循某种标准(TCP[Transmission Control Protocol]).客户端和服务器之间传递信息时, 需要知道信息传输的具体目的地, IP(Internet Protocol)就是双方识别的依据. 当客户端和服务器成功识别, 操作系统会开启网络套接字(socket), 以完成信息的传输. socket每一对客户端和服务器之间建立一个网络连接需要2个socket(client socket &amp; server socket).Client Socket的组成是IP地址加端口号(Port), 端口号的数值不固定, 由操作系统随机生成.Server Socket的组成是域名加端口号(80), 80是所有网络传输的标准端口号. 在网络中, socket不断开启关闭. 当发出一个请求时, socket开启一段时间后关闭. 在某些情况下, socket是一直处于开启状态的, 比如在编辑Google Doc时, 因为文档内容需要和云端同步, 所以此时socket不可以关闭. port 当计算机接收packet时, 可以通过端口(port)知道packet应该传输到哪一个程序.When a program is setup on the operating to receive packets from a particular port, it is said that the program is ‘listening’ to that port. HTTPHTTP(Hypertext Transfer Protocol): 在网络服务器和客户端之间传输的数据需要遵循的规则(格式). MIME type: MIME(Multipurpose Internet Mail Extensions): 互联网媒体类型. A standard for specifying the type of data being sent. 原来是用于标识邮件的附件文件类型, 因此得名. 后来HTTP也使用这个标准. 例子: application/json, text/html, image/jpeg Serialize 将对象转换成其他可以被传输, 存储的格式. 常见的格式有JSON, CSV, XML. Routing 根据http请求分配在页面上显示的内容(Mapping http request to content). http请求不直接请求文件, 而是向服务器发送请求, 服务器根据请求内容执行不同的操作: 向客户端发送已存储在服务器中的文件 从数据库获取数据并发送 实时创建HTML文件 npm包管理系统 包管理系统(package management system): 自动安装, 更新应用, 管理应用版本及依赖. 版本语义化 semantic versioning MAJOR.MINOR.PATCH(1.8.2) MAJOR: 比较大的变化, 代码有可能无法运行. MINOR: 添加一些新特性, 代码依旧运行. PATCH: 修复一些bug, 代码依旧运行. 在package.json中管理版本依赖: 123\"dependencies\": { \"moment\": \"^2.18.0\" } “^2.10.6”: ‘^’允许minor和patch的更新.“~2.10.6”: ‘~’只允许patch的更新. 参考 Learn and Understand NodeJS What is a Web Socket","link":"/posts/2016/12/13/about-node/"},{"title":"数组, 栈, 队列","text":"利用JavaScript学习基础的数据结构: 数组, 栈, 队列. 数组一般来说, 数组存储一系列同一种数据类型的值.但因为JavaScript是动态类型(Dynamic Typing), 数组中的类型不需要一致, 可以包含不同类型的值. 12345678910111213141516var arr = [ 1, false, { name: 'Tony', address: '111 Main St.' }, function(name){ var greeting = \"Hello \"; console.log(greeting + name); }, // 为什么这个function是函数表达式? (inside of an object, created on the fly) \"hello\"];// 可以这样调用函数arr[3](arr[2].name); // \"Hello Tony\" 在JavaScript中,数组是一个可以修改的对象.如果添加元素,它就会动态增长.在C和Java等其他语言里,我们要决定数组的大小,想添加元素就要创建一个全新的数组,不能简单地往其中添加所需的元素. 添加和删除数组首尾元素 12345678910111213141516171819202122232425262728293031323334var numbers = [0,1,2,3,4,5,6,7,8,9];// 添加元素到数组最后// 1numbers[numbers.length]=10;// 2numbers.push(12);numbers.push(12,23);// 添加元素到数组最前// 1for(var i = numbers.length; i&gt;=0; i--){ numbers[i] = numbers[i-1];}numbers[0] = -1;// 2numbers.unshift(-2);numbers.unshift(-3, -4);// 删除数组中最靠后的元素// 1numbers.pop();// 移除数组中第一个元素// 1for(var i = 0; i &lt; numbers.length; i++){ numbers[i] = numbers[i+1];};numbers.pop();//上述循环只是将数组后一位元素覆盖前一位, 因此需要利用pop⬇️将最后一位移除// 2numbers.shift(); 通过push和pop方法,就能用数组来模拟栈 通过shift和unshift方法,就能用数组模拟基本的队列数据结构 添加和删除数组任意元素 1234567var numbers = [0,1,2,3,4,5,6,7,8,9];// 删除从数组索引5开始的3个元素numbers.splice(5,3);// 从索引5开始, 不删除元素, 分别添加2,3,4三个元素numbers.splice(5,0,2,3,4); 二维和多维数组 JavaScript只支持一维数组,并不支持矩阵(二维数组).但可以用数组套数组,实现矩阵或任一多维数组. 创建3x3矩阵: 123456789101112131415161718192021222324var matrix3x3x3 = [];for(var i=0; i&lt;3; i++){ matrix3x3x3[i] = []; for(var j=0; j&lt;3; j++){ matrix3x3x3[i][j] = []; for(var z=0; z&lt;3; z++){ matrix3x3x3[i][j][z] = i+j+z; } }}// 查看矩阵输出:function printMatrix(matrix){ for(var i=0; i&lt;matrix.length; i++){ for(var j=0; j&lt;matrix[i].length; j++){ for(var z=0; z&lt;matrix[i][j].length;z++){ console.log(matrix[i][j][z]); }; } }};printMatrix(matrix3x3x3); 栈两种数据结构类似于数组,但在添加和删除元素时更为可控.它们就是栈和队列. 栈是一种遵从后进先出(LIFO)原则的有序集合.新添加的或待删除的元素都保存在栈的末尾,称作栈顶,另一端就叫栈底.在栈里,新元素都靠近栈顶,旧元素都接近栈底. 栈也被用在编程语言的编译器和内存中保存变量、方法调用等. 栈的创建和使用: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function Stack(){ // 利用数组保存栈内的元素 var items = []; // 添加元素至栈顶 this.push = function(element){ items.push(element); }; // 移除栈顶元素, 同时返回被移除的元素 this.pop = function(element){ return items.pop(); }; //只能用push和pop方法添加删除栈中元素, 遵从LIFO原则 // 返回栈顶元素, 不对栈做任何修改 this.peek = function(){ return items[items.length-1]; }; // 如果栈中没有元素就返回true, 否则返回false this.isEmpty = function(){ return items.length === 0; }; // 返回栈中元素个数,与数组的length属性功能相似 this.size = function(){ return items.length; }; // 移除栈中所有元素 this.clear = function(){ items = []; }; // 将栈中所有元素输出到控制台 this.print = function(){ console.log(items.toString()); };};// 实例化Stack类var stack = new Stack();// 验证栈是否为空console.log(stack.isEmpty());// 往栈中添加元素stack.push(5);stack.push(8);stack.push(12);stack.push(2);// 查看栈顶元素console.log(stack.peek());// 查看栈中元素格式console.log(stack.size());// 再次检查栈是否为空console.log(stack.isEmpty());// 移除栈顶元素后再查看stack.pop();console.log(stack.peek());// 查看栈内所有元素stack.print(); 利用栈解决十进制和二进制的转换问题: 要把十进制转化成二进制,我们可以将该十进制数字和2整除(二进制是满二进一),直到结果是0为止.举个例子,把十进制的数字10转化成二进制的数字,过程大概是这样: 123456789101112131415function divideBy2(decNum){ var remStack = new Stack(), rem, binaryString = ''; while(decNum &gt; 0){ // {1} rem = Math.floor(decNum % 2); // {2} remStack.push(rem); // {3} decNum = Math.floor(decNum / 2); // {4} } while(!remStack.isEmpty()){ // {5} binaryString += remStack.pop().toString(); } return binaryString;}; 在这段代码中,当函数参数满足和2做整除的条件时(行{1}),我们会获得当前参数与2相除的余数,放到栈中(行{2}、{3}).然后让参数和2相除(行{4}).另外注意:JavaScript有数字类型,但是它不会区分究竟是整数还是浮点数.因此,要使用Math.floor函数让除法的操作仅返回整数部分.最后,用pop方法把栈中的元素都移除,把出栈的元素变成连接成字符串(行{5}). 修改以上算法, 把 十进制转换成任何进制: 1234567891011121314151617function baseConverter(decNum, base){ var remStack = new Stack(), rem, baseString = ''; var digits = '0123456789ABCDEF'; //{6} while(decNum &gt; 0){ rem = Math.floor(decNum % base); remStack.push(rem); decNum = Math.floor(decNum / base); } while(!remStack.isEmpty()){ baseString += digits[remStack.pop()]; //{7} } return baseString;}; 在将十进制转成二进制时,余数是0或1；在将十进制转成八进制时,余数是0到8之间的数；但是将十进制转成16进制时,余数是0到8之间的数字加上A、B、C、D、E和F(对应10、11、12、13、14和15).因此,需要对栈中的数字做转化.(行{6}和行{7}). 队列队列和栈有很多相似之处,但有个重要区别,队列是遵循FIFO(First In First Out,先进先出,也称为先来先服务)原则的一组有序的项.队列在尾部添加新元素,并从顶部移除元素.最新添加的元素必须排在队列的末尾. 在现实中,最常见的队列的例子就是排队. 在计算机科学中,一个常见的例子就是打印队列.比如说我们需要打印五份文档.我们会打开每个文档,然后点击打印按钮.每个文档都会被发送至打印队列.第一个发送到打印队列的文档会首先被打印,以此类推,直到打印完所有文档. 队列的创建和使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function Queue(){ var items = []; // 向队列尾部添加新的元素 this.enqueue = function(element){ items.push(element); }; // 移除队列的首位元素, 并返回被移除的元素 this.dequeue = function(){ return items.shift(); }; // 返回队列中首位元素(即最先被添加的元素), 不对队列做任何修改, 与栈的peek方法类似 this.front = function(){ return items[0]; }; // 如果队列中不包含任何元素, 返回true, 否则返回false this.isEmpty = function(){ return items.length === 0; }; this.clear = function(){ items = []; }; // 返回队列中包含元素个数 this.size = function(){ return items.length; }; this.print = function(){ console.log(items.toString()); };};// 实例化Queue类var queue = new Queue();// 验证是否为空console.log(queue.isEmpty());// 向末尾添加元素queue.enqueue('John');queue.enqueue('Jack');queue.enqueue('Amy');// 输出队列中所有元素queue.print();// 输出队列所含元素个数console.log(queue.size());// 移除首位元素queue.dequeue();// 查看队列最前元素console.log(queue.front()); Queue类和Stack类非常类似.唯一的区别是dequeue方法和front方法,这是由于先进先出和后进先出原则的不同所造成的. 优先队列 默认队列有一些修改版本.其中一个修改版就是优先队列.元素的添加和移除是基于优先级的. 一个现实的例子就是机场登机的顺序.头等舱和商务舱乘客的优先级要高于经济舱乘客.另一个现实中的例子是医院的(急诊科)候诊室.医生会优先处理病情比较严重的患者. 实现一个优先队列,有两种选项:设置优先级,然后在正确的位置添加元素；或者用入列操作添加元素,然后按照优先级移除它们.在这个示例中,将会在正确的位置添加元素,因此可以对它们使用默认的出列操作: 123456789101112131415161718192021222324252627282930313233343536373839function PriorityQueue(){ var items = []; function QueueElement(element, priority){ // {1} this.element = element; this.priority = priority; }; this.enqueue = function(element, priority){ var queueElement = new QueueElement(element, priority); // 如果队列为空, 直接插入元素 if(this.isEmpty()){ items.push(queueElement); } else { // 设置added变量用以标识元素是否被插入队列 var added = false; // 遍历队列, 比较待插入元素与队列内各个元素优先级 for(var i=0; i&lt;items.length; i++){ if(queueElement.priority &lt; items[i].priority){ // 将待插入元素插入适当位置 // 在本例情况下priority值大在后(以下用p值代替,p值小,优先级高) // 因此将待插入元素插入p值比其大的元素之前一位 // 这样插入, 即使优先级相同, 也遵循先进先出原则 items.splice(i, 0, queueElement); // 当元素被顺利插入, 将added值改成true added = true; break; // 终止循环 } } // 如果队列不为空, 而又没有元素被添加, 说明待插入元素p值最大, 直接插入末尾位置. if(!added){ items.push(queueElement); } } }; // 其他方法和默认的Queue实现相同} 默认的Queue类和PriorityQueue类实现上的区别是,要向PriorityQueue添加元素,需要创建一个特殊的元素(行{1}).这个元素包含了要添加到队列的元素(可以是任意类型)及其在队列中的优先级. 12345var priorityQueue = new PriorityQueue();priorityQueue.enqueue(\"John\", 2);priorityQueue.enqueue(\"Jack\", 1);priorityQueue.enqueue(\"Camila\", 1);priorityQueue.print(); 以上代码是一个使用PriorityQueue类的示例.在下图中可以看到每条命令的结果(以上代码的结果): 第一个被添加的元素是优先级为2的John.因为此前队列为空,所以它是队列中唯一的元素.接下来,添加了优先级为1的Jack.由于Jack的优先级高于John,它就成了队列中的第一个元素.然后,添加了优先级也为1的Camila.Camila的优先级和Jack相同,所以它会被插入到Jack之后(因为Jack先被插入队列)；Camila的优先级高于John,所以它会被插入到John之前. 我们在这里实现的优先队列称为最小优先队列,因为优先级的值较小的元素被放置在队列最前面(1代表更高的优先级).最大优先队列则与之相反,把优先级的值较大的元素放置在队列最前面. 循环队列 还有另一个修改版的队列实现,就是循环队列.循环队列的一个例子就是击鼓传花游戏(Hot Potato).在这个游戏中,孩子们围成一个圆圈,把花尽快地传递给旁边的人.某一时刻传花停止,这个时候花在谁手里,谁就退出圆圈结束游戏.重复这个过程,直到只剩一个孩子(胜者). 123456789101112131415161718192021222324252627function hotPotato(nameList, num){ var queue = new Queue(); // {1} for(var i=0; i&lt;nameList.length; i++){ queue.enqueue(nameList[i]); // {2} } var eliminated = ''; while(queue.size() &gt; 1){ for(var i=0; i&lt;num; i++){ queue.enqueue(queue.dequeue()); // {3} } eliminated = queue.dequeue(); // {4} console.log(eliminated + '在击鼓传花游戏中被淘汰. '); } return queue.dequeue(); // {5}}var names = ['John', 'Jack', 'Camila', 'Ingrid', 'Carl'];var winner = hotPotato(names, 7);console.log('胜利者: ' + winner);// Camila在击鼓传花游戏中被淘汰.// Jack在击鼓传花游戏中被淘汰.// Carl在击鼓传花游戏中被淘汰.// Ingrid在击鼓传花游戏中被淘汰.// 胜利者: John 实现一个模拟的击鼓传花游戏,要用到这一章开头实现的Queue类(行{1}).我们会得到一份名单,把里面的名字全都加入队列(行{2}).给定一个数字,然后迭代队列.从队列开头移除一项,再将其添加到队列末尾(行{3}),模拟击鼓传花(如果你把花传给了旁边的人,你被淘汰的威胁立刻就解除了).一旦传递次数达到给定的数字,拿着花的那个人就被淘汰了(从队列中移除——行{4}).最后只剩下一个人的时候,这个人就是胜者(行{5}). 参考 《学习JavaScript数据结构与算法》","link":"/posts/2017/03/07/array-stack-queue/"},{"title":"三种基础排序算法","text":"冒泡排序, 插入排序, 选择排序的介绍以及它们的JavaScript代码实现. 在计算机科学所使用的排序算法通常被分类为： 计算的 时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，且坏的性能是O(n^2)。对于一个排序理想的性能是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(n log n)。 存储器使用量（以及其他电脑资源的使用） 稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 依据排序的方法：插入、交换、选择、合并等等。 依据排序的方法分类的三种排序算法: 冒泡排序冒泡排序对一个需要进行排序的数组进行以下操作: 比较第一项和第二项; 如果第一项应该排在第二项之后, 那么两者交换顺序; 比较第二项和第三项; 如果第二项应该排在第三项之后, 那么两者交换顺序; 以此类推直到完成排序; 实例说明: 将数组[3, 2, 4, 5, 1]以从小到大的顺序进行排序: 3应该在2之后, 因此交换, 得到[2, 3, 4, 5, 1]; 3, 4顺序不变, 4, 5也不变, 交换5, 1得到[2, 3, 4, 1, 5]; 第一次遍历结束, 数组中最后一项处于正确位置不会再有变化, 因此下一次遍历可以排除最后一项; 开始第二次遍历, 最后结果为[2, 3, 1, 4, 5], 排除后两项进行下一次遍历; 第三次遍历结果为[2, 1, 3, 4, 5]; 最后得到[1, 2, 3, 4, 5], 排序结束; 代码实现: 123456789101112131415161718function swap(items, firstIndex, secondIndex){ var temp = items[firstIndex]; items[firstIndex] = items[secondIndex]; items[secondIndex] = temp;};function bubbleSort(items){ var len = items.length, i, j, stop; for (i = 0; i &lt; len; i++){ for (j = 0, stop = len-i; j &lt; stop; j++){ if (items[j] &gt; items[j+1]){ swap(items, j, j+1); } } } return items;} 外层的循环决定需要进行多少次遍历, 内层的循环负责数组内各项的比较, 还通过外层循环的次数和数组长度决定何时停止比较. 冒泡排序极其低效, 因为处理数据的步骤太多, 对于数组中的每n项, 都需要n^2次操作来实现该算法(实际比n^2略小, 但可以忽略, 具体原因见⤵️), 即时间复杂度为O(n^2). 对于含有n个元素的数组, 需要进行(n-1)+(n-2)+...+1次操作, 而(n-1)+(n-2)+...+1 = n(n-1)/2 = n^2/2 - n/2, 如果n趋于无限大, 那么n/2的大小对于整个算式的结果影响可以忽略, 因此最终的时间复杂度用O(n^2)表示 选择排序选择排序对一个需要进行排序的数组进行以下操作: 假定数组中的第一项为最小值(min); 比较第一项和第二项的值; 若第二项比第一项小, 则假定第二项为最小值; 以此类推直到排序完成. 实例说明: 将数组[“b”, “a”, “d”, “c”, “e”]以字母a-z的顺序进行排序: 假定数组中第一项”b”(index0)为min; 比较第二项”a”与第一项”b”, 因”a”应在”b”之前的顺序, 故”a”(index1)为min; 然后将min与后面几项比较, 由于”a”就是最小值, 因此min确定在index1的位置; 第一次遍历结束后, 将假定的min(index0), 与真实的min(index1)进行比较, 真实的min应该在index0的位置, 因此将两者交换, 第一次遍历交换之后的结果为[“a”, “b”, “d”, “c”, “e”]; 然后开始第二次遍历, 遍历从第二项(index1的位置)开始, 这次假定第二项为最小值, 将第二项与之后几项逐个比较, 因为”b”就在应该存在的位置, 所以不需要进行交换, 这次遍历之后的结果为”a”, “b”, “d”, “c”, “e”]; 之后开始第三次遍历, “c”应为这次遍历的最小值, 交换index2(“d”), index3(“c”)位置, 最后结果为[“a”, “b”, “c”, “d”, “e”]; 最后一次遍历, 所有元素在应有位置, 不需要进行交换. 代码实现: 1234567891011121314151617181920212223function swap(items, firstIndex, secondIndex){ var temp = items[firstIndex]; items[firstIndex] = items[secondIndex]; items[secondIndex] = temp;};function selectionSort(){ let items = [...document.querySelectorAll('.num-queue span')].map(num =&gt; +num.textContent); let len = items.length, min; for (i = 0; i &lt; len; i++){ min = i; for(j = i + 1; j &lt; len; j++){ if(items[j] &lt; items[min]){ min = j; } } if(i != min){ swap(items, i, min); } } return items;}; 外层循环决定每次遍历的初始位置, 从数组的第一项开始直到最后一项. 内层循环决定哪一项元素被比较. 选择排序的时间复杂度为O(n^2). 插入排序与上述两种排序算法不同, 插入排序是稳定排序算法(stable sort algorithm), 稳定排序算法指不改变列表中相同元素的位置, 冒泡排序和选择排序不是稳定排序算法, 因为排序过程中有可能会改变相同元素位置. 对简单的值(数字或字符串)排序时, 相同元素位置改变与否影响不是很大. 而当列表中的元素是对象, 根据对象的某个属性对列表进行排序时, 使用稳定排序算法就很有必要了. 一旦算法包含交换(swap)这个步骤, 就不可能是稳定的排序算法. 列表内元素不断交换, 无法保证先前的元素排列为止一直保持原样. 而插入排序的实现过程不包含交换, 而是提取某个元素将其插入数组中正确位置. 插入排序的实现是将一个数组分为两个部分, 一部分排序完成, 一部分未进行排序. 初始状态下整个数组属于未排序部分, 排序完成部分为空. 然后进行排序, 数组内的第一项被加入排序完成部分, 由于只有一项, 自然属于排序完成状态. 然后对未完成排序的余下部分的元素进行如下操作: 如果这一项的值应该在排序完成部分最后一项元素之后, 保留这一项在原有位置开始下一步; 如果这一项的值应该排在排序完成部分最后一项元素之前, 将这一项从未完成部分暂时移开, 将已完成部分的最后一项元素移后一个位置; 被暂时移开的元素与已完成部分倒数第二项元素进行比较; 如果被移除元素的值在最后一项与倒数第二项的值之间, 那么将其插入两者之间的位置, 否则继续与前面的元素比较, 将暂移出的元素放置已完成部分合适位置. 以此类推直到所有元素都被移至排序完成部分. 实例说明: 现在需要将数组var items = [5, 2, 6, 1, 3, 9];进行插入排序: 5属于已完成部分, 余下元素为未完成部分. 接下来提取出2, 因为5比2大, 于是5被移至靠右一个位置, 覆盖2, 占用2原本存在的位置. 这样本来存放5的位置(已完成部分的首个位置)就被空出, 而2在比5小, 因此将2置于这个位置, 此时结果为[2, 5, 6, 1, 3, 9]; 接下来提取出6, 因为6比5大, 所以不操作提取出1, 1与已完成部分各个元素(2, 5, 6)进行比较, 应该在2之前, 因此2, 5, 6各向右移一位, 1置于已完成部分首位, 此时结果为[1, 2, 5, 6, 3, 9]; 对余下未完成元素进行类似操作, 最后得出结果[1, 2, 3, 5, 6, 9]; 代码实现: 1234567891011function insertionSort(items) { let len = items.length, value, i, j; for (i = 0; i &lt; len; i++) { value = items[i]; for (j = i-1; j &gt; -1 &amp;&amp; items[j] &gt; value; j--) { items[j+1] = items[j]; } items[j+1] = value; } return items;}; 外层循环的遍历顺序是从数组的第一位到最后一位, 内层循环的遍历则是从后往前, 内层循环同时负责元素的移位. 插入排序的时间复杂度为O(n^2) 以上三种排序算法都十分低效, 因此实际应用中不要使用这三种算法, 遇到需要排序的问题, 应该首先使用JavaScript内置的方法Array.prototype.sort(); 参考 2015-CS50-week-算法 排序算法-JavaScript描述","link":"/posts/2017/03/05/sorting-algorithm/"},{"title":"Redux App - BookList","text":"通过创建一个书籍列表app, 学习Redux的一些基础概念以及主要API的运用, 下面是该app的图示: 简单介绍首次渲染的app页面: 左边是书籍列表, 右边首次渲染的文字为提示词(选择某本书显示该本书相关信息), 功能如提示词所示, 即点击某本书后在右侧会显示该书的详细信息, 以下是图例: 从视图层, 数据层分析 从上图可以看出, 从数据方面看, 该app中包含两种类型的数据, 一是左边栏中一系列的书籍(hard data), 二是当前选中的书籍(meta level properties). 从视图方面看, 该app的视图包含3部分的内容, List View是数据列表, List Item是列表中的单本书, Detail View是当前选中书籍的详细信息. 在创建app时, 我们要将app的视图与数据分开, redux负责数据层的内容, 存储state; react负责视图层的内容, 将state转化为呈现在页面上的view. 组织结构Redux脚手架: Redux Boilerplate 文件结构 1234567891011121314151617181920212223book_list/ README.md node_modules/ package.json .gitignore .babelrc index.html webpack.config.js src/ actions/ index.js components/ app.js containers/ book_detail.js book_list.js reducers/ index.js reducer_active_book.js reducer_books.js index.js style/ style.css 从文件结构中可以看到, 应用最重要的几个部分为reducers, actions, components和container. 下面对这几个部分进行详细说明. reducer和actionreducerreducer是返回应用state的函数, 因为大多数redux应用包含多个state, 因此包含多个不同的reducer. 在书籍应用(book_list)中, 有两类数据, 因此应包含两个reducer, 一个负责创建全部书籍列表, 一个负责创建当前选中的书籍. 如上图所示, 创建BooksReducer以及ActiveBook, reducer返回state的值, state的key(即图中的books和activeBook)可以为任何值, 与reducer无关, 与reducer相关的只有state的值. BooksReducer返回所有书籍列表数据, 具体内容见下: reducer_books.js12345678export default function() { return [ { title: 'Javascript: The Good Parts', pages: 101 }, { title: 'Harry Potter', pages: 39 }, { title: 'The Dark Tower', pages: 85 }, { title: 'Eloquent Ruby', pages: 1 } ];} ActiveBook的内容会根据用户操作时刻变化, reducer接受redux分配的action后根据action类型返回与之相关的state. reducer_active_book.js12345678export default function(state = null, action) { switch(action.type) { case 'BOOK_SELECTED': return action.payload; } return state;} 最后再使用redux库的combineReducers方法将所有reducer整合起来. 把reducer对象传入combineReducers后, redux根据传入的所有reducer创建整个app的状态(state). reducers/index.js12345678910import { combineReducers } from 'redux';import BooksReducer from './reducer_books';import ActiveBook from './reducer_active_book';const rootReducer = combineReducers({ books: BooksReducer, activeBook: ActiveBook});export default rootReducer; action上面提到, ActiveBook这个reducer返回的state值会根据action.type变化, 此app比较简单, 只需要一个action来处理用户操作. actions/index.js123456export function selectBook(book) { return { type: 'BOOK_SELECTED', payload: book };} selectBook()是action creator, 相关的state发生改变后会调用action creator, action creator返回action, action是一个JavaScript对象, 在这个对象中必须声明type属性, type描述用户操作的具体内容, 此时是BOOK_SELECTED, 除了type属性, 还有一个payload属性, payload属性的值为与该action相关的数据值, 因为这个action选择了某一本书, 那么所需要的相关数据就是那本书的详细信息, payload的值就是所选取的书的信息. type和payload属性中, type必须声明, 但payload并非必需. container和component在组织组件时, 一般将组件分为container和component, 因此组织文件结构时, 也创建两个文件夹, 分别为containers和components. 容器组件(container)container是利用redux store中数据的组件, 也被叫做smart component. BookList和BookDetail都是根据state的变化而变化, 因此这两个组件应为container. book-detail.js1234567891011121314151617181920212223242526import React, { Component } from 'react';import { connect } from 'react-redux';class BookDetail extends Component { render() { if (!this.props.book) { return &lt;div&gt;Select a book to get started.&lt;/div&gt;; } return ( &lt;div&gt; &lt;h3&gt;Details for:&lt;/h3&gt; &lt;div&gt;Title: {this.props.book.title}&lt;/div&gt; &lt;div&gt;Pages: {this.props.book.pages}&lt;/div&gt; &lt;/div&gt; ); }}function mapStateToProps(state) { return { book: state.activeBook };}export default connect(mapStateToProps)(BookDetail); 从以上代码中可以看到, book-detail从react-redux库中引入了connect方法, 因为在react和redux搭配使用时, react无法直接获取redux所负责的应用state, 因此需要react-redux的帮助使两个库能更好得配合使用. mapStateToProps将来自redux的state转换为当前component的props, connect将component提升为container. 关于connect: 只要应用的state产生变化(用户事件, ajax请求…): container会立即rerender 组件的props也会立即变化 book-list.js1234567891011121314151617181920212223242526272829303132333435363738import React, { Component } from 'react';import { connect } from 'react-redux';import { selectBook } from '../actions/index';import { bindActionCreators } from 'redux';class BookList extends Component { renderList() { return this.props.books.map((book) =&gt; { return ( &lt;li key={book.title} onClick={() =&gt; this.props.selectBook(book)} className=\"list-group-item\"&gt; {book.title} &lt;/li&gt; ); }); } render() { return ( &lt;ul className=\"list-group col-sm-4\"&gt; {this.renderList()} &lt;/ul&gt; ) }}function mapStateToProps(state) { return { books: state.books };} function mapDispatchToProps(dispatch) { return bindActionCreators({ selectBook: selectBook }, dispatch);} export default connect(mapStateToProps, mapDispatchToProps)(BookList); BookList组件中, 用户点击动作不只需要调用action creator, 还要确保action分发到所有reducer中, 使用redux库中的bindActionCreator方法和dispatch方法达到此目的. 展示组件(component)component是没有与redux store连结的组件, 也被叫做dumb component, 只负责呈现View, 不处理数据. 此例中是只负责渲染书籍列表和选中书籍的详细信息到页面中. app.js 12345678910111213141516import React from 'react';import { Component } from 'react';import BookList from '../containers/book-list';import BookDetail from '../containers/book-detail';export default class App extends Component { render() { return ( &lt;div&gt; &lt;BookList /&gt; &lt;BookDetail /&gt; &lt;/div&gt; ); }} wrapupsrc/index.js12345678910111213import React from 'react';import ReactDOM from 'react-dom';import { Provider } from 'react-redux';import { createStore } from 'redux';import App from './components/app';import reducers from './reducers';ReactDOM.render( &lt;Provider store={createStore(reducers)}&gt; &lt;App /&gt; &lt;/Provider&gt; , document.querySelector('.container')); 从react-redux引入了Provider, 将store作为属性传入Provider后, Provider接受来自store的更新并传递这些更新. 下面是该应用的完整逻辑介绍: 项目完整代码 TipsReact与Redux的state只使用react构建应用时, 也有一个state, 是component state(组件层面), 要注意与redux的application state(应用层面)进行区分, 在redux应用中, 两个类型的state都可以使用, 两者是完全分离, 互不影响的, 在app中使用redux state一般是将state转化为props再使用, 利用this.props.something, 而component state是this.state.somthing. Redux存储数据的方法与Angular, Backbone, Flux的区别 Redux将所有的数据只存储在一个object中, 这个object就是store. 许多其他库或框架将数据分为不同的集合存储, Backbone是存储在不同的collection中, flux则是存储在不同的store中. 参考 Modern React with Redux","link":"/posts/2017/04/16/redux-booklist/"},{"title":"[译]看漫画理解Flux","text":"原文: A cartoon guide to Flux作者: Lin Clark原文发布时间: 2015.09.29 译文: Flux是现在网页开发领域最流行但很少人对其有深刻理解的一个概念. 这篇文章会从大多数人都能理解的角度对Flux进行解释. 问题首先, 我想说明Flux的出现是为了解决了什么问题. Flux作为一种架构模式, 其作用是处理应用中的数据. Facebook技术团队为了解决工作过程中遇到的一些问题, 开发了Flux和React, 很多人将它们结合使用, 当然这两者也可以独立使用. 在他们遇到的问题中, 比较典型的一个就是推送的漏洞. 用户登录Facebook时, 会看到信息框的推送小红点. 但当点击信息框, 推送小红点消失, 可实际上用户并没有新信息需要查看. 然后浏览站点几分钟后, 推送通知又会重新出现, 用户就需要为实际上并不存在的新信息多次点击信息框. 正是推送的漏洞导致上述情况的出现. 不只是用户遭遇了推送不断出现的循环, Facebook的开发团队也遭遇了漏洞不断修复又发生的循环, 这一秒问题被解决, 下一秒漏洞又出现, 如此循环往复. 于是Facebook团队决定想出一种方法一劳永逸地解决这个问题. 他们打算开发一个可预测(状态)的系统, 以确保问题不会不断出现. 根本问题他们发现, 数据在应用中传递的方式是导致该漏洞的根本原因. 注: 这是我从Facebook团队的演讲中分享的简化版本例子中搜集到的资料, 实际的架构必定与此有所差异. 他们让存储数据的模型传递数据到视图层以渲染数据. 用户操作在视图层发生, 因此视图有时候需要根据用户输入进行更新. 而且在某些情况下, 视图还负责更新其它视图. 除了以上的几种情况, 这些行为还可以引发一系列的其他改变. 这就像是游戏Pong一样, 你很难预测球将会停在哪个地方, 甚至是直接跃出屏幕. 另外, 这些改变还可能以异步的形式发生. 一种改变会引发多种其它改变, 就像是在游戏Pong中扔出许多球, 导致球到处乱飞无法控制. 总的来说, 这样的架构使得追踪数据流变得极为困难. 解决方案: 单向数据流于是, Facebook决定尝试一种不一样的架构, 其中数据只能单向流动, 当我们需要插入新数据时, 数据流动又从头开始. 他们将这个架构叫做Flux. 实际上这个架构模式超级酷, 不过仅从图片上很难看出来. 一旦我们理解了Flux, 就能明白上述图表所表达的意思. 如果你完全不了解Flux, 就开始阅读文档, 那么这个图表或许对你不会有太大帮助, 然而这个图表的作用却是辅助开发者理解文档, 在我们开始深入学习如何进行某些具体的操作之前, 此图表应该让我们对Flux系统有个整体的把握. 然而, 真正帮助我更好地理解Flux的并不是这个图表, 不过我自己想出了个好办法, 我将这个系统(Flux)的工作想象成几个不同的人物进行团队合作, 实现一个共同的目标. 这样的思考方式让我对Flux有更深入的理解. 现在我希望把我的想法, 我想象中的几个人物介绍给大家. 人物介绍在详细解释这些人物的分工之前, 我先简单介绍一下它们. The action creator 第一个人物是action creator(动作创建者). 它负责创建action, 应用中所有的改变和交互都需要经由它. 当你想要改变应用的状态(state)或渲染不同的视图, 就要”发射”一个action. 我把action creator看做电报员. 我们把想要传送的信息告知电报员, 电报员帮我们将信息转化成系统其它部分可以理解的格式. action creator创建的action包含type(类型)和payload(负载)属性. 我们会预先在系统中定义许多action, 这里type属性值就是其中一种action(系统中的action一般来说是一系列的常量). 例如MESSAGE_CREATE或者MESSAGE_READ就可以是action的type值. 让系统的一部分知道在应用中可能发生的所有action有个好处: 刚接触项目的开发者一打开action creator文件, 就可以看到全部API, 了解系统中所有可能发生的状态变化. 一旦创建了action信息, action creator就会将action传送给dispatcher(调度员). The dispatcher dispatcher(调度员)是回调函数的登记处, 很像是在电话交换台的电话接线员, 它有一份名单列表, 里面记录着所有需要接收action的store, dispatcher接收到action creator的传送过来的action后, 会将其分配给不同的store. dispatcher执行操作的方式是同步的, 这样的方式解决了我们之前提到的Pong游戏中的多个球问题. 如果我们要在store之间设置依赖, 即在某个store更新前需要另一个store先执行更新, 那么可以让dispatcher通过waitFor()指令安排好两个store的更新情况. Flux的dispatcher与许多其它架构中的dispatcher有所差异. 不管action的type值是什么, action都会被发送到已经在dispatcher处注册过的所有store中. 这表明store不只订阅(subscribe to)一部分action, 而是订阅了全部action, 之后再筛选出需要处理和不需要处理的action. The store 接下来是store. store里储存着应用的所有state, 这些state改变的逻辑也同时储存在store中. 我把store看作是控制欲过强的领导者, 它亲自控制所有state变化. 我们不可以直接要求它改变state, store里没有setter, 如果我们想要让state执行改变, 必须通过action creator/dispatcher这一途径提交action以改变state. 之前提到过, 如果store在dispatcher处已注册, 所有action都会被分发给所有已注册的store. 在store内通常有个switch声明, 根据action的type值决定store是否需要处理该action. 如果是需要处理的action, store会根据action的具体信息更新state. 一旦store完成state的更新之后, 会发出change事件, 以通知控制器视图(controller view)state已完成更新. The controller view and the view 视图(view)负责接受state并渲染, 同时还负责接收用户输入. 视图就像是展示者, 它并不理会在应用中发生的其它过程, 只在意传到它手中的数据, 并将这些数据转化成用户可以理解的形式并展示出来(通过HTML). controller view(控制器视图)则像是store和view之间的中介. 当state发生改变时, store会通知控制器视图, 控制器视图接收更新后的state, 将state传递给控制器视图下的所有视图. 如何协作现在我们来看看这些人物是如何协作的. 配置 首先是初始配置: 只发生一次的应用初始化. 1.应用中的全部store告知dispatcher: 一旦接收到action, 需要通知它们. 2.之后控制器视图向所有store请求最新的state. 3.当store将state传送给控制器视图时, 控制器视图将state传递给它底层的视图(views)以进行渲染. 4.当state有更新时, 控制器视图也会收到store的通知. 数据流配置结束后, 应用就准备好接受用户输入了. 现在我们让用户执行一些操作来触发一个action然后观察数据流. 1.view通知action creator开始准备创建一个action. 2.action creator转化好action的格式后将其传送给dispatcher. 3.dispatcher将action逐一传送给store. 对于所有的action, 每一个已注册store都会收到通知. 然后store会判断需要对哪些action进行处理, 那些不需要处理, 并且根据action来改变state. 4.state更新好之后, store会通知订阅该store的所有view controller. 5.这些view controller接收到通知后, 会向store请求更新完成的state. 6.store给出state后, view controller让它控制范围下的所有view根据更新的state重新渲染页面. 以上就是我对Flux架构的理解. 希望能够帮到大家. 参考 Flux documentation Fluxxor documentation The Case for Flux 推荐阅读: 看漫画理解Redux(英文, 中文) 注: 初学redux时看到的文章, 想要通过翻译深入理解, 因此翻译的质量可能不是太好, 内容会在之后的学习过程中不断改进.","link":"/posts/2017/04/27/flux-cartoon-guide/"},{"title":"[译]看漫画理解Redux","text":"原文: A cartoon guide to Redux作者: Lin Clark原文发布时间: 2015.10.21 译文: Flux架构模式或许给许多人带来了很大困惑, 但大家接触到Redux之后, 发现区别Flux和Redux是个更困难的挑战, Redux模式借鉴了Flux的许多概念, 在这篇文章中我将以漫画的形式详细解释这两者的区别. 在阅读本文前, 建议先阅读: 看漫画理解Flux(英文, 中文). 为何改进FluxRedux和Flux能够解决同样的问题, 甚至更多. 和Flux一样, Redux使得应用中的state变化变得可预测. 想要改变state, 必须要发出一个action, 没有其他直接改变state的方法, 因为存储state的store只有getter, 没有setter. Flux和Redux的基本概念几乎无异. 那么为什么不使用Flux却要设计一个新的架构模式呢? 因为Redux的开发者Dan Abramov觉得Flux还有许多可以改进的地方, 改进之后就能有一个更好的开发工具, 于是他创造了Redux, 而且仍然保持Flux模式的可预测state变化的能力. Flux没有热重载和时间旅行调试, 这篇文章(英文,中文)详细解释了这两个概念. 因此使用Flux架构的应用在调试时会遇到比较多的问题. 问题1: 重载描述store的代码会重置state在Flux中, store包含以下两部分内容: state变化的逻辑 该store当前的state 将以上两者置于同一个对象中注定无法实现热重载. 当我们重载store对象以观察更新后的state效果时, 就失去了store当前所存储的state. 同时还会将关联该store与系统其他部分的订阅事件搞混. 解决方案 将对象分离, 即使用两个对象, 一个对象存储state, 这个对象无法被重载; 另一个对象包含所有state变化的逻辑, 这个对象可以被重载, 不需要存储state. 问题2: 每接收一个action, state都会被重写在时间旅行调试中, 我们会追踪每一个阶段的state对象, 这样就能获取任意一个阶段的state对象信息. 为了实现这个目标, 每一次state改变后, 我们都要将旧的state添加到存储state对象的数组中, 可是由于JavaScript对象通过引用传递的特性, 简单将变量添加到数组中不能达到目的, 因为这样无法创建新的对象拷贝, 只是创建了一个指向相同对象的指针. 因此, 每一个阶段的state都要保存在不同的对象中, 这样就能避免直接改变历史版本的state. 解决方案 当action传送到store时, 不要通过直接改变state处理action, 而应该拷贝state, 对拷贝后的state进行修改. 问题3: 难以引入第三方插件开发者工具的扩展性十分重要, 开发者应该能够方便地在工具中添加自己需要的第三方插件, 不需要在整合第三方插件与工具这方面下太多功夫. 因此, 我们需要一些”扩展工具点”. 一个典型的例子是日志, 比如接收到action时, 我们希望console.log()action的信息, 处理完该action后, console.log()更新后的state信息, 在Flux中, 要想达到这个目的, 需要订阅dispatcher及每一个store的更新, 但这部分代码并不属于业务逻辑, 却需要自己完成, 因为无法借助第三方模块简单实现. 解决方案 将系统的某些打包进其他对象中, 这些对象均有一个原始版本, 开发者可以在原始版本的基础上添加所需功能. 我们可以把”扩展工具点”看做是”增强器(enhancer)”, “高阶”对象(higher order objects)或者是中间件(middleware) 另外, 运用”树”型结构来组织state变化的逻辑, 这样store就只需要分发(dispatch)一个事件来通知视图state发生变化. 等整个state树中的所有reducer处理完成之后, 视图才会接收到该事件. 注: 上述的几个问题和解决方案的示例均是开发者工具使用的角度出发. 但实际上在其他方面, 上述结论也成立. 除了以上差异之外, Redux和Flux之间还存在其他差异. 比如, Redux精简了冗余代码, 使得我们更容易复用store中的逻辑, 这里有个列表, 详细列出了Redux的优势. 现在我们来看看Redux是如何实现这些功能的. 新的人物Redux中的人物与Flux并非完全相同. The action creators Redux与Flux中的action creator相同. 当我们想要改变应用的state时, 就发出一个action, 这也是state改变的唯一方式. 我在谈Flux的文章(原文, 译文)中提到, 把action creator看做是电报员. 你把想要传送的信息交给电报员, 它会转换好信息格式以便系统的其他部分理解. 和Flux不同的是, Redux中的action creator不会直接发送action到dispatcher, 而是返回一个已转换好格式的action对象. The store在Flux中, 我把store看做是控制欲过强的领导者. 所有state变化都必须由它亲自来完成, 只有通过action才可以改变state, 无法直接修改. Redux中的store依旧控制欲强且官僚主义, 但有一点不同. Flux中有多个store, 每个store中所控制的区域不同, store对其所负责区域有完全掌控权, 均储存着各自的state, 控制那部分state改变的逻辑. 而在Redux中只有1个store, 因此该store将责任委托以减轻它的负担. Redux store只负责保存整体的state树, 它将检视state变化的任务委托给reducer, 应用中有许多reducer, 其中root reducer负责对其他reducer进行领导管理. 可以发现, 在Redux中没有dispatcher, 因为store接管了dispathcer的工作. The reducers当store想知道action如何改变state时, 它就会向reducer咨询. root reducer负责告知store其所要求的信息. root reducer会根据state对象的键(key)将state分成多个部分, 然后将分离后的每一部分的state传给其下的reducer, reducer知道如何处理这些state. 我把这些reducer看做是一群热衷于拷贝工作的白领. 它们不希望自己所处理的文件乱成一团, 因此对于传送来的文件(即分离的state), 它们不会直接对其进行修改, 而是拷贝一份之后对拷贝执行修改. 这是Redux的核心思想之一. 不可直接操作state对象, 需要对其执行分离后进行修改, 再将修改后的部分合并为一个新的state对象. 各个reducer将分离的state拷贝修改之后传给root reducer, root reducer将修改过的各个state进行合并, 组成一个新的state对象. 然后root reducer将新的state对象返回给store, store将该state升级为正式的state. 如果你现在正在开发的只是一个小应用, 那么整个应用或许只需要一个reducer负责拷贝state对象以及改变state的值, 而大应用则需要多个reducer. 这也是Flux与Redux的另一个不同之处. 在Flux中, 多个store之间没有联系, 它们处于同一等级, 各自完成自己的任务. 而在Redux中, reducer有层级结构, 有多个等级, 就像组件(component)之间也有层级结构一样. The views: smart and dumb componentsFlux有控制器视图(controller view)和常规视图(regular review)的概念. 控制器视图作为store和view之间的中介, 起着沟通两者的作用. Redux中有与此相似的概念: 容器组件(smart component)与展示组件(dumb component). 容器组件是中介, 但比控制器视图遵循更多的规则: 容器组件负责action, 如果容器组件中包含的某个展示组件需要触发一个action, 容器组件就会通过props传递一个函数给展示组件, 然后展示组件在有需要时调用该函数. 容器组件不定义CSS样式 大部分情况下, 容器组件不产生DOM节点, 它们给展示组件指令, 让展示组件产生DOM节点. 展示组件不直接依赖action文件, 因为所有action的传递都通过props, 这样一来, 即使应用的逻辑不同, 展示组件也可以在它们中进行复用. 展示组件会定义自身所需的CSS样式(我们也能够自定义样式, 只需在组件中设置样式相关的属性添加需要的样式, 使其与默认样式合并即可). The view layer binding Redux无法直接将store与view绑定, 需要view layer binding(视图层绑定系统)的帮助. 如果你开发过react与redux结合的应用, 那么你肯定知道react-redux, react-redux就是视图层绑定系统. view layer binding有点像视图树的IT部门, 它确保所有组件与store关联, 还负责处理许多技术细节, 这样系统的其他部分即使不明白系统某些部分的运作也没有关系. view layer binding引入了3个概念: Provider组件: 它包围着组件树, 使根组件的子组件更容易使用connect()与store相关联. connect(): react-redux库提供的函数. 如果某个组件想要更新state, 就要将该组件以参数形式传入connect(), 之后connect函数就会利用选择器(selector)配置好所有关联. selector: 是开发者自定义的一个函数, 在其中声明组件需要state的哪些部分作为属性. The root component 所有React应用都有根组件(root component), 根组件归根结底就是处于组件等级结构中顶层的组件. 然而在Redux应用中, 根组件需要处理更多的事. 根组件就像是公司中的高管. 为所有团队分工共同完成一项任务. 同时, 根组件还创建store, 告知store应该使用哪个reducer, 并且负责结合视图层绑定系统与视图. 如何分工合作现在我们来看看各部分是如何分工合作的. 配置应用中的各部分需要互相配合才能使应用真正发挥其功能. 我们在配置中实现这一步. 1.store做好准备. 根组件创建store并利用createStore()方法告知store使用的root reducer是哪一个. root reducer管理全部reducer, 它利用combineReducers()将全部reducer结合. 2.设置store与组件之间的通信. 根组件将所有附属组件包裹在 Provider组件中，并且建立Provider与store之间的联系。 Provider创建了某种网络以便于组件的更新. 容器组件通过connect()函数连接到该网络, 这样组件就能够获取state的更新. 3.准备action回调函数. 为了使展示组件更好地处理action, 容器组件可以用bindActionCreators()设置action回调函数, 这样的话，容器组件就会给展示组件传入一个回调函数。对应的action会在展示组件调用这个回调函数时被自动分发。 数据流现在应用配置已完成, 用户可以开始执行操作. 让我们触发一个action来观察数据流. 1.view请求action, action creator转化好action格式之后将其返回. 2.action被分发的形式有两种, 如果配置阶段使用了bindActionCreators(), action就会被自动分发, 否则由视图分发. 3.store接收action, 将当前state树和action发送给root reducer. 4.root reducer把state tree分成多个部分. 将每部分传至附属reducer, 附属reducer知道如何处理state. 5.附属reducer拷贝自己负责的那部分state, 然后对拷贝执行修改, 之后返回修改后的拷贝到root reducer. 6.一旦所有附属reducer返回所负责state拷贝后, root reducer将这些分离的state组合成一个完整全新的state树, 将其返回store, 然后store就用新的state树代替旧的state. 7.store告知view layer binding已经更新过state树. 8.view layer binding向store请求新的state树. 9.view layer binding触发重新渲染. 这是我对Redux以及它与Flux之间差异的理解, 希望能够帮到大家! 参考 Redux docs Dan Abramov’s React Europe talk The Evolution of Flux Frameworks Smart and Dumb Components The upsides of using Redux The downsides of using Redux JS Jabber: The Evolution of Flux Libraries with Andrew Clark and Dan Abramov 注: 初学redux时看到的文章, 想要通过翻译深入理解, 因此翻译的质量可能不是太好, 内容会在学习的过程中不断改进. 翻译完成后发现之前已经有人翻过这篇文章, 是更好的一个版本: 译文.","link":"/posts/2017/05/01/redux-cartoon-guide/"},{"title":"20行代码实现JavaScript模板引擎","text":"刷朋友圈看到了一个不错的题目, 于是Google了一下, 找到一篇文章: JavaScript template engine in just 20 lines, 并不是逐字逐句翻译, 因此算是翻译+笔记吧. 12345678var TemplateEngine = function(tpl, data) { // magic here ...}var template = '&lt;p&gt;Hello, my name is &lt;%name%&gt;. I\\'m &lt;%age%&gt; years old.&lt;/p&gt;';console.log(TemplateEngine(template, { name: \"Krasimir\", age: 29})); 现在我们要实现TemplateEngine函数, 由上可知, 该函数的两个参数为模板及数据. 执行上述代码后会出现以下结果: 1&lt;p&gt;Hello, my name is Krasimir. I'm 29 years old.&lt;/p&gt; 首先我们必须要获取模板中的动态变化部分, 之后将用二个参数中的真实数据替换动态变化部分的内容, 可以使用正则表达式实现. 1var re = /&lt;%([^%&gt;]+)?%&gt;/g; 上面的表达式会提取所有以&lt;%为开头, %&gt;为结尾的部分内容, 末尾的g(global)表示匹配所有项. 然后使用RegExp.prototype.exec()方法, 将所有匹配的字符串存进一个数组中. 12var re = /&lt;%([^%&gt;]+)?%&gt;/g;var match = re.exec(tpl); 输出match得到这样的结果: 1234567[ \"&lt;%name%&gt;\", \" name \", index: 21, input: \"&lt;p&gt;Hello, my name is &lt;%name%&gt;. I\\'m &lt;%age%&gt; years old.&lt;/p&gt;\"] 我们提取出了数据, 但是只得到一个数组元素, 我们需要处理的是所有匹配项, 因此使用while循环实现: 1234var re = /&lt;%([^%&gt;]+)?%&gt;/g, match;while(match = re.exec(tpl)) { console.log(match);} 执行上述代码之后会发现&lt;%name%&gt;和&lt;%age%&gt;都被提取出来了. 接下来要用真实的数据取代占位符. 最简单的方式是使用String.prototype.replace()方法实现: 1234567var TemplateEngine = function(tpl, data) { var re = /&lt;%([^%&gt;]+)?%&gt;/g, match; while(match = re.exec(tpl)) { tpl = tpl.replace(match[0], data[match[1]]) } return tpl;} 对于文章开头的例子, 因为只是简单的对象, 使用当前的方式(data[&quot;property&quot;])就能够完成任务, 但是实际上会遇到更复杂的多层嵌套对象, 比如: 1234{ name: \"Krasimir Tsonev\", profile: { age: 29 }} 将函数的第二个参数改成上述形式之后, 使用以上的方法就没有办法解决问题了, 因为当我们输入&lt;%profile.age%&gt;时, 得到的数据是[“profile.age”], 其值为undefined. 此时replace()方法不再适用. 如果对于在&lt;%和%&gt;之间的内容, 将其看成JavaScript代码, 可以直接执行并返回值, 那就比较好了, 比如: 1var template = '&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I\\'m &lt;%this.profile.age%&gt; years old.&lt;/p&gt;'; 使用new Function()语法, 构造函数: 12var fn = new Function(\"arg\", \"console.log(arg + 1);\");fn(2); // outputs 3 fn函数接受一个参数, 其函数体为console.log(arg + 1), 上述的代码相当于: 1234var fn = function(arg) { console.log(arg + 1);}fn(2); // outputs 3 现在我们知道了可以通过上述方式由字符串构造出一个简单的函数. 不过在实现我们的需求时, 还需要花点时间思考如何构建我们所需的函数体. 该函数的功能是返回编译后的模板. 开始试试看如何实现: 123456return \"&lt;p&gt;Hello, my name is \" + this.name + \". I\\'m \" + this.profile.age + \" years old.&lt;/p&gt;\"; 将模板分离为由文本和JavaScript代码组成的部分. 利用简单的合并就可以获得预期的结果. 不过该方法还是无法100%符合我们的要求. 因为如果&lt;%和%&gt;之间的内容不是简单的变量, 而是其他更复杂的比如循环语句, 就无法获得预期结果, 例如: 12345var template = 'My skills:' + '&lt;%for(var index in this.skills) {%&gt;' + '&lt;a href=\"\"&gt;&lt;%this.skills[index]%&gt;&lt;/a&gt;' +'&lt;%}%&gt;'; 如果使用简单的合并, 结果是这样的: 1234567return'My skills:' + for(var index in this.skills) { +'&lt;a href=\"\"&gt;' + this.skills[index] +'&lt;/a&gt;' +} 这样的话会产生错误, for(var index in this.skills) {无法正常执行, 因此采用另一种方式, 不要将所有内容添加到数组中, 而只将所需的内容添加, 最后合并数组: 12345678var r = [];r.push('My skills:'); for(var index in this.skills) {r.push('&lt;a href=\"\"&gt;');r.push(this.skills[index]);r.push('&lt;/a&gt;');}return r.join(''); 因此接下来的步骤是在构造的函数体中根据情况添加各行代码, 之前我们已从模板中提取出一些相关的信息: 占位符的内容以及它们所处的位置. 那么, 再定义一个辅助的变量(cursor)就能够实现我们想要得到的结果. 1234567891011121314151617181920212223var TemplateEngine = function(tpl, data) { var re = /&lt;%([^%&gt;]+)?%&gt;/g, code = 'var r=[];\\n', cursor = 0, match; var add = function(line) { code += 'r.push(\"' + line.replace(/\"/g, '\\\\\"') + '\");\\n'; } while(match = re.exec(tpl)) { add(tpl.slice(cursor, match.index)); add(match[1]); cursor = match.index + match[0].length; } add(tpl.substr(cursor, tpl.length - cursor)); code += 'return r.join(\"\");'; // &lt;-- return the result console.log(code); return tpl;}var template = '&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I\\'m &lt;%this.profile.age%&gt; years old.&lt;/p&gt;';console.log(TemplateEngine(template, { name: \"Krasimir Tsonev\", profile: { age: 29 }})); code变量的值为我们自己构造的函数的函数体, 函数体中首先定义了一个空数组. 可以通过cursor变量存储&lt;%this.name%&gt;这种形式的内容之后的文字处于模板中的位置索引值. 然后我们又创建了add函数, 利用这个函数可以添加各行代码到code变量中. 这之后我们会遇到一个棘手的问题, 需要利用转义解决双引号&quot;的问题: 123456var r=[];r.push(\"&lt;p&gt;Hello, my name is \");r.push(\"this.name\");r.push(\". I'm \");r.push(\"this.profile.age\");return r.join(\"\"); this.name和this.profile.age不应该被双引号引起. 可以这样改进add函数来解决这个问题: 12345678910var add = function(line, js) { js? code += 'r.push(' + line + ');\\n' : code += 'r.push(\"' + line.replace(/\"/g, '\\\\\"') + '\");\\n';}var match;while(match = re.exec(tpl)) { add(tpl.slice(cursor, match.index)); add(match[1], true); // &lt;-- say that this is actually valid js cursor = match.index + match[0].length;} 如果占位符的内容为JS代码, 则将其与布尔值true一同传入add函数, 这样就可以得到我们预期的结果: 123456var r=[];r.push(\"&lt;p&gt;Hello, my name is \");r.push(this.name);r.push(\". I'm \");r.push(this.profile.age);return r.join(\"\"); 然后我们需要做的就是创建这个函数并执行. 在TemplateEngine函数中不返回tpl, 而是返回我们动态创建的函数: 1return new Function(code.replace(/[\\r\\t\\n]/g, '')).apply(data); 不要在函数中直接传入参数, 利用apply方法调用该函数并传入参数. 这样才会创建正确的作用域, this.name才可正确执行, 此时this指向data对象. 最后我们还想在其中实现一些复杂的操作, 例如if/else声明以及循环: 12345678var template = 'My skills:' + '&lt;%for(var index in this.skills) {%&gt;' + '&lt;a href=\"#\"&gt;&lt;%this.skills[index]%&gt;&lt;/a&gt;' +'&lt;%}%&gt;';console.log(TemplateEngine(template, { skills: [\"js\", \"html\", \"css\"]})); 不过现在会抛出错误Uncaught SyntaxError: Unexpected token for, 通过调试可以发现问题: 123456789var r=[];r.push(\"My skills:\");r.push(for(var index in this.skills) {);r.push(\"&lt;a href=\\\"\\\"&gt;\");r.push(this.skills[index]);r.push(\"&lt;/a&gt;\");r.push(});r.push(\"\");return r.join(\"\"); 包含for循环的那行代码不应该被添加到数组中, 于是我们这样进行改进: 12345678var re = /&lt;%([^%&gt;]+)?%&gt;/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = 'var r=[];\\n', cursor = 0;var add = function(line, js) { js? code += line.match(reExp) ? line + '\\n' : 'r.push(' + line + ');\\n' : code += 'r.push(\"' + line.replace(/\"/g, '\\\\\"') + '\");\\n';} 上述代码添加了一个新的正则表达式, 如果JS代码以if, for, else, switch, case, break, { , }这些内容为起始值, 则直接添加该行代码, 不添加到数组中. 那么最后的结果就是: 123456789var r=[];r.push(\"My skills:\");for(var index in this.skills) {r.push(\"&lt;a href=\\\"#\\\"&gt;\");r.push(this.skills[index]);r.push(\"&lt;/a&gt;\");}r.push(\"\");return r.join(\"\"); 这样的话, 所有的内容都被正确编译. 1My skills:&lt;a href=\"#\"&gt;js&lt;/a&gt;&lt;a href=\"#\"&gt;html&lt;/a&gt;&lt;a href=\"#\"&gt;css&lt;/a&gt; 最后的改进使函数功能更强大, 改进之后我们可以直接在模板里添加复杂逻辑: 12345678910111213var template = 'My skills:' + '&lt;%if(this.showSkills) {%&gt;' + '&lt;%for(var index in this.skills) {%&gt;' + '&lt;a href=\"#\"&gt;&lt;%this.skills[index]%&gt;&lt;/a&gt;' + '&lt;%}%&gt;' +'&lt;%} else {%&gt;' + '&lt;p&gt;none&lt;/p&gt;' +'&lt;%}%&gt;';console.log(TemplateEngine(template, { skills: [\"js\", \"html\", \"css\"], showSkills: true})); 添加了一些优化项的最终版本代码就类似如下这样: 123456789101112131415var TemplateEngine = function(html, options) { var re = /&lt;%([^%&gt;]+)?%&gt;/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = 'var r=[];\\n', cursor = 0, match; var add = function(line, js) { js? (code += line.match(reExp) ? line + '\\n' : 'r.push(' + line + ');\\n') : (code += line != '' ? 'r.push(\"' + line.replace(/\"/g, '\\\\\"') + '\");\\n' : ''); return add; } while(match = re.exec(html)) { add(html.slice(cursor, match.index))(match[1], true); cursor = match.index + match[0].length; } add(html.substr(cursor, html.length - cursor)); code += 'return r.join(\"\");'; return new Function(code.replace(/[\\r\\t\\n]/g, '')).apply(options);} 参考 JavaScript template engine in just 20 lines (原文) JavaScript Micro-Templating","link":"/posts/2017/07/11/implement-js-template-engine/"},{"title":"[译]JavaScript继承实例","text":"原文: JavaScript inheritance by example作者: Axel Rauschmayer原文发布时间: 2012.01.08 译文: 本文通过几个例子说明了JavaScript中的关于继承的几个主题: 第一个例子是JS中构造器(constructor) Point以及它的二级构造器ColorPoint的原生实现, 然后一步步对它们进行改进. 对象JavaScript是少数可以直接创建对象的面向对象编程语言之一. 在大部分其他编程语言中, 需要通过class来创建对象. 现在我们用JavaScript创建一个point对象. 12345678910var point = { x: 5, y: 2, dist: function () { return Math.sqrt((this.x*this.x)+(this.y*this.y)); }, toString: function () { return \"(\"+this.x+\", \"+this.y+\")\"; }}; 使用大括号创建对象的语法是通过对象初始化器/对象字面量. 对象point有4个属性: x, y, dist以及toString. 可以通过点操作符读取这些属性的值: 12point.x// 5 值为函数的属性叫做方法(methods), 调用方法的方式是: 12345point.dist()// 5.385164807134504point.toString()// '(5, 2)' 构造器以上例子中我们只创建一个point对象, 如果想要创建多个, 就需要为这些对象创建工厂. 在类继承编程语言中这种工厂叫做类 classes, 在JavaScript中叫做构造器 constructors. 以函数foo为例: JS中调用函数foo有两种方式: 函数调用: foo(arg1, arg2) 构造器调用: new foo(arg1, arg2) 以下是用以创建多个point对象的构造器Point: 12345678910function Point(x, y) { this.x = x; this.y = y; this.dist = function () { return Math.sqrt((this.x*this.x)+(this.y*this.y)); }; this.toString = function () { return \"(\"+this.x+\", \"+this.y+\")\"; };} 我们执行new Point()时, 构造器的任务是设置一个全新的对象, 然后通过隐式的参数this传入对象的属性. 我们之前使用对象字面量来定义对象的属性, 现在则通过this来定义. 构造器隐式返回全新的对象, 即对象的实例. 123var p = new Point(3, 1);p instanceof Point// true 和之前一样, 可以调用方法, 获取属性值: 12345p.toString()// '(3, 1)'p.x// 3 然而方法被某个实例所特有并不合适, 应该被所有实例共享以节省内存. 可以使用prototype(原型)达到这个目的. 存储在Point.prototype的对象成为Point所产生的所有实例的原型. 对象(“prototypee”)及其原型的工作原理是这样的: prototypee继承所有其原型的属性. 一般来说, 原型只有一个, prototypee可以有多个, 所有prototypee共用原型的属性. 因此, 我们可以在Point.prototype内定义方法: 123456789101112function Point(x, y) { this.x = x; this.y = y;}Point.prototype = { dist: function () { return Math.sqrt((this.x*this.x)+(this.y*this.y)); }, toString: function () { return \"(\"+this.x+\", \"+this.y+\")\"; }} 上例中我们通过对象字面量将一个对象赋值给Point.prototype, 这个对象含有两个方法: dist和toString. 现在各部分的任务有了明确的分工, 构造器设置实例专属的数据, 原型中包含共享的数据(如方法). 注意JavaScript引擎对原型实现了高度优化, 因此在原型中定义方法不会引起太大的性能问题, 调用方法的方式也与之前无异, 跟在哪里定义方法无关. 不过还是存在一个问题: 对于所有的函数f, 以下声明必须成立(详见参考[1]): 1f.prototype.constructor === f 上述声明是所有函数的默认行为, 但我们利用对象字面量替换了Point.prototype的默认值, 这样上述声明就不再成立, 为了使上述声明成立, 有两种方法, 一是手动在对象字面量添加constructor属性, 二是通过添加而非替换的方式定义原型中的方法, 这样就不会覆盖原本的默认值: 12345678910function Point(x, y) { this.x = x; this.y = y;}Point.prototype.dist = function () { return Math.sqrt((this.x*this.x)+(this.y*this.y));};Point.prototype.toString = function () { return \"(\"+this.x+\", \"+this.y+\")\";}; constructor属性不是特别重要, 主要用于检查特定的实例由哪个构造器创建: 12345var p = new Point(2, 2)p.constructor// [Function: Point]p.constructor.name// 'Point' 扩展对象在JavaScript中, 扩展一个对象意味着在对象中添加新属性, 但会带来不好的结果: 比如, 我们现在要扩展对象A, 扩展的内容为对象B, 仅仅是将B的属性浅拷贝到A中. JavaScript中有个较不常见的实现这种扩展的方法Object.extend(), 该方法来自于框架”Prototype”. 以下是其实现方式: 1234567function extend(target, source) { // 不要这样做: for (var propName in source) { target[propName] = source[propName]; } return target;} 上述代码的问题是它使用for-in来遍历对象的所有属性, 包括继承自原型的属性. 见下例: 12345extend({}, new Point())//{ x: undefined,// y: undefined,// dist: [Function],// toString: [Function] } 我们想要扩展的对象获得Point的实例对象本身的属性x和y, 但是来自原型的继承属性dist和toString方法并不是我们想要的. 继承的属性也被拷贝到第一个对象参数中, 因为for-in会遍历包括继承的属性在内的所有属性. Point继承了多个来自Object对象的属性, 比如valueOf: 123var p = new Point(7, 1);p.valueOf// [Function: valueOf] 但valueOf这类属性没有被拷贝到对象实例中, 因为for-in只会遍历可枚举(Enumerable)(详见参考[2])属性, 而valueOf这类属性不可枚举: 1234p.propertyIsEnumerable(\"valueOf\")// falsep.propertyIsEnumerable(\"dist\")// true 为了让extend()方法达到我们预期的效果, 必须确保只有原对象自身的属性被拷贝到目标对象. 12345678function extend(target, source) { for (var propName in source) { if (source.hasOwnProperty(propName)) { target[propName] = source[propName]; } } return target;} 还有一个问题是: 如果source对象本身含有一个名为”hasOwnProperty”的属性(详见参考[3]), 上述代码就无法成功执行: 12extend({}, { hasOwnProperty: 123 })// TypeError: Property 'hasOwnProperty' is not a function 失败的原因是source.hasOwnProperty获取的是source对象自身的hasOwnProperty属性, 属性值是一个数字, 而非原型链中的同名属性. 可以通过从原型链中获取这个属性解决该问题: 12345678910function extend(target, source) { var hasOwnProperty = Object.prototype.hasOwnProperty; for (var propName in source) { // 把this绑定到source对象, 之后再调用hasOwnProperty()方法 if (hasOwnProperty.call(source, propName)) { target[propName] = source[propName]; } } return target;} 在ECMAScript5或者更旧版本但装载了shim(详见参考[4])的引擎, 使用以下版本的extend()方法更好, 因为这个版本在实现继承(扩展)的同时, 没有改变source对象属性的描述符, 例如可枚举性. 12345678function extend(target, source) { Object.getOwnPropertyNames(source) .forEach(function(propName) { Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName)); }); return target;} 设置对象的原型现在, 我们已经知道如何通过一种不太完美的方式为对象添加属性. 还了解了怎么通过原型添加属性以避免前一种方法带来的缺陷: 令属性只存在于构造器的所创建的实例中, 但不存在于对象本身. 如果这种方式的继承可以更直接地实现, 同时不需要通过构造器设置对象原型, 那就更好了. 由于对象原型是个十分重要, 高度优化的特性, 利用原型创建新对象是实现这种继承唯一标准的方式. 也就是说, 你只有一次机会设置对象的原型, 就是在创建它的时候. 以下代码使用了ECMAScript 5的Object.create()方法创建了一个新对象, 该对象的原型是对象proto. 12345var proto = { bla: true };var obj = Object.create(proto);obj.foo = 123;obj.bar = \"abc\"; 新建的对象obj同时包含继承和自身的属性: 1234obj.bla// trueobj.foo// 123 ECMAScript 5 shim 则使用与以下类似的代码使Object.create兼容旧浏览器. 12345678if (Object.create === undefined) { Object.create = function (proto) { function Tmp() {} Tmp.prototype = proto; // 创建原型为proto的新空对象 return new Tmp(); };} 以上代码使用了一个临时函数构造器来创建含有特定原型的对象实例. 直到现在, 我们使用Object.create()时, 都没有考虑第二个参数, 在该参数中可以定义新建对象的属性: 1234var obj = Object.create(proto, { foo: { value: 123 }, bar: { value: \"abc\" }}); 这些属性是通过property descriptors(Object.defineProperty()方法)定义的. 使用该方法, 不仅能定义属性和属性值, 还可以定义属性的描述符, 比如可枚举性. 现在让我们试着实现一个方法protoChain(), 它是Object.create()方法的简化版本. 不过该简化版本没有实现定义属性描述符的功能, 例: 1234var obj = protoChain(proto, { foo: 123, bar: \"abc\"}); 泛化上述protoChain方法: 1protoChain(obj_0, obj_1, ..., obj_n-1, obj_n) 我们需要先创建全新的对象才可以为其添加原型. 因此, protoChain()返回obj_n的浅拷贝, obj_n的原型是obj_n-1的浅拷贝, 以此类推. obj_0是唯一一个未被拷贝的从chain返回的对象. 可以这样实现protoChain()方法: 12345678910function protoChain() { if (arguments.length === 0) return null; var prev = arguments[0]; for(var i=1; i &lt; arguments.length; i++) { // 通过原型 prev 创建 arguments[i] 的拷贝 prev = Object.create(prev); extend(prev, arguments[i]); } return prev;} 创建二级构造器subtyping的意思是基于当前存在的构造器创建一个新的构造器. 新的构造器叫做二级构造器(sub-constructor), 当前存在的构造器是super-constructor. 下面的ColorPoint是Point的二级构造器: 1234function ColorPoint(x, y, color) { Point.call(this, x, y); this.color = color;} 以上代码为构造器ColorPoint将要创建的实例设置了属性x, y和 color. 这个功能是通过绑定this(ColorPoint的实例)到Point对象里实现的: Point作为函数被调用, 利用call()方法调用Point确保其在正确的执行环境下被调用. 这样的话, Point()函数为我们添加了x和y属性, color属性则是由我们自己添加. 然后需要添加方法: 有一部分的方法希望从Point中继承, 有一些则想要自己定义, 可以通过extend()方法实现: 12345// function ColorPoint: 见上extend(ColorPoint.prototype, Point.prototype);ColorPoint.prototype.toString = function () { return this.color+\" \"+Point.prototype.toString.call(this);}; 首先将Point.prototype上的方法拷贝到ColorPoint.prototype, 然后添加自己定义的方法: 以上代码中, 我们修改Point的toString()方法, 在toString()原来的结果前加上ColorPoint的color属性值. 更多调用super-prototype方法的信息详见参考[5]. 执行上述代码后, 调用ColorPoint的toString()方法就能得出我们所预期的结果: 123var cp = new ColorPoint(5, 3, \"red\");cp.toString()// 'red (5, 3)' 对代码进一步优化, 我们可以通过将Point.prototype设置为ColorPoint.prototype的原型避免添加过多属性到ColorPoint.prototype. 123456// function ColorPoint: 见上ColorPoint.prototype = Object.create(Point.prototype);ColorPoint.prototype.constructor = ColorPoint;ColorPoint.prototype.toString = function () { return this.color+\" \"+Point.prototype.toString.call(this);}; 首行代码中, 我们替换了ColorPoint.prototype的默认值, 因此需要在第二行代码中设置它的constructor属性值. 设置单一的constructor属性在概念上很容易理解, 但是手写代码的步骤较复杂, 因此可以通过辅助函数inherits()简化步骤: 12345// function ColorPoint: 见上ColorPoint.prototype.toString = function () { return this.color+\" \"+Point.prototype.toString.call(this);};inherits(ColorPoint, Point); 函数inherits()借鉴了Node.js的util.inherits()方法. 该方法能帮助我们创建二级类, 并且保持一般函数构造器的简洁. 使用inherits()时需要注意以下几点: 不必在意添加方法到原型之前还是之后调用inherits()函数. inherits()函数应该确保constructor属性设置正确. 下面是inherits方法的实现: 1234567function inherits(SubC, SuperC) { var subProto = Object.create(SuperC.prototype); // At the very least, we keep the \"constructor\" property // At most, we keep additions that have already been made extend(subProto, SubC.prototype); SubC.prototype = subProto;}; 关联父级属性还有一个方法可以进行优化, ColorPoint.prototype.toString()实际上是调用以下函数: 1Point.prototype.toString.call(this); 然而这并不理想, 因为我们写死了ColorPoint的父级构造器. 以下是更好的方式: 1ColorPoint._super.toString.call(this); 为了使上述代码成立, inherits()函数执行以下赋值语句即可: 1SubC._super = SuperC.prototype; 从这部分开始, inherits()方法与Node.js中的inherits()开始有所差异, 在Node.js中, SubC.super_指向SuperC. 而这里的ColorPoint构造器引用被写死, 指向Point. 想要避免这样的情况, 可以按照以下方式调用: 1ColorPoint._super.constructor.call(this, x, y); 代码不是很简洁, 但确实达到了目的, 最后的ColorPoint是这样的: 12345678function ColorPoint(x, y, color) { ColorPoint._super.constructor.call(this, x, y); this.color = color;}ColorPoint.prototype.toString = function () { return this.color+\" \"+ColorPoint._super.toString.call(this);};inherits(ColorPoint, Point); 总结本文相关内容源码GitHub地址: inheritance-by-example 延伸阅读 为何我推荐使用构造器: In defense of JavaScript’s constructors 创建对象的几种模式: Exemplar patterns in JavaScript 保持对象中的数据私有: Private data for objects in JavaScript 深入理解属性(属性, 属性描述符等): Object properties in JavaScript 参考 What’s up with the “constructor” property in JavaScript? JavaScript properties: inheritance and enumerability The pitfalls of using objects as maps in JavaScript es5-shim: use ECMAScript 5 in older browsers A closer look at super-references in JavaScript and ECMAScript.next","link":"/posts/2017/07/21/js-inheritance-by-example/"},{"title":"script error","text":"script error 和 JavaScript 中的错误类型 什么是”Script error”使用 JavaScript 的 onerror 事件处理异常, 很有可能会遇到”Script error”这样的错误. “Script error”其实是由跨域的第三方JavaScript文件引起的. 这是个很令人头疼的错误, 因为尽管出现了错误, 但是我们无法得知具体是怎样的错误, 也不知道这个错误产生的位置. 这时, 就可以使用window.onerror来了解错误的具体信息. 起因\b: 跨域脚本查看以下HTML代码, 假设这部分代码由是这个 http://example.com/test 网页的HTML: 123456789101112131415&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;example.com/test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"http://another-domain.com/app.js\"&gt;&lt;/script&gt; &lt;script&gt; window.onerror = function (message, url, line, column, error) { console.log(message, url, line, column, error); } foo(); // call function declared in app.js &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以下是 http://another-domain.com/app.js 的内容, 只声明了一个函数 foo, 调用foo始终会抛出ReferenceError. 1234// another-domain.com/app.jsfunction foo() { bar(); // ReferenceError: bar is not a function} 浏览器加载HTML文档, 执行 JavaScript 文件之后, 控制台就会输出以下内容(通过window.onerror回调输出) 1\"Script error.\", \"\", 0, 0, undefined 这并不是 JavaScript 的 bug, 浏览器会可以隐藏跨域脚本的错误信息以确保安全性. 这样的方式能够避免脚本不小心在onerror回调中泄露敏感信息. 因此, 只有在同域的window.onerror回调函数中, 才可以看到详细的错误信息, 除此之外, 只能看到”Script errpr” 尽管浏览器出于好意隐藏了详细错误信息, 但是有很多情况下我们需要知道跨域脚本究竟产生了怎样的错误: 应用的JavaScript文件位于不同域下. 使用托管于CDN的库, 比如cdnjs. 使用商业性的第三方JavaScript库, 只存在于外部服务器. 为了解决上述的问题, 必须要知道错误的详细信息, 我们只需要实行以下操作: 解决办法: CORS属性及头部1.添加crossorigin=”anonymous”到 script 标签的属性中: 1&lt;script src=\"http://another-domain.com/app.js\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 以上属性告诉浏览器匿名获取目标文件, 这样的话, 浏览器请求该文件时, 就不会发送潜在的泄露用户资料的信息, 如cookie或HTTP认证信息. 2.添加支持跨域的HTTP头部 1Access-Control-Allow-Origin: * CORS指: 跨域资源共享, 由一系列的API组成(其中大部分是HTTP头部), 这些API用以说明跨域文件应该以怎样的方式被获取. 通过设置Access-Control-Allow-Origin: *. 服务器给浏览器这样的指示: 任何域名下的文件都可以获取该文件. 同样可以将*换成特定的域名:1Access-Control-Allow-Origin: https://www.example.com 通过以上两步的配置, 任何由该文件引起的错误详细信息都会通过window.onerror的回调函数抛出, 不再是”Script error” 1\"ReferenceError: bar is not defined\", \"http://another-domain.com/app.js\", 2, 1, [Object Error] 另一种解决方式: 使用 try/catch有时候, 我们没有权限修改所使用的第三方JS头部. 这样的情况下, 就得使用try/catch方法, 见下例, 不添加crossorigin=&quot;anonymous&quot; 1234567891011121314// &lt;!-- note: crossorigin=\"anonymous\" intentionally absent --&gt;&lt;script src=\"http://another-domain.com/app.js\"&gt;&lt;/script&gt;&lt;script&gt;window.onerror = function (message, url, line, column, error) { console.log(message, url, line, column, error);}try { foo(); // call function declared in app.js} catch (e) { console.log(e); throw e; // intentionally re-throw (caught by window.onerror)}&lt;/script&gt; 第三方JS文件: 1234// another-domain.com/app.jsfunction foo() { bar(); // ReferenceError: bar is not a function} 运行上述HTML, 会输出以下内容: 12345=&gt; ReferenceError: bar is not defined at foo (http://another-domain.com/b.js:2:3) at http://example.com/test/:15:3=&gt; \"Script error.\", \"\", 0, 0, undefined 第一个输出的声明来自try/catch的捕获, 获得了错误对象, 含有错误类型, 错误信息以及堆栈轨迹, 包括文件名以及错误所在行号. 第二个输出的声明来自window.onerror的捕获, 只能够输出”Script error”, 没有其它有效信息. 尽管try/catch是一种解决办法, 但是能够修改HTML文档和CORS头部的情况下, 用window.onerror是更好的方式. JavaScript中的异常处理JS代码抛出异常后, JS解释器(interpreter)会执行处理异常的代码, 如果没有处理异常的代码, 应用就会在抛出异常的函数中 return. 一步步执行执行栈中的函数, 直到找到处理异常的函数或到达执行栈顶部的函数, 应用内的终止运行. Error 对象当异常发生, Error 对象会被创建并抛出, JavaScript 定义了7种类型的错误对象: Error一般开发者自定义的异常会使用该对象, 使用以下方式定义: var error = new Error(&quot;error message&quot;) Error对象有两个属性, name 和 message. name 指异常的类型, 此时为 Error. message 是对该错误的具体描述, 以参数形式传入, 此时是”error message”. 其他6种类型的更加具体Error对象也含有同样的这两种属性. RangeError试图传递一个number参数给一个范围内不包含该number的函数时会引发RangeError. 当传递一个不合法的length值作为Array 构造器的参数创建数组, 或者传递错误值到数值计算方法（Number.toExponential(), Number.toFixed(), Number.toPrecision()） 12var pi = 3.14159pi.toFixed(10000) // RangeError ReferenceError引用错误: 引用作用域内不存在的变量抛出的错误 123function foo() { bar++; // ReferenceError} SyntaxError语法错误: C 和 Java在编译过程中, 会抛出 Syntax Error, 但 JavaScript 作为解释性语言, 代码执行过程中才会发现Syntax Error. Syntax errors are unique as they are the only type of exception that cannot be recovered from. 1if (foo) { // SyntaxError TypeError当某个值并非预期的类型, 会抛出 TypeError, 这种情况常出现在调用不存在的对象方法时 123var foo = {}foo.bar() // TypeError URIErrorencodeURI()/decodeURI() 中传入的参数格式不是合法的URI, 会抛出此错误 decodeURIComponent(&quot;%&quot;); // URIError EvalError不合理使用eval()函数, 会抛出该错误. 但在最新版本的EcmaScript标准中, 已不再使用该错误类型. 处理异常JavaScript 使用 try…catch…finally 处理程序中的异常: 1234567try { // 意图执行, 有可能抛出异常的代码} catch (exception) { // 处理意图执行的代码抛出的异常} finally { // 始终会执行的代码} 使用 try 之后必须跟上 catch 或者 finally, 或者两者均有. catch语句尽管 catch是可选语句, 但是处理异常的代码本应是存在的. catch语句会阻止异常在调用栈中(…), 这样即使出现异常, 程序还能正常运行. propagating through the call stack. 如果try语句中的异常发生, 程序的控制权就转给了catch语句中的代码. 同时所发生的异常也被传入其中. 以下例子说明了catch语句是如何处理”ReferenceError”的, ReferenceError对象传入通过参数’exception’传入catch 123456try { foo++; // ReferenceError} catch (exception) { var message = exception.message; // 处理异常} 复杂的程序会产生各种各样的异常, 这种情况下, 可以利用instanceof操作符来区分不同类型的异常. 以下例子中, 假定try语句中产生了多种类型的异常, 紧随其后的catch语句通过instanceof操作符区分不同的异常并对其做出相应的处理. 1234567891011try { // 假定此处发生异常} catch (exception) { if (exception instanceof TypeError) { // 处理 TypeError 异常 } else if (exception instanceof ReferenceError) { // 处理 TypeError 异常 } else { // 处理其他类型的异常 }} finally语句finally语句中的代码始终会执行, 常在其中加入一些总结处理的代码(例如关闭文件…). 即使发生的异常没有被捕获, finally语句也会执行, 这种情况下, finally中的语句执行, 然后被抛出的异常正常执行. 还有一点要注意, 即使try, catch中有return声明, finally语句也会执行. 因此以下函数返回的是false 1234567function foo() { try { return true; } finally { return false; }} 抛出异常JavaScript 允许开发者抛出自定义的异常, 通过throw声明实现. 没有经验的开发者或许会很困惑, 一般开发者都会努力写出没有任何错误的代码, 可是throw声明却主动引入错误. 实际上, 这样的方式能够帮助开发者写出更加容易调试和维护的代码. 在自定义异常中抛出合理的错误信息使得问题更容易被发现和解决. 下面是几个throw声明的例子. 对于声明中抛出的异常类型和抛出次数, JavaScript都没有做出限制. 1234567throw true;throw 5;throw \"error message\";throw null;throw undefined;throw {};throw new SyntaxError(\"useful error message\"); 虽然throw声明中可以包含任何数据类型, 使用内置的异常类型始终是更好的选择. 比如在Firefox浏览器下, 如果抛出的是内置异常类型, 浏览器就会在这些对象上添加一些调试信息, 例如错误所在文件名及行号. 举个例子, 你在程序中进行了除法操作, 但是被除数却是0, 这时结果就会是Infinity(原文是NaN, 但是现在是Infinity, 应该是新标准). 这种情况下, 调试起来就会很困难. 如果在被除数是0的情况下抛出异常就能使调试变得容易: 123456if (denominator === 0) throw new Error(\"Attempted division by zero!\");// 更加合适的错误类型: RangeError: if (denominator === 0) throw new RangeError(\"Attempted division by zero!\"); 自定义异常对象处理自定义错误信息之外, 我们还能通过extend Error类型自定义错误对象(继承Error), 然后像使用其他内置异常类型一样使用自定义的错误对象. 123456789// 创建自定义对象function DivisionByZeroError(message) { this.name = \"DivisionByZeroError\"; this.message = (message || \"\");}// 实现继承DivisionByZeroError.prototype = new Error();DivisionByZeroError.prototype.constructor = DivisionByZeroError; Resources Exceptional Exception Handling in JavaScript What the heck is “Script error”? Proper Error Handling JavaScript Capture and report JavaScript errors with window.onerror","link":"/posts/2017/12/25/script-error/"},{"title":"React Ref","text":"引用某个react UI组件的时候遇到了这样的告警: addComponentAsRefTo(…): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component’s render method, or you have multiple copies of React loaded. 于是去了解了一下ref的用法: Refs and the DOMReact的典型数据传递方式是通过props将数据从父组件传给子组件. 一旦props更新, 子组件重新渲染. 但在某些情况下, 开发者会想要不通过props传递数据更新, 而是直接更新子组件. 这些子组件可以是React组件的实例或者是DOM元素. 对于以上这两种子组件, React提供了一种直接更新的方法: 使用refs. 何时使用refs 处理聚焦, 文本选择, 影音播放 触发imperative animation 参考 与第三方DOM库结合使用时 如果操作可以使用说明式方式完成(things can be done declaratively), 尽量使用说明式, 避免使用refs. 比如, 在Dialog组件中, 能够通过传isOpen属性完成的操作, 就不要暴露open(), close()方法执行. 不要滥用refs开发者很容易滥用refs来处理问题, 但更好的方式是考虑清楚各个组件层级应该拥有的state, 使不同层级的组件拥有不同的state使得应用更加清晰有条理, 易于开发维护. 处理state相关例子 添加ref到DOM元素中ref是React组件中的一个特殊属性, 该属性接受一个回调函数, 在该组件 mount/unmount 的时候回调函数会立即执行. 当ref属性用在HTML元素中时, ref回调函数的参数是该DOM元素. 以下代码中, 使用ref存储了DOM节点(第一个input)的引用. 123456789101112131415161718192021222324252627class CustomTextInput extends React.Component { constructor(props) { super(props); this.focusTextInput = this.focusTextInput.bind(this); } focusTextInput() { // 使用DOM API 显式聚焦第一个`input`元素的文本 this.textInput.focus(); } render() { // 使用`ref`将DOM节点(第一个`input`)的引用存储到this.textInput return ( &lt;div&gt; &lt;input type=\"text\" ref={(input) =&gt; { this.textInput = input; }} /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick={this.focusTextInput} /&gt; &lt;/div&gt; ); }} 当以上CustomTextInput组件mount时, React会调用ref回调函数, 当unmount时, 传入参数null调用. 分别在componentDidMount, componentDidUpdate这两个生命周期中. 在React组件内部使用ref使用是获取DOM元素的常用方式, 以回调的形式(如上例)使用该属性是推荐方式. 更加简洁的推荐使用方式: ref={input =&gt; this.textInput = input}. 在class组件中添加ref在类组件中使用ref属性时, ref回调接受已经mount的组件实例作为其参数. 如果我们想要实现上例中的CustomTextInput在mount之后立即模拟被点击, 可以这样做: 123456789101112class AutoFocusTextInput extends React.Component { componentDidMount() { this.textInput.focusTextInput(); } render() { return ( &lt;CustomTextInput ref={(input) =&gt; { this.textInput = input; }} /&gt; ); }} 注意CustomTextInput只有在被声明为class组件时, 这种情况才生效. 123class CustomTextInput extends React.Component { // ...} Refs 和 Functional 组件因为funtional组件没有实例, 因此不可以在其中使用ref属性. 12345678910111213function MyFunctionalComponent() { return &lt;input /&gt;;}class Parent extends React.Component { render() { // 不可以这样做: return ( &lt;MyFunctionalComponent ref={(input) =&gt; { this.textInput = input; }} /&gt; ); }} 不过在functional组件中的DOM元素或class组件中, 可以使用ref属性 123456789101112131415161718192021function CustomTextInput(props) { // textInput 必须在此处声明, 这样ref回调函数才可以引用它 let textInput = null; function handleClick() { textInput.focus(); } return ( &lt;div&gt; &lt;input type=\"text\" ref={(input) =&gt; { textInput = input; }} /&gt; &lt;input type=\"button\" value=\"Focus the text input\" onClick={handleClick} /&gt; &lt;/div&gt; ); } 将DOM ref暴露给父组件在有些情况下(但极少), 开发者需要在父组件中获取子组件的DOM节点. 一般来说这种方法是不推荐的, 因为违背了组件封装的原则, 可是在某些情况下, 却不得不用到这种方法, 比如触发聚焦或计算子组件DOM节点的大小与位置. 开发者可以给子组件添加ref属性(见在class组件中添加ref), 但这并不是理想的解决方式, 因为这种方式只能够获取到组件的实例, 而不是DOM节点, 此外, 如果子组件是functional组件, 这种方法也不会生效. 因此在这种情况下, React推荐开发者在子组件中暴露一个特殊的属性. 该组组件接受一个名为inputRef的函数属性. React会对其进行处理, 然后将ref属性添加到该组件下的DOM节点上. 这样, 父组件就能够将ref回调传给子组件的DOM节点, 见下例: 1234567891011121314151617function CustomTextInput(props) { return ( &lt;div&gt; &lt;input ref={props.inputRef} /&gt; &lt;/div&gt; );}class Parent extends React.Component { render() { return ( &lt;CustomTextInput inputRef={el =&gt; this.inputElement = el} /&gt; ); }} 以上例子中, Parent组件将ref回调通过inputRef属性传给CustomTextInput, CustomTextInput再将该回调以ref属性的方式传给&lt;input&gt;. 最终, 父组件Parent中的this.inputElement的值就是子组件CustomTextInput下&lt;input&gt;元素. 注意以上例子中, 属性inputRef没有特殊意义, 就是组件的一般属性. 不过, 必须要在&lt;input&gt;元素本身使用ref属性, 这样React才会将该属性与DOM节点关联. 即使CustomTextInput是functional组件, 以上的例子也会生效. ref是有特定含义的属性, 只能够在DOM元素和class组件中使用, inputRef没有特定含义, 只是一般的属性, 因此在组件中都可以使用, 没有使用上的限制. 这种模式的另一个优点是: 可以深入多层级的组件. 比如, 在Parent组件中不需要获取其子组件的DOM节点, 但包含Parent组件的GrandParent组件需要获取, 这时也可以使用inputRef来DOM节点. 例子: 1234567891011121314151617181920212223242526function CustomTextInput(props) { return ( &lt;div&gt; &lt;input ref={props.inputRef} /&gt; &lt;/div&gt; );}function Parent(props) { return ( &lt;div&gt; My input: &lt;CustomTextInput inputRef={props.inputRef} /&gt; &lt;/div&gt; );}class Grandparent extends React.Component { render() { return ( &lt;Parent inputRef={el =&gt; this.inputElement = el} /&gt; ); }} 此时, ref回调是在Grandparent组件中首次声明, 通过inputRef一层层传到CustomTextInput, 使得Grandparent组件通过this.inputElement获取到&lt;input&gt;元素. 总的来说, 我们是反对暴露DOM节点的, 但特殊情况总是免不了, 此时就要使用以上的方法. 注意这种方式要求你在子组件中添加一些代码, 如果你无法控制子组件, 还有另外一种方式findDOMNode(), 但不推荐使用这种方式. 过时API: 字符串ref过去将ref以字符串的形式声明, ref=&quot;textInput, 然后通过this.refs.textInput获取相应的DOM节点. 但现在这种方法不被推荐使用, 因为字符串形式的ref会引起一些问题, 所以React团队不推荐这种用法, 在将来的版本中或许会完全抛弃. 一个小问题如果ref函数以inline函数的方式定义, 它会被调用两次, 第一次的参数是null, 第二次是DOM元素. 这是因为每一次渲染都会创建一个函数的实例, React需要清除旧的ref然后重新设置一个新的ref. 以bound method的方式定义ref回调函数可以避免这个问题, 不过在大部分情况下, 即使以inline函数的方式定义, 也不会引起什么问题. Refs Must Have Owner开发过程中遇到了以下警告: React 16.0.0+ 版本中: 12345Warning:Element ref was specified as a string(myRefName) but no owner was set. You may have multiple copies of React loaded. (details:https://fb.me/react-refs-must-have-owner). 旧版本: 12345678Warning:addComponentAsRefTo(…): Only a ReactOwner can have refs. You might be adding a ref to a componentthat was not created inside a component’s render method, or you have multiple copies of React loaded. 一般是由以下三种原因导致的: 在fuctionnal组件中添加ref属性 在组件的render()函数之外创建了一个元素, 在该元素中添加了ref属性 加载了多个React的拷贝(其中一个可能原因是npm依赖配置错误) 在funtional组件中添加ref如果组件&lt;Foo&gt;是functional组件, 不可以这样添加ref: 1&lt;Foo ref={foo} /&gt; 在render方法之外添加值为字符串形式的ref属性当开发者添加了值为字符串的ref属性到了一个没有父组件的组件中(即该组件不在父组件的render方法内创建) 不可以这样添加 ref: 1ReactDOM.render(&lt;App ref=\"app\" /&gt;, el); 正确方式: 1234567let app;ReactDOM.render( &lt;App ref={inst =&gt; { app = inst; }} /&gt;, el); 多个React拷贝Bower在删除重复数据方面处理得很好, 可是npm并不. 如果调试之后发现不是ref的用法出了问题, 那很可能就是因为项目中加载了多个React的拷贝. 这种问题常常在项目中引入第三方库的时候出现. 在命令行中输入npm ls react可以查看项目中存在的react版本. 参考 Refs and the DOM Refs Must Have Owner","link":"/posts/2018/01/18/react-ref/"},{"title":"常用数组方法及其应用","text":"JavaScript中一些较常用, 能提高效率的数组方法. forEach示例: 1234567891011121314const colors = ['red', 'green', 'blue'];// 不使用forEach// 遍历数组for(var i = 0; i &lt; colors.length; i++){ console.log(colors[i]);}// 使用forEachcolors.forEach(color =&gt; { console.log(color);}); 原数组的元素被遍历传入Iterator Function并执行. 更实际的应用: 12345678const numbers = [1, 2, 3, 4];let sum = 0;numbers.forEach(number =&gt; { sum += number;});console.log(sum); map示例: 123456789101112131415const numbers = [1, 2, 3, 4];// 将原数组中各个元素X2输出// 不使用map实现let doubledNumbers = []; // 创建一个新数组来存储数据, 为了不改变原数组 (avoid mutating)for(var i = 0; i &lt; numbers.length; i++){ doubledNumbers.push(numbers[i] * 2)}console.log(doubledNumbers); // [2, 4, 6, 8]// 使用map实现let doubledMap = numbers.map(number =&gt; number * 2)console.log(doubledMap); // [2, 4, 6, 8] 原数组的元素被遍历传入Iterator Function并执行, 执行后的结果被返回并存入新数组. map可以用于汇总数组内各个元素的属性值, 并输出相关信息. 例子: 1234567891011121314const cars = [ {model: 'Buick', price: 'cheap'}, {model: 'Camaro', price: 'expensive'}];const model = cars.map(car =&gt; { return car.model;});console.log(model); // ['Buick', 'Camaro']const price = cars.map(car =&gt; { return car.price;});console.log(price); // ['cheap', 'expensive'] 渲染数据列表: 可在浏览器控制台输入以下代码片段查看效果 123456789101112131415const cars = [ {model: 'Buick', price: 'cheap'}, {model: 'Camaro', price: 'expensive'}]; const carsList = document.createElement('ul'); const aboutCars = cars.map(car =&gt; { return `&lt;li&gt;${car.model} is ${car.price}&lt;/li&gt;`; });aboutCars.forEach(car =&gt; { carsList.innerHTML += car;})document.body.innerHTML = '';document.body.appendChild(carsList); 更实际的应用: filter示例: 12345678910111213141516171819202122232425262728const products = [ { name: 'cucumber', type: 'vegetable', quantity: 10, price: 1 }, { name: 'banana', type: 'fruit', quantity: 8, price: 15 }, { name: 'cucumber', type: 'vegetable', quantity: 25, price: 12 }, { name: 'orange', type: 'fruit', quantity: 30, price: 8 },]// 不使用filter实现// 筛选出类型为水果的产品let filteredProducts = [];for(var i = 0; i &lt; products.length; i++){ if(products[i].type === 'fruit'){ filteredProducts.push(products[i]) }}console.table(filteredProducts);// 使用filter实现// 筛选出类型为水果的产品const fruit = products.filter(product =&gt; product.type === 'fruit');console.table(fruit);// 筛选出类型为蔬菜, 且数量大于0, 且价格小于10的产品const veg = products.filter(product =&gt; product.type === 'vegetable' &amp;&amp; product.quantity &gt; 0 &amp;&amp; product.price &lt; 10);console.table(veg); console.table将数组以表格的形式显示在控制台中, 可读性更强. 原数组的元素被遍历传入Iterator Function, Iterator Function返回值的类型为布尔值, 如果返回true, 则该元素被存入结果数组. 更实际的应用: 筛选出指定post的comment内容: 1234567891011121314const post = { id: 4, title: 'New Post'};const comments = [ { postId: 4, content: 'Awesome Post'}, { postId: 3, content: 'It was ok'}, { postId: 4, content: 'neat'}];function commentsForPost(post, comments){ return comments.filter(comment =&gt; comment.postId === post.id);}const filteredComments = commentsForPost(post, comments);console.table(filteredComments); 在Todo App中: 未完成的todo会一直显示, 完成的todo只有在showCompleted为true时才显示123const filteredTodos = filteredTodos.filter((todo) =&gt; { return !todo.completed || showCompleted;}); Ps: 逻辑操作符 ||(“或”) expr1 || expr2, 如果表达式结果为true, 则返回expr1, false则返回expr1, 因此当参数为布尔值时, 任意一个参数为true, expr1 || expr2返回的结果就为true. find and findIndex示例: 123456789101112131415161718192021222324const users = [ {name: 'Jill'}, {name: 'Bill'}, {name: 'Alex'}];let user;// 寻找名为Alex的user// 不使用 findfor(var i = 0; i &lt; users.length; i++){ if (users[i].name === 'Alex'){ user = users[i]; break; }}console.log(user); // {name: 'Alex'}// 使用 findconst findUser = users.find(user =&gt; user.name === 'Alex');console.log(findUser); // {name: 'Alex'} 原数组的元素被按顺序被传入Iterator Function, Iterator Function返回值的类型为布尔值, 当Iterator Function返回true时, 停止调用Iterator Function, 并返回停止前最后一个Iterator Function执行的结果. 如果有两个相同的元素符合要求, 只有第一个会被返回. 123456789101112function Car(model){ this.model = model;}const cars = [ new Car('Buick'), new Car('Camaro'), new Car('Focus')];const focusCar = cars.find(car =&gt; car.model === 'Focus')console.log(focusCar); // {model: \"Focus\"} 更实际的应用: 利用find寻找特定id值的post: 123456789101112const posts = [ { id: 1, title: 'New Post'}, { id: 2, title: 'Old Post'}]const comment = { postId: 1, content: 'Awesome Post'};function postForComment(posts, comment){ return posts.find(post =&gt; post.id === comment.postId)}postForComment(posts, comment);// { id: 1, title: 'New Post'} 删除特定评论: 1234567891011121314151617181920212223242526272829const comments = [ { text: 'Love this!', id: 523423 }, { text: 'Super good', id: 823423 }, { text: 'You are the best', id: 2039842 }, { text: 'Ramen is my fav food ever', id: 123523 }, { text: 'Nice Nice Nice!', id: 542328 }];const comment = comments.find(comment =&gt; comment.id === 823423);console.log(comment);// 利用findIndex找到具有某个特定id的评论的索引值const commentIndex = comments.findIndex(comment =&gt; comment.id === 823423);console.log(commentIndex); // 1// 根据索引值删除该条评论, 有两种方法// 1. 但会改变(mutate)原先的comments, 不好// comments.splice(index, 1);// 2. 新建一个数组来保存修改后的comments, (immutable) 👍const newComments = [ ...comments.slice(0, commentIndex), ...comments.slice(commentIndex + 1)];console.table(comments);console.table(newComments); every and some示例: 12345678910111213141516171819202122232425262728293031const computers = [ {name: 'Apple', ram: 24}, {name: 'Compaq', ram: 4}, {name: 'Acer', ram: 32}];// 寻找所有能运行特定程序的电脑// 寻找能运行特定程序的某台电脑// 不使用 every &amp; somelet allComputersCanRunProgram = true;let onlySomeComputersCanRunProgram = false;for(let i = 0; i &lt; computers.length; i++){ let computer = computers[i]; if(computer.ram &lt; 16) { allComputersCanRunProgram = false; } else { onlySomeComputersCanRunProgram = true; }}console.log(allComputersCanRunProgram); // falseconsole.log(onlySomeComputersCanRunProgram); //true// 使用 every &amp; someconst allComputers = computers.every(computer =&gt; computer.ram &gt; 16);console.log(allComputers); // falseconst onlySomeComputers = computers.some(computer =&gt; computer.ram &gt; 16);console.log(onlySomeComputers); //true every: 数组元素被遍历传入Iterator Function, Iterator Function返回布尔值. 返回布尔值后, 会检视所有值并通过逻辑操作符&amp;&amp;(与)对最后结果进行判断. 如果每一个函数所返回的布尔值是true, 那么最后结果就为true, 有一个为false, 最后结果就为false. some: some与every很相似: 数组元素被遍历传入Iterator Function, Iterator Function返回布尔值. 返回布尔值后, 会检视所有值并通过逻辑操作符||(或)对最后结果进行判断. 如果每一个函数所返回的布尔值中有一个为true, 那么最后结果就为true, 全部为false, 最后则是false. 123456789101112131415161718const people = [ { name: 'Wes', year: 1988 }, { name: 'Kait', year: 1986 }, { name: 'Irv', year: 1970 }, { name: 'Lux', year: 2015 }];// 是否有大于19岁的人const isAdult = people.some(person =&gt; ((new Date()).getFullYear()) - person.year &gt;= 19);console.log(isAdult);console.log({isAdult}); // 对象输出时加上{}可读性更强// 是否所有人都大于19岁const allAdult = people.every(person =&gt; ((new Date()).getFullYear()) - person.year &gt;= 19);console.log({allAdult}); 更实际的应用: 1234567891011121314151617181920212223242526function Field(value){ this.value = value;}Field.prototype.validate = function(){ return this.value.length &gt; 0;}let username = new Field('2cool');let password = new Field('my_password');let birthdate = new Field('10/10/2010');// no every &amp; someusername.validate() &amp;&amp; password.validate() &amp;&amp; birthdate.validate()// everylet fields = [username, password, birthdate];let formIsValid = fields.every(field =&gt; field.validate())if(formIsValid) { // allow user to submit}else{ // show an error message} sort123456function compareFunction(a, b){ // return -1, a出现在b之前 // return 1, a出现在b之后 // return 0, 顺序不变}arr.sort(compareFunction); 示例: 12345var numbers = [4, 20, 5, 1, 3];numbers.sort(function(a, b) { return a - b;});console.log(numbers); // [1, 3, 4, 5, 20] 如果没有comparisonFunction, 先将数列中的内容转化成字符串再根据Unicode顺序排序. 12345var scores = [1, 10, 21, 2];scores.sort();console.log(scores); // [1, 10, 2, 21]// 10在 2之前,// 因为在Unicode码中'10'在'2'之前 12345678910111213141516171819202122const inventors = [ { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 }, { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 }, { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 }, { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 }, { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 }, { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 }];// 生辰从早到晚inventors.sort((a, b) =&gt; a.year - b.year ? 1 : -1);console.table(inventors);// 活得长的发明家排在后inventors.sort((a, b) =&gt; { return (a.passed - a.year) - (b.passed - b.year);});console.table(inventors); 对数组以元素字母顺序进行排序 123456789const people = ['Beck, Glenn', 'Becker, Carl', 'Beckett, Samuel', 'Beddoes, Mick', 'Beecher, Henry', 'Billings, Josh', 'Biondo, Frank', 'Birrell, Augustine', 'Black, Elk', 'Blair, Robert', 'Blair, Tony', 'Blake, William']const alpha = people.sort((lastOne, nextOne) =&gt; { const [aLast, aFirst] = lastOne.split(', '); const [bLast, bFirst] = nextOne.split(', '); return aLast &gt; bLast ? 1 : -1;})console.log(alpha); 12345678910// 对各个band按字母顺序排序, 需要忽略名字开头的冠词再进行排序const bands = ['The Plot in You', 'The Devil Wears Prada', 'Pierce the Veil', 'Norma Jean', 'The Bled', 'Say Anything', 'The Midway State', 'We Came as Romans', 'Counterparts', 'Oh, Sleeper', 'A Skylit Drive', 'Anywhere But Here', 'An Old Dog'];function strip(bandName) { return bandName.replace(/^(a |the |an )/i, '').trim();};const sortedBands = bands.sort((a,b) =&gt; strip(a) &gt; strip(b) ? 1 : -1);console.log(sortedBands); Todo App中, 未完成的Todo显示在已完成的之前: 1234567891011let sortedTodos;sortedTodos.sort((a, b) =&gt; { if(!a.completed &amp;&amp; b.completed){ return -1; }else if (a.completed &amp;&amp; !b.completed) { return 1; }else{ return 0; }}) Ps: 逻辑操作符 &amp;&amp;(“与”) expr1 &amp;&amp; expr2, 如果表达式结果为false, 则返回expr1, 否则返回expr2, 因此当参数为布尔值时, 若参数均为true, 则结果返回true, 否则返回false. reduce示例: 12345678910111213141516171819const numbers = [10,20,30];let sum = 0;// 不使用 reduce// 计算numbers数组中所有值的和for(var i = 0; i &lt; numbers.length; i++){ sum += numbers[i];}console.log(sum); //60//使用 reduceconst reduceSum = numbers.reduce((sum, number)=&gt;{ return sum + number;}, 0);console.log(reduceSum); //60 传入reduce的第二个参数是初始值(initial value), 第一个参数是Iterator Function, Iterator Function接受两个参数, 第一次执行接受初始值和原数组中的第一个元素作为参数, 执行结束后返回的值作为Iterator Function的第一个参数, 原数组中的第二个元素作为第二个参数, 以此类推. reduce功能强大, 可以使用reduce实现以上所有数组方法的功能. reduce实现map的功能: 12345678910111213141516let primaryColors = [ {color: 'red'}, {color: 'yellow'}, {color: 'blue'},];const reducedColor = primaryColors.reduce((accumulator, primaryColor)=&gt;{ accumulator.push(primaryColor.color); return accumulator;}, []);console.log(reducedColor); // [\"red\", \"yellow\", \"blue\"]// 若使用map, 则是:const mappedColor = primaryColors.map(primaryColor =&gt; primaryColor.color);console.log(mappedColor); // [\"red\", \"yellow\", \"blue\"] 计算order总量: 123456789101112const orders = [ { amount: 250 }, { amount: 200 }, { amount: 340 }, { amount: 100 }]let totalAmount = orders.reduce((sum, order) =&gt; { return sum + order.amount}, 0);console.log(totalAmount); 计算各个交通工具的个数 123456789101112const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck'];const transportation = data.reduce((obj, item) =&gt; { if (!obj[item]) { obj[item] = 0; } obj[item]++; return obj;}, {});console.log(transportation);//{car: 5, truck: 3, bike: 2, walk: 2, van: 2} 检查括号是否对称 (必须是一对括号且左括号在前) [balanced parentheses]: 1234567891011121314function balancedParens(string){ return !string.split('').reduce(function (counter, char){ if (counter &lt; 0) {return counter;} if (char === \"(\") {return ++counter;} if (char === \")\") {return --counter;} return counter; },0);}balancedParens(\"((())))\"); // falsebalancedParens(\"))((()\"); // falsebalancedParens(\"(((())))\"); // truebalancedParens(\"()()()()\"); // truebalancedParens('()()()skoaksod'); //true string.split(''): 因为reduce只能在数组中使用, 所以先将参数的类型从string转化为array; 将初始值设为0, 若数组中出现(, 计数器(counter)+1, 出现)计数器减1, 只有当计数器最后结果为0时返回true; !会将结果强制转换(coercion)为布尔值; if (counter &lt; 0) {return counter;}: 如果计数器值为负, 直接返回, 最后结果就为false, 因为左括号必须在右括号之前. 计算下例中视频时间总和 123456789101112&lt;ul class=\"videos\"&gt; &lt;li data-time=\"5:43\"&gt;Video 1&lt;/li&gt; &lt;li data-time=\"2:33\"&gt;Video 2&lt;/li&gt; &lt;li data-time=\"3:45\"&gt;Video 3&lt;/li&gt; &lt;li data-time=\"0:47\"&gt;Video 4&lt;/li&gt; &lt;li data-time=\"5:21\"&gt;Video 5&lt;/li&gt; &lt;li data-time=\"6:56\"&gt;Video 6&lt;/li&gt; &lt;li data-time=\"3:46\"&gt;Video 7&lt;/li&gt; &lt;li data-time=\"5:25\"&gt;Video 8&lt;/li&gt; &lt;li data-time=\"3:14\"&gt;Video 9&lt;/li&gt; &lt;li data-time=\"3:31\"&gt;Video 10&lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627282930313233const timeNodes = [...document.querySelectorAll('[data-time]')];// 第一种方法:////const seconds = timeNodes .map(node =&gt; node.dataset.time) // 提取标签为'data-time'的属性值, 并放入数组中 .map(timeCode =&gt; { const [mins, secs] = timeCode.split(':').map(parseFloat); // 相当于.map(str =&gt; parseFloat(str)) return (mins * 60) + secs; }) .reduce((total, vidSeconds) =&gt; total + vidSeconds);// 第二种方法://// // const times = [];// timeNodes.map(video =&gt; {// times.push(video.dataset.time.split(':').map(parseFloat));// });//// const seconds = times.reduce((sum,time) =&gt; sum += (time[0] * 60 + time[1]), 0);let secondsLeft = seconds;const hours = Math.floor(secondsLeft / 3600);secondsLeft = secondsLeft % 3600;const mins = Math.floor(secondsLeft / 60);secondsLeft = secondsLeft % 60;console.log(hours, mins, secondsLeft); 参考 JavaScript30 ES6 Javascript","link":"/posts/2016/12/29/array-methods/"},{"title":"[译]React为何在前端开发中大放异彩","text":"原文: Yes, React is taking over front-end development. The question is why.作者: Samer Buna原文发布时间: 2017.03.31译文同时发布于: Medium 译文: 本文的重点是阐述React受欢迎的原因, 并不是它与其他框架或库的比较. React为何在短时间内就获得了那么高的关注度, 下面是其中的一些原因: 使用JavaScript进行前端开发, 不可避免要与浏览器的DOM打交道, 而DOM的API却异常难用. React提出了虚拟浏览器的概念, 虚拟浏览器就像是开发者和浏览器之间的一个代理人, 开发者使用React进行开发时不需要直接处理真实浏览器, 而是处理虚拟浏览器, 使得开发更加快速且友好. React使开发者能够以声明的形式描述用户界面(UI)并模型化描述这些UI的数据. 这样的话, 开发者只需根据最终的state来描述UI(声明一个函数), 不用再费力使用许多步骤描述UI上的数据. 当state发生变化时, React会根据其变化直接处理UI的渲染. 可以说React就是JavaScript, 如果对JavaScript有一定了解, 想要上手React需要学习的API并不多, 仅需要理解几个函数和相关的用法. 理解了React的API之后, 你对JavaScript了解得越多, React编程的能力也越高. 两者之间没有太大的阻碍. 对JavaScript开发者来说, 在1个多小时内成为一名有效率的React开发者应该不在话下. 当然, React的成功不仅仅因为是上述的几个因素. 接下来我们试试看是否能列出所有的原因. 其中有一个重要因素就是虚拟DOM的概念(React的协调算法). 之后会有一个例子用以说明协调算法能给开发带来多少实际效益. 官方的对React的定义是这样的: 渲染UI的JavaScript库. 定义中有两个重点需要把握. React是库, 不是框架. 它并不是一整套基于MVC(或MVVM, MVP等)的解决方案, React只专注于一方面的任务, 并做得十分出色. React常常和其他库配合使用. 在构建UI方面, React也做的十分出色. UI指的是开发者所构建的一个界面, 用户在界面上执行操作与设备交互. 到处都是UI, 从一个简单的微波炉按钮, 到航天飞机上的仪表盘. 如果我们需要构建界面的设备理解JavaScript语言, 我们就能利用React描述UI. 浏览器能够理解JavaScript, 因此利用React描述UI毫无问题. 在这里我用了描述一词, 而不是构建, 因为开发者实际上只是告诉React我们所需要的界面是怎样的, 真正构建界面的是React. 如果没有React或与其相类似的库, 开发者就要使用Web API(DOM API)和JavaScript自己构建UI. “React是声明式的”, 这句话的意思不言自明, 我们用React描述界面, 告诉它我们想要的界面是怎样的, 并非告诉它如何构建, 因为React了解我们的需求之后, 就知道应该如何构建所需的页面, 将我们用React描述的需求转化成真正渲染在浏览器上的视图. React与HTML结合使用功能十分强大, 使用React描述页面时, 我们声明的HTML界面还能够表示动态数据, 不仅仅是静态数据. React如此受欢迎还因为以下三种设计理念: 1.运用可复用, 可组合, 包含状态的组件 在React中, 我们使用组件(component)来描述UI, 可以将组件看做简单的函数. 利用一些输入调用该函数, 得到函数给我们的输出. 有需要时可以复用这些函数, 同时还能将它们组合起来创建更复杂的组件. 组件几乎都相同, 在React中组件获取输入是通过属性(property)或状态(state)的形式, 组件的输出就是一部分UI的描述(相当于HTML之于浏览器). 我们可以在多个UI中复用同一个组件, 组件中可以包含其他组件. 和纯函数不同, 完整的React组件可以包含私有状态来存储实时变化的数据. 2.根据状态变化实时更新的特性 关于这一个设计理念, 从React这个名字中就可看出. 当组件的状态通过输入(props或state)发生变化时, 它所表示的UI(输出)就会随之发生变化. UI的描述若发生变化, 其结果必须在设备中发生实时变化. 在浏览器中, 完成这样的实时变化必须在DOM中重新渲染HTML视图. 有了React, 考虑如何, 何时渲染这些变化就不是开发者需要伤脑筋的事了, React会对状态的更新做出反应并自动更新DOM. 3.在内存中以虚拟的形式表现视图 在React中, 我们使用JavaScript写HTML(JSX). 用JavaScript根据一些数据生成HTML, 而不是扩展HTML的功能使其与数据交互. 扩展HTML是许多其他框架常用的方法. 比如Angular, 就给HTML扩展了循环, 条件语句等功能. 当我们在后台利用AJAX接受来自服务器的数据时, 仅仅使用HTML是无法处理这些数据的, 要不就是使用扩展了一些功能的HTML, 要不就像React一样利用JavaScript生成HTML. 这两种方法都有其优劣. React团队认为第二种方法的优势大于劣势, 因此在React中采取了第二种方法. 有个重要的优势表明第二种方法是更好的选择, 即利用JavaScript生成HTML使React能更方便地在内存中以虚拟的形式表现视图(即我们常听说的虚拟DOM). 使用虚拟DOM的react渲染HTML树的速度极快, 一旦状态发生改变, React就会提供一个新的HTML树渲染到浏览器的真实DOM中, 而这个更新并不是完全重新渲染, 而是只更新变化的那一部分, 因为React把变化前后的数据都保存在内存中, 因此只更新变化的那一部分是可行的. 这个更新的过程叫做Tree Reconciliation, 我认为这是自AJAX以来Web开发领域的一个里程碑式发明. 在以下的例子中, 我们会专注于最后一个设计理念, 通过一个实例分析tree reconciliation过程, 从中理解这个概念带来的巨大差异. 在这个实例中我们会利用两个完全相同的HTML模板, 第一个使用原生的Web API以及纯JS, 另一个使用React来描述视图. 因为只针对最后一个理念进行试验, 试验的具体内容是创建一个计时器, 在React实例中不使用组件, 也不会使用JSX语法, 虽然JSX语法使代码变得更简单. 在React编程中, 我一直使用JSX语法, 但在这个情况下, 直接使用React API能将概念阐述得更清楚. React协调算法实例你可以用浏览器和编辑器跟着以下的步骤自己进行操作, 网页编辑器也可以, 我会在本地建立文件使用浏览器直接进行测试(不需要用到web服务器): 现在我们从零开始构建这个实例, 先创建一个文件夹, 用你最喜欢的编辑器打开这个文件夹: 123mkdir react-democd react-demoatom . 在文件夹内创建index.html, 在里面添加标准的HTML模板, 同时在HTML中引入script.js文件, 在js文件中声明console.log语句测试是否引入成功: 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;React Demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 用浏览器打开index.html, 确保能看见空的HTML模板, 然后打开控制台, 测试是否看见自己在script.js中声明的console.log语句内容. 12open index.html # On Macexplorer index.html # On Windows 接下来引入React库, React官网中提供了引入的具体方式. 这里选择直接引入托管在CDN中的js文件, 拷贝react和react-dom托管的地址加入index.html中: 12&lt;script src=\"https://unpkg.com/react@15/dist/react.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/react-dom@15/dist/react-dom.js\"&gt;&lt;/script&gt; 可以看到我们引入了两个分离的js文件, React库可以脱离浏览器环境使用, 而如果想在浏览器中使用React库, 就需要ReactDOM库的帮助. 现在我们刷新浏览器, 在控制台中测试可以发现, 全局环境中已经存在React和ReactDOM变量: 这样简单配置之后, 就可以使用React和ReactDOM的API, 当然同时还有原生的Web API和JavaScript, 在第一个例子中会使用后两者. 使用Web API和JavaScript可以简单实现在浏览器中动态添加HTML. 首先创建div元素用以放置JavaScript生成的 HTML内容 , 给这个div的id属性命名为js. 在index.html的body元素内, script标签之前, 添加: 1&lt;div id=\"js\"&gt;&lt;/div&gt; 然后在script.js中, 通过document.getElementById获取这个id为js的div元素, 将其赋值给一个常量jsContainer. 1const jsContainer = document.getElementById(\"js\"); 要改变jsContainer中的内容, 可以用innerHTML直接在该div元素上执行setter调用. 还可以在其中添加任何想要插入的HTML模板. 现在, 我们在其中添加”class”属性为”demo”, 内容为”Hello JS”的div元素: 12345jsContainer.innerHTML = ` &lt;div class=\"demo\"&gt; Hello JS &lt;/div&gt;`; 如果各个步骤没有错误, 在浏览器页面上会出现”Hello JS”字符. 这个class为demo的div是我们目前的UI. 这个UI极其简单, 只是在页面上输出了一些文本内容. document.getElementById和element.innerHTML是原生Web API. 使用原生API, 我们直接与浏览器进行交互. 而在用React编程时, 我们使用的是React的API, 让React操纵Web API, 自己不与浏览器直接交互. React就像是浏览器的代理人, 大部分情况下, 我们只需和React交流, 不需要直接操作浏览器. 上一句提到, 只是大部分情况和React交流, 是因为还有一些情况需要直接操作浏览器, 但这样的情况是少数. 现在我们使用React创建和前一个例子一样的UI, 这次的div元素id为&quot;react&quot;, 在index.html中, div#js下添加: 1&lt;div id=\"react\"&gt;&lt;/div&gt; 现在在script.js中, 创建一个新的常量用以插入新的div: 1const reactContainer = document.getElementById(\"react\"); 常量reactContainer是这个实例中唯一一个需要使用原生web API的地方. 这样ReactDOM库才知道应用应该渲染在DOM的那个位置. 因为声明了reactContainer, 就能使用ReactDOM库将React版的HTML模板渲染到container中: 1234ReactDOM.render( /* TODO: React版的HTML模板 */, reactContainer) 之后要完成的步骤就是我们完全理解React的一个重要步骤. 还记得我之前所说的React是使用JavaScript完成HTML模板的吗, 接下来我们就要完成这项任务. 我们使用JavaScript调用React API来构建这个简单HTML用户界面, 到了实例的最后, 就能了解React为何要这样做. 在第一个例子中, 我们在jsContainer中直接加入字符串, 而这次我们使用对象而不是字符串. 任何HTML字符串都会以对象的形式表示出来, 使用React的APIReact.createElement来实现(这个API是React的核心API). 以下是具体如何用React来构建与第一个例子类似内容的代码: 12345678ReactDOM.render( React.createElement( \"div\", { className: \"demo\" }, \"Hello React\" ), reactContainer); React.createElement接受许多参数: 第一个参数是HTML标签, 在我们的例子中是div. 第二个参数是一个对象, 内容是我们想要前一个参数所具有的属性, 为了和第一个JS例子相对应, 我们在第二个参数中声明className属性, 其值为”demo”, { className: &quot;demo&quot; }转换为HTML中的属性就是class=&quot;demo&quot;. 注意我们使用的是className而不是class, 因为在React中属性名是和Web API匹配的, 因此使用className. 第三个参数是元素的内容, 我们在其中添加字符串”Hello React”. 然后就可以进行测试了. 浏览器应该将”Hello JS”和”Hello React”都渲染到页面上. 现在我们给”class”为”demo”的两个div添加上样式, 将两部分分开. 在index.html中: 1234567&lt;style media=\"screen\"&gt; .demo { border: 1px solid #ccc; margin: 1em; padding: 1em; }&lt;/style&gt; 下图是添加样式之后的页面: (以上为原文的页面, 但译者自己测试结果与其不一致, 见下图) 现在我们建立了两个节点, 一个由DOM API直接控制, 一个则是由React API控制(间接使用DOM API). 其中最主要的一点不同, 是在仅使用JS的版本中, 我们使用字符串来表示内容, 而在React的版本中, 我们使用了JavaScript函数调用, 采用对象而不是字符串来表示内容. 不管用HTML来表示的UI有多复杂, 任何HTML元素都可以使用React.createElement创建一个JavaScript对象来表示. 现在我们给之前所创建的简单UI添加新样式 – 读取用户输入的文本框. JS版本的第一个例子中, 在HTML模板中嵌入元素比较简单, 因为只需要直接插入HTML即可. 比如我们需要在”class”为”demo”的div中添加&lt;input /&gt;元素, 只需要下面这样简单的操作: 123456jsContainer.innerHTML = ` &lt;div class=\"demo\"&gt; Hello JS &lt;input /&gt; &lt;/div&gt;`; 为了在React版本的第二个例子中达到与上面一样的效果, 需要在React.createElement中加入更多参数. 在第四个参数中使用React.createElement添加input元素(注意, 任何HTML元素都是对象): 123456789ReactDOM.render( React.createElement( \"div\", { className: \"demo\" }, \"Hello React\", React.createElement(\"input\") ), reactContainer); 现在你可能会觉得使用React是”把简单的步骤复杂化”, 确实是这样, 但是我们有充分的理由这样做, 继续看下面的步骤. 我们继续在UI中分别加入时间戳, 在JS版本中, 把时间戳放在段落标签中再插入. 可以调用new Date()来显示一个简单的时间戳: 1234567jsContainer.innerHTML = ` &lt;div class=\"demo\"&gt; Hello JS &lt;input /&gt; &lt;p&gt;${new Date()}&lt;/p&gt; &lt;/div&gt;`; 要在React版本中加入同样的时间戳样式, 需要在React.createElement的第五个参数中添加元素, 如下: 1234567891011121314ReactDOM.render( React.createElement( \"div\", { className: \"demo\" }, \"Hello React\", React.createElement(\"input\"), React.createElement( \"p\", null, new Date().toString() ) ), reactContainer); 现在, JS和React版本的例子依然渲染同样的内容: 可以看到, 直到现在, React版本的例子依旧比JS版本的例子复杂. 究竟React在哪方面做得如此出色, 值得我们耗费那么多的精力用它来替代简单的HTML呢? 答案和最初渲染的HTML视图没有关系, React的长处在于更新DOM中已存在的视图. 现在我们在所创建的DOM中执行一个更新操作, 让时间戳随秒数增加. 将对两个版本的DOM操作添加到render函数中, 再使用Web APIsetInterval重复调用render函数, 每秒调用一次. 下面是script.js文件中的全部完整代码: 1234567891011121314151617181920212223242526const jsContainer = document.getElementById(\"js\");const reactContainer = document.getElementById(\"react\");const render = () =&gt; { jsContainer.innerHTML = ` &lt;div class=\"demo\"&gt; Hello JS &lt;input /&gt; &lt;p&gt;${new Date()}&lt;/p&gt; &lt;/div&gt; `; ReactDOM.render( React.createElement( \"div\", { className: \"demo\" }, \"Hello React \", React.createElement(\"input\"), React.createElement( \"p\", null, new Date().toString() ) ), reactContainer );}setInterval(render, 1000); 刷新浏览器, 在两个版本中, 时间戳字符串随着时间每秒改变一次. 现在我们就是在更新DOM中的UI. React让你大吃一惊的时刻即将来到了.如果你打算在JS版本的文本框中输入一些文字, 会发现根本无法输入. 这是可以预料到的结果, 因为在JS版本中, 我们每隔一秒就把整个DOM节点抛弃然后再重新生成. 不过, 在React版本中的文本框输入文字却一点困难都没有! 尽管React部分的代码也是每隔一秒重新渲染一次, 但React版本的实例只重新渲染了时间戳所在元素p的那一部分, 并非改变整个DOM节点, 其中的文本输入框不会随着秒数增加重新渲染, 因此可以在里面输入文字. 在页面中打开Chrome开发者工具可以观察到两种不同更新DOM的方式, 开发者工具会对更新的DOM节点进行高亮处理, 可以发现, 每隔一秒, class为”js”的div都会更新一次, 而React只是更新了含有时间戳字符串的那一部分p元素. React使用的diffing算法, 使只更新需要更新的部分DOM成为可能. diffing过程之所以可行, 是因为React的虚拟DOM以及存储在内存中的UI. 使用虚拟DOM, React先将DOM的完整版本存储在内存中, 之后如果有更新, 那么更新之后的完整版本就会被存储在内存中, 这样的话, React就能够对比两个版本, 然后根据diffing算法计算出两者的差异(在上例情况下, 不同之处为时间戳). 之后, 根据React的指令, 浏览器就会只更新有差异之处, 而不是整个DOM节点. 不管我们重新生成多少次界面, React都会”指导”浏览器只做出部分更新. 这种方法不仅效率高, 还大大降低了更新UI的复杂程度. 让React来考虑是否需要更新DOM, 这样开发者就能专注于考虑数据(state)以及如何用UI描述数据. 这样我们就可以根据需要控制数据的更新, 不用再考虑如何将这些更新渲染到真正的DOM中(因为React会帮助我们高效地完成这件事). 感谢阅读! 这是本文所完成例子的源代码, 这是demo. 如果对这篇文章或本人所著其他文章有任何疑问, 可以通过这个slack频道联系到我(邀请你自己进入该频道), 在#questions房间中提问. 我还在在线学习网站Pluralsight和Lynda中教授一些课程. 以下是我最近发布的几个课程Getting Started with React.js, Advanced Node.js以及 Learning Full-stack JavaScript.","link":"/posts/2017/04/25/why-react/"},{"title":"CORS","text":"CORS(Cross-Origin Resource Sharing 跨域资源共享) 介绍实现跨域请求有多种方式, 如使用JSONP, 但由于安全原因, JSONP在使用上有很大限制, 还能通过设置代理, 但这种方式在实现上很繁琐, 而且难以维护. CORS标准是实现跨域请求比较好的一种方式, 基于XMLHttpRequest对象实现. 想要做出CORS请求, 需要客户端和服务器端合作进行配置. 做出CORS请求使用JavaScript作出跨域请求: 创建XMLHttpRequest对象点击查看支持CORS的浏览器列表, Chrome, Firefox, Opera 和 Safari使用XMLHttpRequest2对象, IE使用相类似的XDomainRequest对象, 工作原理基本相似, 不过额外添加了一些安全措施. 首先创建请求对象, Nicholas Zakas 实现了一个简单的辅助函数以区分浏览器的差异: 1234567891011121314151617181920212223242526272829function createCORSRequest(method, url) { var xhr = new XMLHttpRequest(); if (\"withCredentials\" in xhr) { // Check if the XMLHttpRequest object has a \"withCredentials\" property. // 检查 XMLHttpRequest 对象含有 withCredentials 属性 // withCredentials 属性只存在于 XMLHTTPRequest2 对象中 xhr.open(method, url, true); } else if (typeof XDomainRequest != \"undefined\") { // XDomainRequest 对象只存在于 IE 浏览器 xhr = new XDomainRequest(); xhr.open(method, url); } else { // 该浏览器不支持 CORS xhr = null; } return xhr;}var xhr = createCORSRequest('GET', url);if (!xhr) { throw new Error('CORS not supported');} 事件处理器原始的XMLHttpRequest对象只存在一个事件处理器: onreadystatechange, 会处理所有的响应. 现在onreadystatechange依然可用, 不过XMLHttpRequest2对象引入了许多新的事件处理器. 以下是完整列表: Event Handler Description onloadstart* When the request starts. onprogress While loading and sending data. onabort* When the request has been aborted. For instance, by invoking the abort() method. onerror When the request has failed. onload When the request has successfully completed. ontimeout When the author specified timeout has passed before the request could complete. onloadend* When the request has completed (either in success or failure). *星号表示XDomainRequest不支持, 具体见: 来源 withCredentials一般来说, CORS请求默认不发送/设置任何cookie. 前端使用xhr.withCredentials = true;以配置包含cookie. 同时服务器这样配置: Access-Control-Allow-Credentials: true. The .withCredentials property will include any cookies from the remote domain in the request, and it will also set any cookies from the remote domain. 这些cookie仍然遵循同源策略, JS代码无法通过document.cookie或响应头部获取这些cookie. 只能由 remote domain 控制. 发送请求配置好后就可以发出请求. 使用: xhr.send(), 如果包含请求体, 可在参数中声明xhr.send(body)`. 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Create the XHR object.function createCORSRequest(method, url) { var xhr = new XMLHttpRequest(); if (\"withCredentials\" in xhr) { // XHR for Chrome/Firefox/Opera/Safari. xhr.open(method, url, true); } else if (typeof XDomainRequest != \"undefined\") { // XDomainRequest for IE. xhr = new XDomainRequest(); xhr.open(method, url); } else { // CORS not supported. xhr = null; } return xhr;}// Helper method to parse the title tag from the response.function getTitle(text) { return text.match('&lt;title&gt;(.*)?&lt;/title&gt;')[1];}// Make the actual CORS request.function makeCorsRequest() { // This is a sample server that supports CORS. var url = 'http://html5rocks-cors.s3-website-us-east-1.amazonaws.com/index.html'; var xhr = createCORSRequest('GET', url); if (!xhr) { alert('CORS not supported'); return; } // Response handlers. xhr.onload = function() { var text = xhr.responseText; var title = getTitle(text); alert('Response from CORS request to ' + url + ': ' + title); }; xhr.onerror = function() { alert('Woops, there was an error making the request.'); }; xhr.send();} 服务器添加跨域支持浏览器有时候会添加额外的首部做出额外的请求, 客户端无法知道这些额外的请求, 但是可以使用类似Wireshark 的 packet 分析器发现这些请求. 这些请求是Preflight request(以下译为预先请求). Preflight request做出正式CORS请求之前的预先请求, 作用是检查CORS协议是否被理解. 预先请求属于HTTP OPTIONS请求, OPTIONS请求服务器告知其支持的各种功能, 可以询问服务器通常支持哪些方法, 或者对某些特殊资源支持哪些方法. (有些服务器可能只支持对一些特殊类型的对象使用特定的操作). 预先请求首部包括 Access-Control-Request-Method, Access-Control-Request-Headers 以及 Origin. 浏览器会在必要时发出预先请求, 一般情况下, 前端开发者无需在代码中手动添加预先请求. 比如浏览器会在发出DELETE请求之前发出预先请求, 事先检测服务器是否允许DELETE请求, 请求首部内容如下: 1234OPTIONS /resource/foo Access-Control-Request-Method: DELETE Access-Control-Request-Headers: origin, x-requested-withOrigin: https://foo.bar.org 如果服务器允许DELETE请求, 会对预先请求做出如下的响应, Access-Control-Allow-Methods的值就会包含DELETE方法: 123456HTTP/1.1 200 OKContent-Length: 0Connection: keep-aliveAccess-Control-Allow-Origin: https://foo.bar.orgAccess-Control-Allow-Methods: POST, GET, OPTIONS, DELETEAccess-Control-Max-Age: 86400 CORS Preflight request 示例 12345678910OPTIONS /resources/post-here/ HTTP/1.1 Host: bar.other Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Connection: keep-alive Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type 12345678910111213HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 Vary: Accept-Encoding, Origin Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 跨域请求类型跨域请求有两种类型: 简单跨域请求 复杂跨域请求 处理简单跨域请求简单跨域请求遵循以下规则: HTTP方法匹配以下任意一个(大小写敏感): HEAD GET POST HTTP首部匹配以下内容: Accept Accept-Language Content-Language Last-Event-ID Content-Type(值必须为以下其中一个) application/x-www-form-urlencoded multipart/form-data text/plain 之所以叫简单跨域请求, 是因为这些请求不使用CORS机制也可完成. JSONP请求就属于简单跨域请求(GET). 表单提交也属于简单跨域请求(POST). 观察客户端发出的一个简单请求, 以下是相关JS代码: 123var url = 'http://api.alice.com/cors';var xhr = createCORSRequest('GET', url);xhr.send(); 以下是浏览器发出的HTTP请求, 与CORS相关的首部使用**标记: 123456GET /cors HTTP/1.1**Origin: http://api.bob.com**Host: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 合法的跨域请求总是包含Origin头部, 由浏览器自动添加, 用户可以对其进行修改. 所有跨域请求一定都包含Origin首部, 但是并非所有包含Origin首部的请求都是跨域请求, 某些同源请求也会有Origin首部. Firefox浏览器不会对同源请求添加Origin首部, 而Chrome和Safari则会对同源的POST/PUT/DELETE请求添加该首部(同源GET请求没有该首部). 以下是包含Origin首部的一个同源请求例子: 123POST /cors HTTP/1.1Origin: http://api.bob.comHost: api.bob.com 不管响应是否包含跨域相关的首部, 同源请求的响应都会直接发送给客户端. 尽管如此, 如果Origin的值与所允许的不匹配, 服务器端的代码就会返回错误, 因此要确保允许请求的来源的Origin. 以下是个合法的服务器响应: 1234**Access-Control-Allow-Origin: http://api.bob.com****Access-Control-Allow-Credentials: true****Access-Control-Expose-Headers: FooBar**Content-Type: text/html; charset=utf-8 所有CORS相关的首部前缀均为: &quot;Access-Control-&quot;. 以下是各个首部的详细内容: Access-Control-Allow-Origin(必需) - 所有合法的跨域请求都必须包含该首部, 省略该首部会导致跨域请求失败. 该首部的值可以是HTTP请求中Origin首部的值, 也可以是*以表示允许来自所有origin的请求. Access-Control-Allow-Credentials(可选) - 默认情况下, 跨域请求不包含cookie. 该首部值若为true, 则请求中就需要包含cookie. 首部唯一合法的值也是true. 如果不需要包含cookie, 正确方式是不要加上这个首部, 而不是将其值设为false. Access-Control-Allow-Credentials首部和XMLHttpRequest2对象的属性withCredentials结合工作, 如果withCredentials为true, 而响应中不含Access-Control-Allow-Credentials: true首部, 那么该跨域请求则会失败. 反之亦然. 推荐做法是如果不需要cookie, 就不要设置该首部. Access-Control-Expose-Headers(可选) - XMLHttpRequest 2 对象有一个getResponseHeader()方法, 返回特定的响应首部值. 在执行CORS请求过程中, getResponseHeader()方法只能获取简单响应首部的值, 简单响应首部包括以下几项: Cache-Control Content-Language Content-Type Expires Last-Modified Pragma 如果希望客户端能够获取到其他响应首部的值, 就要使用Access-Control-Expose-Headers - 该首部的值为以逗号分隔的一系列首部名. 处理复杂跨域请求以上方式处理了简单的GET请求, 但是如果想要处理其他例如PUT, DELETE等请求, 或者希望Content-Type首部的值支持application/json, 就需要处理复杂跨域请求. 复杂跨域请求看似只发送了一个请求, 但是实际上包含两类请求. 浏览器首先发出预先请求, 咨询服务器是否允许发送正式请求, 浏览器会处理这两类请求的具体细节. 预先请求会被缓存, 因此不需要在每一个请求前都发送. 以下是复杂跨域请求的一个例子: JavaScript: 12345var url = 'http://api.alice.com/cors';var xhr = createCORSRequest('PUT', url);xhr.setRequestHeader( 'X-Custom-Header', 'value');xhr.send(); Preflight Request: 12345678OPTIONS /cors HTTP/1.1**Origin: http://api.bob.com****Access-Control-Request-Method: PUT****Access-Control-Request-Headers: X-Custom-Header**Host: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 和简单请求一样, 浏览器会在每一个请求中添加Origin首部, 包括预先请求. 预先请求是HTTP OPTIONS请求(因此要确保服务器能够对该HTTP请求做出响应). OPTIONS也包含几个额外的首部: Access-Control-Request-Method - 实际HTTP请求的方法, 该首部始终会包含在请求的请求首部, 即使是之前定义的简单HTTP请求(GET, POST, HEAD). Access-Control-Request-Headers - 该首部的值为以逗号分隔的一系列非简单首部名. 预先请求的作用是检测正式请求是否能够成功被发送. 服务器需要检视这两种请求以确保首部的合法性. 如果HTTP方法和首部都合法, 服务器的请求和响应应如下所示: Preflight Request: 12345678OPTIONS /cors HTTP/1.1**Origin: http://api.bob.com****Access-Control-Request-Method: PUT****Access-Control-Request-Headers: X-Custom-Header**Host: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... Preflight Response: 1234**Access-Control-Allow-Origin: http://api.bob.com****Access-Control-Allow-Methods: GET, POST, PUT****Access-Control-Allow-Headers: X-Custom-Header**Content-Type: text/html; charset=utf-8 Access-Control-Allow-Origin(必需) - 与简单响应一样, 预先响应必须包含该首部. Access-Control-Allow-Methods(必需) - 以逗号分隔的所支持的HTTP方法. 尽管预先请求只是获取许可的一个简单HTTP请求, 但响应首部中必须要列出所有支持的HTTP方法. 这个首部有很大用处, 因为预先请求的响应会存入缓存中, 因此预先响应中可以包含多个请求类型的细节信息. Access-Control-Allow-Headers(如果请求中包含Access-Control-Request-Headers首部, 则该响应首部必需) - 以逗号分隔的所支持的请求首部, 与Access-Control-Allow-Methods首部的形式很相似, 会列出所有服务器支持的首部(不仅仅是预先请求中所请求的首部). Access-Control-Allow-Credentials(可选) - 见简单请求. Access-Control-Max-Age(可选) - 表示预先请求的返回结果（即 Access-Control-Allow-Methods和Access-Control-Allow-Headers提供的信息)可以被缓存多久。 一旦预先请求获取服务器许可, 浏览器就会做出正式请求, 正式请求与简单请求很相似, 响应的处理方式也一样. 正式请求: 1234567PUT /cors HTTP/1.1**Origin: http://api.bob.com**Host: api.alice.com**X-Custom-Header: value**Accept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 正式响应: 12**Access-Control-Allow-Origin: http://api.bob.com**Content-Type: text/html; charset=utf-8 如果服务器拒绝CORS请求, 则会返回类似HTTP 200的响应, 同时没有任何CORS首部. 如果预先请求中的HTTP方法或首部不合法, 服务器也会拒绝该请求. 如果响应中没有CORS专属的首部, 浏览器会假定该请求不合法, 不发送正式请求: Preflight Request: 12345678OPTIONS /cors HTTP/1.1**Origin: http://api.bob.com****Access-Control-Request-Method: PUT****Access-Control-Request-Headers: X-Custom-Header**Host: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... Preflight Response: 12// ERROR - No CORS headers, this is an invalid request!Content-Type: text/html; charset=utf-8 如果CORS请求有错误, 浏览器会执行onerror处理器. 在控制台报出如下错误: XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 但浏览器不会报出更详细的错误信息. CORS请求图示: Chrome插件跨域如果希望Chrome插件支持跨域请求, 可以用以下两种方式: 在manifest.json文件中添加如下值: 1\"permissions\": [ \"http://*.html5rocks.com\"] 服务器不需要添加额外CORS首部或者执行任何其他操作. 如果域名没有在manifest.json文件中声明, 插件就会做出一般的CORS请求, Origin首部的值为&quot;chrome-extension://[CHROME EXTENSION ID]&quot;. 此时想要执行跨域请求, 就需要使用如前所述的一般方式. CORS w/ Images在Canvas或者WebGL下, 跨域请求图片会引起很大的问题, 可以在中添加crossOrigin属性以解决大部分问题. 具体可以阅读Chromium Blog: Using Cross-domain images in WebGL和Mozilla Hacks: Using CORS to load WebGL textures from cross-domain images. 阅读CORS enabled image了解其实现方式. 参考 Using CORS Preflight request OPTIONS","link":"/posts/2017/08/11/CORS/"},{"title":"初期自学路线","text":"知乎上有一个问题: 零基础的前端开发初学者应如何系统地学习？. 根据这个问题的一些答案了解到了一些前端学习的重点和学习方法, 现在想记录一下自己的学习路线, 在知乎上也做出了回答, 下面的内容和回答内容几乎是一样的, 这里做个备份. 正文 从下定决心开始自学前端到现在半年多，感觉已经入了门，分享一些自己在学习过程遇到的好的资源以及自己的学习心得，希望可以给与自己同样喜欢计算机的初学者一些参考，然而毕竟还没有进入这个行业，知识结构一定会有所欠缺，所以也希望大家能够给我提出一些意见和建议。 先简单介绍一下自己的情况，16年7月大学本科毕业，英语专业，大学里没有选修过计算机相关课程，属于 完全零基础 。不过一直觉得计算机是自己的兴趣，大学里也曾经试过自学，不过当时没有下定决心也没有确切的目标，于是学习计划也被无限期搁置。直到大四下学期经历了半年英语相关的实习之后，就下定决心追求梦想，又偶然知道了前端这个方向，于是开始自学前端。 开始学习之前在知乎上做了一些功课，主要参考了两个回答。一个是如何教会非计算机专业的女友写代码并且找到工作?中@朱佳顺的回答，这个回答的学习路线偏 编程入门 方向。还有一个是零基础的前端开发初学者应如何系统地学习？中@张帅的回答 ，这个回答偏 前端 方向，于是结合了这两个回答的内容进行学习。按照相关的学习路线大约学习了一段时间之后，自己就大概有了方向，也开始寻找其他的资源。 下面是我对这段时间学习过的内容及其他相关资源的总结(大部分是免费资源，付费资源会注明)，其中YouTube上的视频资源会相对较多(请自备梯子)，因为相比看书，更喜欢通过视频学习。不过从开始学习到现在间隔时间会比较久，所以没办法把所有学习过的资源一一列出，不够完整请见谅。 整体内容大概是这几部分: HTML和CSS 编程入门 JavaScript React Node 其他 HTML 和 CSS 《深入浅出HTML和CSS》： 概念浅显易懂，对初学者十分友好 w3school：很多人推荐，刚开始就是看的这个教程，但是个人觉得并不适合当作教程一气呵成地看，更适合遇到疑问时查询。不过后来发现一个更好的资源查询网站:MDN。 MDN: 可以查询到很多web相关的资源: Web Technology 学习教程(个人觉得这个学习教程比w3school更加系统) … 《精通css》：虽然书名是精通xxx，但实际上对初学者很友好，前三章介绍了CSS中的相关概念以及一些写代码时的好习惯和规范，这部分看得比较详细。后几章是实际上手的章节，这几章并没有全部看完，个人觉得css的学习更多靠项目的积累，所以打算是在遇到实际问题之后再回头来参考这本书中的内容。 《css权威指南》：对于一些基础的概念解释得比较详细，有一点缺陷就是中文翻译得一般，有些内容看起来比较费解，所以有能力的同学可以选择看英文版。 PS切图技巧 PSD转HTML教程: 从 psd 到 html-慕课网 PSD To HTML-YouTube(最后一部分的jQuery可以在接触过JavaScript之后再看) CodeSchool的html和css教程(付费): CodeSchool上的前端相关课程内容十分完备，而且课程质量大都很高。付费计划是每月29.9刀，包年是19.9刀每月，我当时是买了一个月的会员然后下载了一些自己需要的课程便于以后学习，只不过不是会员就无法进行课程配套的实战练习，这些练习的质量也都很高，大家可以根据自己的实际需求选择包月或包年计划。如果担心课程质量可以先选择一部分免费的课程进行学习，觉得不错再去购买会员。 学习html和css更重要的是练手，练手项目可以在以下网站中找 百度前端技术学院 codepen codeplayer （HTML和CSS的篇幅比较少，因为个人觉得JavaScript相对来说更重要一些，而且自己也比较喜欢JavaScript。） 编程入门 Udacity的CS101: 相比MIT的CS101，对初学者更友好一些，而且个人比较喜欢这样的教学方式，短视频+小练习，完全零基础可以先看这个教程。这个教程中的许多小练习都很有价值，包括了一些初级的算法,递归、迭代等，而且几乎每个小练习都有解析。个人认为是一个很棒的入门教程，强烈推荐。（编程语言为Python） Programming JavaScript: Udacity的CS101是用Python作为教学语言来教授编程入门，这个教程是用JavaScript作为作为教学语言，和前端的学习路线更贴近，看过一部分，觉得也是一门不错的课程。不过Udacity的教程会更加完整一些，可以两个结合起来看，如果对编程语言的基础(变量，分支，循环等)已经有所了解，可以跳过前面的几个部分。这个playlist的来源应该是Foundations of Programming: Fundamentals，这里面各个视频的标题包含每个视频的主要内容，可以通过标题内容选择一些需要的视频进行学习。 MIT-CS101(2008-有中文字幕):很多学习编程的回答中都会有这门课程，是一门口碑特别好的编程入门课程，在刚开始学习时也看过一部分，但是由于对计算机完全零基础，所以对某些概念的理解困难比较大，于是看过一部分之后就暂时没有再学习。 MIT-CS101(2011-无中文字幕):和上面的课程实际上是同一门课，只是版本不同，是最近开始看的，但这次再学习，和第一次时的感受完全不一样，对其中的大部分概念理解起来更加容易了，学习起来也相对轻松很多，全部都是干货，学得十分开心。通过课程内容标题大概能了解lecture具体的内容，根据自己在学习前端时遇到的问题，暂时只学习了 lecture1-lecture11 的内容。这里再推荐一个用JavaScript来描述排序算法的资源CS-JavaScript 哈佛大学-CS50(2011-有中文字幕):在网易云课堂里偶然发现的另一门入门教程，相对MIT的课程推荐的人会少一点。当时觉得可以通过看这些视频理解一些基本的概念，于是把一整个系列下载到了手机上，基本上是在碎片时间看的，所以也不算是很认真地看过。不过看了之后发现也是一门很好的课程，比如说在视频中提到了栈,变量的拷贝,引用等，知道了这些概念之后在JavaScript的学习过程中就特别注意到了这几点，也算是有点收获。 哈佛大学-CS50(2016-无中文字幕): 也是隔了一段时间后的第二次学习，同样也是看得更认真，对其中大部分内容比最初学习时理解更加轻松。 尽管3-6是四门课程，但实际上是两门课程的不同版本，推荐每门选择一个版本认真学习，不理解的内容可以暂时放一放迟一点再学习。虽然都是编程入门课程，但是两者的侧重点不同，所以不用怕内容会有重复，即使有小部分重复也可以帮助自己加深对一些概念的理解。如果刚开始学习时就能看懂大部分内容就在刚开始时认真看下来。如果和我一样最初阶段在理解上困难比较大，推荐学习了Udacity的CS101和一段时间的JavaScript之后再进行认真学习。 在学习MIT-CS101时的一点感悟 : 两次学习时的侧重点有所不同，第一次学习时把侧重点都放在了理解Python的语法以及代码的逻辑而不是编程的基础概念上 印象最深刻是第一次学习对实现Hanoi的代码几乎没有一行是理解的，觉得把实际问题转化成代码实在太难了，但是最近再去学习，理解上竟然一点困难都没有了。所以大家在学习时千万不要因为一时看不懂就放弃了！ 分享偶然看到的一句话: If you can’t solve a problem, then there is an easier problem you can’t solve: Find It. 所以学习应该是循序渐进的过程，现在不懂不代表以后不懂，把不懂的问题先放着，先去学习自己现在能够理解的知识，随着学习的深入，很可能你当时遇到的问题就不再是问题了。因此个人认为学习的材料应该在自己所掌握的知识之外，理解范围之内，在学习这样的材料时，既能学到知识，学习的热情和信心也会更高。因为在学习某些课程时，有些内容就算特别认真地看，很多概念也还是无法理解，所以可以将这些内容暂时放在一边，先学习自己理解能力范围之内的内容，等以后对不理解内容有过接触和了解之后再去学习相关内容。 JavaScript我学习JavaScript的方式是先学习一些相关的系列教程，然后总结出自己在学习过程中遇到的问题，和在一些知乎回答中总结出的JavaSript里比较难理解的概念进行深入学习。深入学习一般是先在一些权威书籍中找到这些概念进行学习，看了书之后还是无法理解就会在YouTube上找相关的内容，如果还是不够清楚就会在Google或者Stackoverflow上寻找相关答案。 下面推荐一些自己认为不错的JavaSript的系列教程，书籍以及YouTube频道。 书籍 《JavaScript编程精解(第二版）》: Eloquent JavaScript的中文译本，强烈建议购买，最好的入门书，没有之一。把很多概念讲的很明白，对初学者友好的同时又有一定的深度。把这本书称作入门书其实有点不恰当，因为这是一本在学习JavaScript过程中一直可以翻阅的书，覆盖的范围很广，从JavaScript的基础语法，函数式编程，面向对象编程，DOM，HTTP到Node.js…. 《JavaScript DOM编程艺术》: 也是一门很适合初学者的书，读完之后大概可以了解JavaScript的基础语法和DOM的相关知识。 《JavaScript面向对象编程指南(第2版)》 《你不知道的JavaScript(上卷)》: (中文版还有一本中卷，但是翻译得一般，所以不建议买中文版中卷, 这里是英文原版的github地址：You Don’t Know JS) 《JavaScript权威指南(第6版)》 《JavaScript语言精粹》 在看这些书时并不是一节一节看下来的，所以并没有把列举的这些书全部看完，不过这几本书翻得挺多的，在遇到难以理解的概念时先到这些书里找相关的内容。因为每本书对不同的概念的解释方式都有所不同，结合起来学习的效果会更好一些。而且这些都是比较权威的书籍，多看看这些书在学习时也能少花费一些精力。如果书里有代码可以自己一边敲一边学习，也能加深理解。 视频教程 Codecademy的JavaScript课程: 由于对基础概念一点都不了解，虽然当时刷完了，但从中收获不大，因为在利用这些交互式教程学习时，思维会很容易转换成为了完成任务而学习，而不是为了理解概念而学习。个人觉得在了解了一点基础知识之后再开始学习这种交互式的教程效果会更好一点，用来巩固知识和加深理解一些概念。当然这个教程本身是很好，只是学习时应该注意方法。 Code School的JavaScript课程: Code School的课程质量就不再细说了，个人觉得是自己在学习过程中看过的最完整的一个教程。 Udacity的JavaScript基础 Wesbos的JavaScript30: Wesbos的教程质量都很高，而且讲课很有趣，这个教程是通过30个实际项目来教授一些HTML5,CSS3,JavaScript相关的知识，是2016年末刚出的教程，所以我自己是最近才开始学习这个教程，不是在初学阶段学习。 JavaScript: Understanding the Weird Parts(付费) - Udemy: 个人觉得这套课程非常好，对JavaScript语言的介绍深入浅出，是自己很喜欢的一门课程，YouTube上有前3.5小时的课程内容，可以先看完再决定是否要购买。前3.5h链接 YouTube频道推荐这里选了几个学习时看得比较多的频道，大家有问题的时候可以直接在YouTube上搜索相关关键词，然后选择订阅量较多的频道和浏览量多的视频进行学习。 funfunfunction LearnCode.academy thenewboston LevelUpTuts Wes Bos kudvenkat JavaScript以及web开发中需要重点学习的知识点这部分的重点是列出知识点，因为都是比较零散的内容，所以下面的推荐学习内容只列出一部分，具体的学习还是需要根据自己的理解程度来安排，仅仅只学习推荐的学习内容是不够的，还是需要自己另外看书看教程直到真正理解。 闭包，this，作用域，原型链 JavaScript is Weird…and AWESOME 面向对象JavaScript - Udacity 当时学习过程中对这些概念的理解遇到比较大困难，花了挺长一段时间去消化，有些书反反复复翻了很多遍，相关视频也看了好几遍。不过虽然难理解，但花一些时间和精力下去还是可以掌握的，初次遇到觉得很难也不要害怕。看书很重要。 AJAX MDN-AJAX Intro to AJAX - Udacity 《锋利的jQuery》里面对AJAX的解释也十分详细 练习AJAX时可以使用的RESTful API JSON MDN-JSON Git Try Git - CodeSchool jQuery Try jQuery - CodeSchool:试过刚开始学习时就去看，可是一点都看不懂，所以不适合刚开始学习时看。建议学习一段时间的JavaScript之后再开始学习jQuery。 《锋利的jQuery》 Intro to JQuery - Udacity 之前推荐的YouTube Channel里有好几个都有jQuery教程，可以根据自己喜好在其中选择。 Event Event : 这个视频及其所在playlist接下来的4个视频都是Event的相关内容，整个playlist是一套JavaScript教程，由于自己是在对JavaScript有一些了解之后才发现的这套教程，所以并没有把全部教程看完，只看了自己有疑问的部分内容。个人觉得讲解得比较详细，全套教程应该也值得一看。 Internet相关知识: How the Internet Works for Developers - Pt 1 - Overview &amp; Frontend How the Internet Works for Developers - Pt 2 - Servers &amp; Scaling The Internet(这是一个playlist，把Internet费解的概念解释的很清楚，即使对相关知识完全不懂也会有挺大收获)初学推荐先看以下几个视频： 1. How The Internet Works in 10 Minutes 5. How Web Browsers Work 6. What is HTTP? 《HTTP权威指南》:在学习过程中遇到某些问题的时候可以先在这本书上查询。 ES6 视频教程: ES6 JavaScript(付费) - Udemy: 还是Udemy上的付费课程，个人很喜欢这门课程的老师，讲课讲得很不错，他在Udemy上的课程几乎都买了。 Learn ES6 (ECMAScript 2015) - egghead.io 文字教程(在学习过程中发现，自己暂时还没有全部学习过): ES6 Features ECMAScript 6 Tutorial ES6相关书籍 React选框架: 选择学习的框架之前也做了一些功课，找了一些网上的一些框架比较，初定是在React, Vue2中选择一个进行学习，最终选择了React。主要有两个原因，一是React的学习路线虽然相比Vue2更陡峭，但学到的知识会更多; 二是React的学习资源相比Vue2会更多。 教程: React-thenewboston React-CodeSchool(付费) React-The Net Ninja React-egghead.io The Ultimate Introduction to ReactJS:这个教程与其他教程有所不同,视频内容刚开始是用原生写一个Tic Tac Toe游戏，写完之后po主分析了用原生JS的弊端:用户的操作直接和DOM进行交互，很容易产生bug，比如点了游戏网格外的界面之后，整个页面就会被重写，因为这个点击直接修改了body的innerHTML。然后他分析了应该怎么做才能避免这些bug，整体思路就是一步一步把你往React的逻辑里带。 The Complete React Web App Developer Course(付费) - Udemy:覆盖的内容很多，老师讲课讲得很好，用的是React旧版的API讲解，所以没有完全跟着敲，自己在学习时是用新的API，遇到挺多问题，不过也学到更多，除了学习到ES6，对this的理解也有所加深。Udemy有一个好处就是在遇到问题时可以直接在网站上提问，老师一般在第二天就会解答。 Modern React with Redux(付费) - Udemy: 与前一位老师的讲课风格有差异，课程的侧重点也不同，所以两门课都值得购买。这门课程的老师还开了几门React相关的课程，有兴趣的同学可以自己在Udemy上找一下。 学习React时遇到的最大困难就是 生命周期函数 ，后来理解了之后想了想应该是自己对DOM的渲染没有深刻的理解。当时也看了挺多视频和文章，但是没有记下网址，不过大部分视频是在YouTube上找到的，大家可以直接在YouTube上搜索，根据浏览量和自己的喜好进行学习。 Node学习Node的方法和React很相似，都是先从YouTube上找相关的系列教程进行学习，但学习了一段时间之后，发现仅仅靠学习YouTube的教程只能达到入门水平，对很多抽象概念的理解(比如说stream, middleware, buffer,websocket等等)有比较大的困难，深入学习还是需要找另外的资源。于是开始找相关的书籍资源，国内Node的书不多，口碑最好的是朴灵老师的《深入浅出Node》。但是看了一部分之后发现自己暂时还没达到看懂这本书的水平。因此开始找其他的资源，在知乎上发现了一个比较不错的回答如何系统地学习Node.js？via @itlr.后来无意中又发现了Udemy这个视频网站，抱着试试看的心态买了两门课程，后来就入了Udemy的坑，也在上面发现很多好课程。上面回答中包含的资源这里就不再列举，下面列一些自己找到的资源。 Node-thenewboston Node-The Net Ninja Node-CodeSchool（付费） NodeSchool Learn and Understand NodeJS(付费) - Udemy The Complete Node.js Developer Course(付费) - Udemy (对Node的学习并没有特别深入，因为考虑到自己的时间问题，当下应该先专注前端的学习，所以学习了一段时间之后就暂时放着了，不过在学习Node的同时对JavaScript以及后端的一些知识也有了更深入的了解，收获很大。而且因为是JavaScript, 所以也学习得十分开心，准备等工作之后有时间再深入学习。） 其他 webpack webpack 2 Basics Tutorial webpack 2 vs Browserify/Grunt/Gulp/Rollup webpack 2 - A full tutorial webpack 2(付费) - Udemy 命令行: Command Line Power User - Wesbos Linux Command Line Basics - Udacity Markdown: Mastering Markdown - Wesbos 正则表达式 30分钟入门教程 工具推荐: Dev Docs: 查API，包括很多编程语言和框架，可以离线缓存，十分方便。 Duet Display: 在电脑和iPad上分别下载这个app，能够将iPad作为电脑的扩展屏，iPad上是付费版本，个人认为挺值的。 JSBin: 直接在网站上运行HTML,CSS,JS代码，需要运行一些简单代码时会比较方便，还能自己扩展library运行React或Vue等项目。同类型的网站还有jsfiddle和codepen。 The End","link":"/posts/2017/02/16/learning-web-dev-from-scratch/"},{"title":"Redux基础","text":"Redux是JavaScript应用的状态容器，为应用提供可预测的状态管理, 可以和许多JavaScript库结合使用, 如React, Angular, Ember。 Redux三大原则1.不管是多复杂的应用, 应用的state均保存在一个JavaScript对象中, 并且我们能够实时观察到state的变化. 2.state是只读的, 不可以直接改变它的值, 如果想要改变必须通过dispatch action进行, action也是一个JavaScript对象, 描述state的变化. 3.state改变均由reducer完成, reducer是纯函数, 在函数内需要声明根据action的不同, state是应该如何变化, 下面是一个reducer的例子: 12345678910 const counter = (state = 0, action) =&gt; { switch (action.type) { case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; }} counter接受两个参数, 初始state和action, 返回更新后的state, state根据不同的action.type变化. Redux store的三个重要方法利用Redux的createStore()方法可以创建store用以保存app的状态: 1const store = createStore(counter); store遵循了redux的三个基本原则: 保存应用当前的状态: getState()方法; 能够分发action: dispatch()方法; 创建store时需要声明reducer函数. store关联的三个重要方法分别是 getState() dispatch() subscribe() 在jsbin中的js和html区域中输入以下代码(将js区域的标准设置为ES6/Babel), 通过点击output的空白区域测试app的功能. 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445const counter = (state = 0, action) =&gt; { switch (action.type) { case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; }}const { createStore } = Redux;// ⬆️运用了ES6的解构(destructuring), 等同于: // var createStore = Redux.createStore;// ES6 module中这样引入:// import { createStore } from 'redux';//将reducer传入createStore函数中创建storeconst store = createStore(counter);// store关联了3个重要的方法: // 1. getState() 获取store中当前的stateconsole.log(store.getState());// 2. dispatch() 分发action, 并返回这个action, 是唯一能改变store中数据的方式store.dispatch({ type: 'INCREMENT'});console.log(store.getState());store.dispatch({ type: 'DECREMENT'});console.log(store.getState());// 3. subscribe() 注册监听函数, 在store发生变化时被调用const render = () =&gt; { document.body.innerText = store.getState();}store.subscribe(render);render();document.addEventListener('click', () =&gt; { store.dispatch({ type: 'INCREMENT'});}) html模板(后面几例均使用此模板):(同时加入了react和react-dom库以方便之后的app使用, 在Vanilla JS与redux结合完成的计数器app中并没有用到react库) 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width\"&gt; &lt;script src=\"https://unpkg.com/redux@latest/dist/redux.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://fb.me/react-15.1.0.js\"&gt;&lt;/script&gt; &lt;script src=\"https://fb.me/react-dom-15.1.0.js\"&gt;&lt;/script&gt; &lt;script src=\"https://unpkg.com/expect/umd/expect.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://wzrd.in/standalone/deep-freeze@latest\"&gt;&lt;/script&gt; &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id='root'&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; createStore以及三个重要方法的实现(简化版)示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const counter = (state = 0, action ) =&gt; { switch (action.type){ case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; }}const createStore = (reducer) =&gt; { let state; let listeners = []; // getState() const getState = () =&gt; state; // dispatch() const dispatch = (action) =&gt; { state = reducer(state, action); listeners.forEach(listener =&gt; listener()); }; // subscribe() const subscribe = (listener) =&gt; { listeners.push(listener); return () =&gt; { listeners = listeners.filter(l =&gt; l!== listener); // unsubscribe }; }; dispatch({}); // call it initially return { getState, dispatch, subscribe }; };const store = createStore(counter);const render = () =&gt; { document.body.innerText = store.getState();}store.subscribe(render);render();document.addEventListener('click',() =&gt; { store.dispatch( { type: 'INCREMENT' });}); subscribe()注册一个监听函数, 在store发生变化时被调用, 一般在与某个系统(如React)结合时使用, 上述例子中是与Vanilla JS结合使用, 将store的状态变化以数字的形式呈现在页面上.subscribe()方法返回的函数提供了unsubscribe的方法, 将某个监听函数从监听函数列表中移除, 这样的话, 如果想要unsubsribe某个监听函数, 可以进行如下操作: 123456let foo = () =&gt; {...};let unsubscribeFoo = store.subscribe(foo); // 之后若想要unsubscribe, 这样声明:unsubscribeFoo(); // 一旦该函数执行, store有变化时函数foo就不会被调用 Redux与React结合(基础)上一个例子中使用Vanilla JS直接操作DOM, 对性能不利, 下面介绍用React与Redux结合制作一个简单的计数器app的方法, html模板不变, 使用下面的js代码. 示例. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const counter = (state = 0, action) =&gt; { switch (action.type){ case 'INCREMENT': return state + 1; case 'DECREMENT': return state - 1; default: return state; }}const Counter = ({ value, onIncrement, onDecrement}) =&gt; { return ( &lt;div&gt; &lt;h1&gt;{value}&lt;/h1&gt; &lt;button onClick={onIncrement}&gt;+&lt;/button&gt; &lt;button onClick={onDecrement}&gt;-&lt;/button&gt; &lt;/div&gt; )};const { createStore } = Redux;const store = createStore(counter);const render = () =&gt; { ReactDOM.render( &lt;Counter value={store.getState()} onIncrement={() =&gt; store.dispatch({ type: 'INCREMENT' }) } onDecrement={() =&gt; store.dispatch({ type: 'DECREMENT' }) } /&gt;, document.getElementById('root') );};store.subscribe(render);render(); 分析以上计数器app, 将app分解为视图层和数据层. react负责两部分视图的渲染, 一是当前的计数值, 二是控制数字变化的部分, 即增加减少按钮. redux负责保存当前计数器的state, 即按钮被实际按下的次数, 以及当下的state应该如何渲染. Counter组件是dumb component, 不负责任何业务逻辑(business logic), 它的任务是说明当前store的state应该如何转化为可以被渲染的输出(value), 以及通过props传递的回调函数是如何与事件处理函数绑定的(onIncrement, onDecrement). 在render函数中, 我们将Counter组件渲染到页面中, 因此这里render函数关联了react库和redux库, 将redux负责的state渲染到react库负责的视图中. 其中value值渲染的是当前的状态, 然后根据用户点击的不同按钮dispatch不同的action, 点击按钮’+’时, dispatch的action是’INCREMENT’, state值就增加1, 因为通过store.subscribe(render)声明Counter中value属性值需要根据store中state的变化而变化, 因此value值就会增加1, 页面上的显示的数字自然也加上1. combineReducers简单实现(updated at 2017-09-13) 1234567891011121314const combineReducers = (reducers) =&gt; { return (state = {}, action) =&gt; { return Object.keys(reducers).reduce( (nextState, key) =&gt; { nextState[key] = reducers[key]( state[key], action ); return nextState; }, {} ); };}; combineReducers接受的参数是 mapping key-value 返回一个reducer函数 React Redux TodoList原始版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194const todo = (state, action) =&gt; { switch (action.type) { case 'ADD_TODO': return { id: action.id, text: action.text, completed: false }; case 'TOGGLE_TODO': if (state.id !== action.id) { return state; } return { ...state, completed: !state.completed }; default: return state; }};const todos = (state = [], action) =&gt; { switch (action.type) { case 'ADD_TODO': return [ ...state, todo(undefined, action) ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action) ); default: return state; }};// reducer 接受 state 和 actionconst visibilityFilter = ( state = 'SHOW_ALL', action) =&gt; { switch (action.type) { case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; }};const { combineReducers } = Redux;const todoApp = combineReducers({ todos, visibilityFilter});const { createStore } = Redux;const store = createStore(todoApp);const { Component } = React;// FilterLink react component const FilterLink = ({ filter, currentFilter, children}) =&gt; { if(filter === currentFilter){ return &lt;span&gt;{children}&lt;/span&gt; } return ( &lt;a href=\"#\" onClick={e =&gt; { e.preventDefault(); store.dispatch({ type: 'SET_VISIBILITY_FILTER', filter }); }} &gt; {children} &lt;/a&gt; )};// getVisbleTodos : helper functionconst getVisibleTodos = ( todos, filter) =&gt; { switch (filter) { case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter( t =&gt; t.completed ); case 'SHOW_ACTIVE': return todos.filter( t =&gt; !t.completed ); }}let nextTodoId = 0;class TodoApp extends Component { render() { const { todos, visibilityFilter } = this.props; const visibleTodos = getVisibleTodos( todos, visibilityFilter ); return ( &lt;div&gt; &lt;input ref={node =&gt; { this.input = node; }} /&gt; &lt;button onClick={() =&gt; { store.dispatch({ type: 'ADD_TODO', text: this.input.value, id: nextTodoId++ }); this.input.value = ''; }}&gt; Add Todo &lt;/button&gt; &lt;ul&gt; {visibleTodos.map(todo =&gt; &lt;li key={todo.id} onClick={() =&gt; { store.dispatch({ type: 'TOGGLE_TODO', id: todo.id }); }} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}&gt; {todo.text} &lt;/li&gt; )} &lt;/ul&gt; &lt;p&gt; Show: {' '} &lt;FilterLink filter=\"SHOW_ALL\" currentFilter={visibilityFilter} &gt; All &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_ACTIVE\" currentFilter={visibilityFilter} &gt; Active &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_COMPLETED\" currentFilter={visibilityFilter} &gt; Completed &lt;/FilterLink&gt; &lt;/p&gt; &lt;/div&gt; ) };}// See Section 8 for earlier `render()` exampleconst render = () =&gt; { ReactDOM.render( // Render the TodoApp Component to the &lt;div&gt; with id 'root' &lt;TodoApp {...store.getState()} /&gt;, document.getElementById('root') )};store.subscribe(render);render(); 提取 presentational componentspresentational components: Todo, TodoList, AddTodo, Footer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242const todo = (state, action) =&gt; { switch (action.type) { case 'ADD_TODO': return { id: action.id, text: action.text, completed: false }; case 'TOGGLE_TODO': if (state.id !== action.id) { return state; } return { ...state, completed: !state.completed }; default: return state; }};const todos = (state = [], action) =&gt; { switch (action.type) { case 'ADD_TODO': return [ ...state, todo(undefined, action) ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action) ); default: return state; }};// reducer 接受 state 和 actionconst visibilityFilter = ( state = 'SHOW_ALL', action) =&gt; { switch (action.type) { case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; }};const { combineReducers } = Redux;const todoApp = combineReducers({ todos, visibilityFilter});const { createStore } = Redux;const store = createStore(todoApp);const { Component } = React;// FilterLink react component const FilterLink = ({ filter, currentFilter, children, onClick}) =&gt; { if(filter === currentFilter){ return &lt;span&gt;{children}&lt;/span&gt; } return ( &lt;a href=\"#\" onClick={e =&gt; { e.preventDefault(); onClick(filter) }} &gt; {children} &lt;/a&gt; )};const Todo = ({ onClick, completed, text}) =&gt; ( &lt;li onClick={onClick} style={{ textDecoration: completed ? 'line-through' : 'none' }}&gt; {text} &lt;/li&gt;);const TodoList = ({ todos, onTodoClick}) =&gt; ( &lt;ul&gt; {todos.map(todo =&gt; &lt;Todo key={todo.id} {...todo} onClick={() =&gt; onTodoClick(todo.id)} /&gt; )} &lt;/ul&gt;);const AddTodo = ({ onAddClick}) =&gt; { let input; return ( &lt;div&gt; &lt;input ref={node =&gt; { input = node; }} /&gt; &lt;button onClick={() =&gt; { onAddClick(input.value); input.value = \"\"; }}&gt; Add Todo &lt;/button&gt; &lt;/div&gt; );};const Footer = ({ visibilityFilter, onFilterClick}) =&gt; ( &lt;p&gt; Show: {' '} &lt;FilterLink filter=\"SHOW_ALL\" currentFilter={visibilityFilter} onClick={onFilterClick} &gt; All &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_ACTIVE\" currentFilter={visibilityFilter} onClick={onFilterClick} &gt; Active &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_COMPLETED\" currentFilter={visibilityFilter} onClick={onFilterClick} &gt; Completed &lt;/FilterLink&gt; &lt;/p&gt;)// getVisbleTodos : helper functionconst getVisibleTodos = ( todos, filter) =&gt; { switch (filter) { case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter( t =&gt; t.completed ); case 'SHOW_ACTIVE': return todos.filter( t =&gt; !t.completed ); }}let nextTodoId = 0;const TodoApp = ({ todos, visibilityFilter}) =&gt; ( &lt;div&gt; &lt;AddTodo onAddClick = {text =&gt; store.dispatch({ type: 'ADD_TODO', id: nextTodoId++, text }) } /&gt; &lt;TodoList todos={ getVisibleTodos( todos, visibilityFilter ) } onTodoClick={id =&gt; store.dispatch({ type: 'TOGGLE_TODO', id }) } /&gt; &lt;Footer visibilityFilter={visibilityFilter} onFilterClick={filter =&gt; store.dispatch({ type: 'SET_VISIBILITY_FILTER', filter }) }/&gt; &lt;/div&gt;);// See Section 8 for earlier `render()` exampleconst render = () =&gt; { ReactDOM.render( // Render the TodoApp Component to the &lt;div&gt; with id 'root' &lt;TodoApp {...store.getState()} /&gt;, document.getElementById('root') )};store.subscribe(render);render(); store变化 todoApp 重新渲染, store 中 todos, visibilityFilter 属性 首先渲染第一个组件 AddTodo, AddTodo 是presentational component 含有input 和 button 元素 点击button 后调用 onAddClick函数, onAddClick是 AddTodo 组件的prop, specified by TodoApp, 当button click之后, dispatch 一个action type为ADD_TODO, 调用reducer更新全局store, 重新渲染todoApp组件, todoItem本身由todolist 展示组件控制, 由两个属性控制, 可见的todos以及onTodoClick函数, todolist 函数接受todos数组 分别渲染到Todo组件中, 使用…传递todo的属性到Todo组件 提取 container componentsFilterLink, VisibleTodoList, AddTodo container 连接 presentational component 和 redux store, 使用container component 避免在组件中传递太多属性导致混乱 decouple from behavior and data that its child components needed specify the data and behavior that it need render method 里使用state 因此需要forceUpdate containers 不再需要来自 state 的 props 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274const todo = (state, action) =&gt; { switch (action.type) { case 'ADD_TODO': return { id: action.id, text: action.text, completed: false }; case 'TOGGLE_TODO': if (state.id !== action.id) { return state; } return { ...state, completed: !state.completed }; default: return state; }};const todos = (state = [], action) =&gt; { switch (action.type) { case 'ADD_TODO': return [ ...state, todo(undefined, action) ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action) ); default: return state; }};// reducer 接受 state 和 actionconst visibilityFilter = ( state = 'SHOW_ALL', action) =&gt; { switch (action.type) { case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; }};const { combineReducers } = Redux;const todoApp = combineReducers({ todos, visibilityFilter});const { createStore } = Redux;const store = createStore(todoApp);const { Component } = React;const Todo = ({ onClick, completed, text}) =&gt; ( &lt;li onClick={onClick} style={{ textDecoration: completed ? 'line-through' : 'none' }}&gt; {text} &lt;/li&gt;);const TodoList = ({ todos, onTodoClick}) =&gt; ( &lt;ul&gt; {todos.map(todo =&gt; &lt;Todo key={todo.id} {...todo} onClick={() =&gt; onTodoClick(todo.id)} /&gt; )} &lt;/ul&gt;);// 难界定AddTodo是presentational 还是 container, 因为input 和 button 都是处理UI 而button 中的 onClick 属性dispatch action. // 因为是比较简单的处理 所以混杂了这两者 逻辑复杂之后再分离. const AddTodo = () =&gt; { let input; return ( &lt;div&gt; &lt;input ref={node =&gt; { input = node; }} /&gt; &lt;button onClick={() =&gt; { store.dispatch({ type: 'ADD_TODO', id: nextTodoId++, text: input.value }) input.value = \"\"; }}&gt; Add Todo &lt;/button&gt; &lt;/div&gt; );};// Presentaional component - Linkconst Link = ({ active, children, onClick}) =&gt; { if(active){ return &lt;span&gt;{children}&lt;/span&gt; } return ( &lt;a href=\"#\" onClick={e =&gt; { e.preventDefault(); onClick() }} &gt; {children} &lt;/a&gt; )};// container component - FilterLinkclass FilterLink extends Component { // dispatch了action但是state不会自动更新 因此forceUpfate() componentDidMount() { this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); // save the reference to the unsubscribe function } componentWillUnmount() { this.unsubscribe(); } render() { const props = this.props; const state = store.getState(); return ( &lt;Link active={ props.filter === state.visibilityFilter } onClick = {() =&gt; store.dispatch({ type: 'SET_VISIBILITY_FILTER', filter: props.filter }) } &gt; {props.children} &lt;/Link&gt; ) }}// presentational componentconst Footer = () =&gt; ( &lt;p&gt; Show: {' '} &lt;FilterLink filter=\"SHOW_ALL\" &gt; All &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_ACTIVE\"x &gt; Active &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_COMPLETED\" &gt; Completed &lt;/FilterLink&gt; &lt;/p&gt;)// getVisbleTodos : helper functionconst getVisibleTodos = ( todos, filter) =&gt; { switch (filter) { case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter( t =&gt; t.completed ); case 'SHOW_ACTIVE': return todos.filter( t =&gt; !t.completed ); }}class VisibleTodoList extends Component { // dispatch了action但是state不会自动更新 因此forceUpfate() componentDidMount() { this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); // save the reference to the unsubscribe function } componentWillUnmount() { this.unsubscribe(); } render() { const props = this.props; const state = store.getState(); return ( &lt;TodoList todos={ getVisibleTodos( state.todos, state.visibilityFilter ) } onTodoClick={id =&gt; store.dispatch({ type: 'TOGGLE_TODO', id }) }/&gt; ) } }let nextTodoId = 0;const TodoApp = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;); ReactDOM.render( &lt;TodoApp /&gt;, document.getElementById('root'))// container components it render are going to subscribe to the store themselves, 因此, 不需要再手动 subscribe render pass store down explicitly via props以上方法直接利用以下方式处理store的数据: 1234567891011121314151617181920// 获取storestore.getState(); // 更新storecomponentDidMount() { this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); // save the reference to the unsubscribe function}componentWillUnmount() { this.unsubscribe();}// dispatch actionstore.dispatch({ type: 'TOGGLE_TODO', id}) 在一个JS文件中比较方便, 但是 container component 难测试, reference to a specific store, 难 mock store 难以实现 universal 应用, server 对于每个不同请求提供不同的 store 实例, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281const todo = (state, action) =&gt; { switch (action.type) { case 'ADD_TODO': return { id: action.id, text: action.text, completed: false }; case 'TOGGLE_TODO': if (state.id !== action.id) { return state; } return { ...state, completed: !state.completed }; default: return state; }};const todos = (state = [], action) =&gt; { switch (action.type) { case 'ADD_TODO': return [ ...state, todo(undefined, action) ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action) ); default: return state; }};// reducer 接受 state 和 actionconst visibilityFilter = ( state = 'SHOW_ALL', action) =&gt; { switch (action.type) { case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; }};const { combineReducers } = Redux;const todoApp = combineReducers({ todos, visibilityFilter});const { Component } = React;const Todo = ({ onClick, completed, text}) =&gt; ( &lt;li onClick={onClick} style={{ textDecoration: completed ? 'line-through' : 'none' }}&gt; {text} &lt;/li&gt;);const TodoList = ({ todos, onTodoClick}) =&gt; ( &lt;ul&gt; {todos.map(todo =&gt; &lt;Todo key={todo.id} {...todo} onClick={() =&gt; onTodoClick(todo.id)} /&gt; )} &lt;/ul&gt;);// 难界定AddTodo是presentational 还是 container, 因为input 和 button 都是处理UI 而button 中的 onClick 属性dispatch action. // 因为是比较简单的处理 所以混杂了这两者 逻辑复杂之后再分离. const AddTodo = ({ store }) =&gt; { let input; return ( &lt;div&gt; &lt;input ref={node =&gt; { input = node; }} /&gt; &lt;button onClick={() =&gt; { store.dispatch({ type: 'ADD_TODO', id: nextTodoId++, text: input.value }) input.value = \"\"; }}&gt; Add Todo &lt;/button&gt; &lt;/div&gt; );};// Presentaional component - Linkconst Link = ({ active, children, onClick}) =&gt; { if(active){ return &lt;span&gt;{children}&lt;/span&gt; } return ( &lt;a href=\"#\" onClick={e =&gt; { e.preventDefault(); onClick() }} &gt; {children} &lt;/a&gt; )};// container component - FilterLinkclass FilterLink extends Component { // dispatch了action但是state不会自动更新 因此forceUpfate() componentDidMount() { const { store } = this.props; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); // save the reference to the unsubscribe function } componentWillUnmount() { this.unsubscribe(); } render() { const props = this.props; const { store } = props; const state = store.getState(); return ( &lt;Link active={ props.filter === state.visibilityFilter } onClick = {() =&gt; store.dispatch({ type: 'SET_VISIBILITY_FILTER', filter: props.filter }) } &gt; {props.children} &lt;/Link&gt; ) }}// presentational componentconst Footer = ({ store }) =&gt; ( &lt;p&gt; Show: {' '} &lt;FilterLink filter=\"SHOW_ALL\" store={store} &gt; All &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_ACTIVE\" store={store} &gt; Active &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_COMPLETED\" store={store} &gt; Completed &lt;/FilterLink&gt; &lt;/p&gt;)// getVisbleTodos : helper functionconst getVisibleTodos = ( todos, filter) =&gt; { switch (filter) { case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter( t =&gt; t.completed ); case 'SHOW_ACTIVE': return todos.filter( t =&gt; !t.completed ); }}class VisibleTodoList extends Component { componentDidMount() { // 现在使用 this.props.store 获取 store 内的数据 const { store } = this.props; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); // save the reference to the unsubscribe function } componentWillUnmount() { this.unsubscribe(); } render() { const props = this.props; const { store } = props; const state = store.getState(); return ( &lt;TodoList todos={ getVisibleTodos( state.todos, state.visibilityFilter ) } onTodoClick={id =&gt; store.dispatch({ type: 'TOGGLE_TODO', id }) }/&gt; ) } }let nextTodoId = 0;// every container component needs a reference to the storeconst TodoApp = ({ store }) =&gt; ( &lt;div&gt; &lt;AddTodo store={store} /&gt; &lt;VisibleTodoList store={store}/&gt; &lt;Footer store={store}/&gt; &lt;/div&gt;);const { createStore } = Redux;ReactDOM.render( &lt;TodoApp store = {createStore(todoApp)}/&gt;, document.getElementById('root')) pass the store down implicitly via context123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312const todo = (state, action) =&gt; { switch (action.type) { case 'ADD_TODO': return { id: action.id, text: action.text, completed: false }; case 'TOGGLE_TODO': if (state.id !== action.id) { return state; } return { ...state, completed: !state.completed }; default: return state; }};const todos = (state = [], action) =&gt; { switch (action.type) { case 'ADD_TODO': return [ ...state, todo(undefined, action) ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action) ); default: return state; }};// reducer 接受 state 和 actionconst visibilityFilter = ( state = 'SHOW_ALL', action) =&gt; { switch (action.type) { case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; }};const { combineReducers } = Redux;const todoApp = combineReducers({ todos, visibilityFilter});const { Component } = React;const Todo = ({ onClick, completed, text}) =&gt; ( &lt;li onClick={onClick} style={{ textDecoration: completed ? 'line-through' : 'none' }}&gt; {text} &lt;/li&gt;);const TodoList = ({ todos, onTodoClick}) =&gt; ( &lt;ul&gt; {todos.map(todo =&gt; &lt;Todo key={todo.id} {...todo} onClick={() =&gt; onTodoClick(todo.id)} /&gt; )} &lt;/ul&gt;);let nextTodoId = 0;const AddTodo = (props, { store }) =&gt; { // context.store let input; return ( &lt;div&gt; &lt;input ref={node =&gt; { input = node; }} /&gt; &lt;button onClick={() =&gt; { store.dispatch({ type: 'ADD_TODO', id: nextTodoId++, text: input.value }) input.value = \"\"; }}&gt; Add Todo &lt;/button&gt; &lt;/div&gt; );};AddTodo.contextTypes = { store: React.PropTypes.object};// Presentaional component - Linkconst Link = ({ active, children, onClick}) =&gt; { if(active){ return &lt;span&gt;{children}&lt;/span&gt; } return ( &lt;a href=\"#\" onClick={e =&gt; { e.preventDefault(); onClick() }} &gt; {children} &lt;/a&gt; )};// container component - FilterLinkclass FilterLink extends Component { // dispatch了action但是state不会自动更新 因此forceUpfate() componentDidMount() { const { store } = this.context; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); // save the reference to the unsubscribe function } componentWillUnmount() { this.unsubscribe(); } render() { const props = this.props; const { store } = this.context; const state = store.getState(); return ( &lt;Link active={ props.filter === state.visibilityFilter } onClick = {() =&gt; store.dispatch({ type: 'SET_VISIBILITY_FILTER', filter: props.filter }) } &gt; {props.children} &lt;/Link&gt; ) }}FilterLink.contextTypes = { store: React.PropTypes.object};// presentational componentconst Footer = () =&gt; ( &lt;p&gt; Show: {' '} &lt;FilterLink filter=\"SHOW_ALL\" &gt; All &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_ACTIVE\" &gt; Active &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_COMPLETED\" &gt; Completed &lt;/FilterLink&gt; &lt;/p&gt;)// getVisbleTodos : helper functionconst getVisibleTodos = ( todos, filter) =&gt; { switch (filter) { case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter( t =&gt; t.completed ); case 'SHOW_ACTIVE': return todos.filter( t =&gt; !t.completed ); }}class VisibleTodoList extends Component { componentDidMount() { // 现在使用 this.props.store 获取 store 内的数据 const { store } = this.context; this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate() ); // save the reference to the unsubscribe function } componentWillUnmount() { this.unsubscribe(); } render() { const props = this.props; const { store } = this.context; const state = store.getState(); return ( &lt;TodoList todos={ getVisibleTodos( state.todos, state.visibilityFilter ) } onTodoClick={id =&gt; store.dispatch({ type: 'TOGGLE_TODO', id }) }/&gt; ) } }VisibleTodoList.contextTypes = { // must store: React.PropTypes.object};// every container component needs a reference to the storeconst TodoApp = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;);class Provider extends Component { // 利用 react context pass redux store 到所有 children component 包括 grandchildren...(work at any depth) getChildContext() { return { store: this.props.store }; } render() { // render whatever you provide to it return this.props.children; }}Provider.childContextTypes = { // must be specified for store to be passed by context store: React.PropTypes.object};const { createStore } = Redux;ReactDOM.render( &lt;Provider store = {createStore(todoApp)}&gt; &lt;TodoApp /&gt; &lt;/Provider&gt;, document.getElementById('root')) // context 很方便 但是违反了 React 所遵循的 explicit data flow 的原则// context 提供了一个全局变量以便 React 组件获取 redux store 内的值, 但是提供全局变量并不是一个好办法, 除非用于 dependency injection, 否则不要轻易使用 context; 同时 context API 不稳定 不要太过依赖 context React-Redux Providerreact-redux库 提供了Provider &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/react-redux/5.0.6/react-redux.min.js&quot;&gt;&lt;/script&gt; 1const { Provider } = ReactRedux; 替换: 1234567891011121314151617class Provider extends Component { // 利用 react context pass redux store 到所有 children component 包括 grandchildren...(work at any depth) getChildContext() { return { store: this.props.store }; } render() { // render whatever you provide to it return this.props.children; }}Provider.childContextTypes = { // must be specified for store to be passed by context store: React.PropTypes.object}; Generate Containers with connectconnect, mapStateToProps, mapDispatchToProps 如果每个component在不同文件中, 就可以直接使用mapStateToProps, mapDispatchToProps 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276const todo = (state, action) =&gt; { switch (action.type) { case 'ADD_TODO': return { id: action.id, text: action.text, completed: false }; case 'TOGGLE_TODO': if (state.id !== action.id) { return state; } return { ...state, completed: !state.completed }; default: return state; }};const todos = (state = [], action) =&gt; { switch (action.type) { case 'ADD_TODO': return [ ...state, todo(undefined, action) ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action) ); default: return state; }};// reducer 接受 state 和 actionconst visibilityFilter = ( state = 'SHOW_ALL', action) =&gt; { switch (action.type) { case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; }};const { combineReducers } = Redux;const todoApp = combineReducers({ todos, visibilityFilter});const { Component } = React;const Todo = ({ onClick, completed, text}) =&gt; ( &lt;li onClick={onClick} style={{ textDecoration: completed ? 'line-through' : 'none' }}&gt; {text} &lt;/li&gt;);const TodoList = ({ todos, onTodoClick}) =&gt; ( &lt;ul&gt; {todos.map(todo =&gt; &lt;Todo key={todo.id} {...todo} onClick={() =&gt; onTodoClick(todo.id)} /&gt; )} &lt;/ul&gt;);const { connect } = ReactRedux;// connect()() 返回 containerlet nextTodoId = 0;let AddTodo = ({ dispatch }) =&gt; { // context.store let input; return ( &lt;div&gt; &lt;input ref={node =&gt; { input = node; }} /&gt; &lt;button onClick={() =&gt; { dispatch({ type: 'ADD_TODO', id: nextTodoId++, text: input.value }) input.value = \"\"; }}&gt; Add Todo &lt;/button&gt; &lt;/div&gt; );};AddTodo = connect()(AddTodo); //null, null: default behavior: inject just dispatch function, not subscribe to the store// Presentational component - Linkconst Link = ({ active, children, onClick}) =&gt; { if(active){ return &lt;span&gt;{children}&lt;/span&gt; } return ( &lt;a href=\"#\" onClick={e =&gt; { e.preventDefault(); onClick() }} &gt; {children} &lt;/a&gt; )};const mapStateToLinkProps = ( state, ownProps) =&gt; { return { active: ownProps.filter === state.visibilityFilter };};const mapDispatchToLinkProps = ( dispatch, ownProps) =&gt; { return { onClick: () =&gt; dispatch({ type: 'SET_VISIBILITY_FILTER', filter: ownProps.filter }) };}const FilterLink = connect( mapStateToLinkProps, mapDispatchToLinkProps)(Link);// presentational componentconst Footer = () =&gt; ( &lt;p&gt; Show: {' '} &lt;FilterLink filter=\"SHOW_ALL\" &gt; All &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_ACTIVE\" &gt; Active &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_COMPLETED\" &gt; Completed &lt;/FilterLink&gt; &lt;/p&gt;)// getVisbleTodos : helper functionconst getVisibleTodos = ( todos, filter) =&gt; { switch (filter) { case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter( t =&gt; t.completed ); case 'SHOW_ACTIVE': return todos.filter( t =&gt; !t.completed ); }}// takes state, return the props to the presentational components, props会在state变化的时候自动更新. // map redux store to the props of TodoList componentconst mapStateToTodoListProps = (state) =&gt; { return { todos: getVisibleTodos( state.todos, state.visibilityFilter ) };};// map redux store to the callback props of TodoList componentconst mapDispatchToTodoListProps = (dispatch) =&gt; { return { onTodoClick: (id) =&gt; { dispatch({ type: 'TOGGLE_TODO', id }) } };};const VisibleTodoList = connect( mapStateToTodoListProps, mapDispatchToTodoListProps)(TodoList);// curried function that needs to be called twice // TodoList is the presentational component I want to pass the state to, 不再需要手动subscribe, unsubscribe, 也不用声明 propType, connect handles them for us// every container component needs a reference to the storeconst TodoApp = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;);const { Provider } = ReactRedux;const { createStore } = Redux;ReactDOM.render( &lt;Provider store = {createStore(todoApp)}&gt; &lt;TodoApp /&gt; &lt;/Provider&gt;, document.getElementById('root')) Extract Action Creators123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293const todo = (state, action) =&gt; { switch (action.type) { case 'ADD_TODO': return { id: action.id, text: action.text, completed: false }; case 'TOGGLE_TODO': if (state.id !== action.id) { return state; } return { ...state, completed: !state.completed }; default: return state; }};const todos = (state = [], action) =&gt; { switch (action.type) { case 'ADD_TODO': return [ ...state, todo(undefined, action) ]; case 'TOGGLE_TODO': return state.map(t =&gt; todo(t, action) ); default: return state; }};// reducer 接受 state 和 actionconst visibilityFilter = ( state = 'SHOW_ALL', action) =&gt; { switch (action.type) { case 'SET_VISIBILITY_FILTER': return action.filter; default: return state; }};const { combineReducers } = Redux;const todoApp = combineReducers({ todos, visibilityFilter});const { Component } = React;const Todo = ({ onClick, completed, text}) =&gt; ( &lt;li onClick={onClick} style={{ textDecoration: completed ? 'line-through' : 'none' }}&gt; {text} &lt;/li&gt;);const TodoList = ({ todos, onTodoClick}) =&gt; ( &lt;ul&gt; {todos.map(todo =&gt; &lt;Todo key={todo.id} {...todo} onClick={() =&gt; onTodoClick(todo.id)} /&gt; )} &lt;/ul&gt;);const { connect } = ReactRedux;// connect()() 返回 containerlet nextTodoId = 0;// extract actionCreators from componentsconst addTodo = (text) =&gt; { return { type: 'ADD_TODO', id: nextTodoId++, text };};const toggleTodo = (id) =&gt; { return { type: 'TOGGLE_TODO', id };};const setVisibilityFilter = (filter) =&gt; { return { type: 'SET_VISIBILITY_FILTER', filter };};let AddTodo = ({ dispatch }) =&gt; { // context.store let input; return ( &lt;div&gt; &lt;input ref={node =&gt; { input = node; }} /&gt; &lt;button onClick={() =&gt; { dispatch(addTodo(input.value)); input.value = \"\"; }}&gt; Add Todo &lt;/button&gt; &lt;/div&gt; );};AddTodo = connect()(AddTodo); //null, null: default behavior: inject just dispatch function, not subscribe to the store// Presentational component - Linkconst Link = ({ active, children, onClick}) =&gt; { if(active){ return &lt;span&gt;{children}&lt;/span&gt; } return ( &lt;a href=\"#\" onClick={e =&gt; { e.preventDefault(); onClick() }} &gt; {children} &lt;/a&gt; )};const mapStateToLinkProps = ( state, ownProps) =&gt; { return { active: ownProps.filter === state.visibilityFilter };};const mapDispatchToLinkProps = ( dispatch, ownProps) =&gt; { return { onClick: () =&gt; { dispatch( setVisibilityFilter(ownProps.filter) ); } };}const FilterLink = connect( mapStateToLinkProps, mapDispatchToLinkProps)(Link);// presentational componentconst Footer = () =&gt; ( &lt;p&gt; Show: {' '} &lt;FilterLink filter=\"SHOW_ALL\" &gt; All &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_ACTIVE\" &gt; Active &lt;/FilterLink&gt; {' '} &lt;FilterLink filter=\"SHOW_COMPLETED\" &gt; Completed &lt;/FilterLink&gt; &lt;/p&gt;)// getVisbleTodos : helper functionconst getVisibleTodos = ( todos, filter) =&gt; { switch (filter) { case 'SHOW_ALL': return todos; case 'SHOW_COMPLETED': return todos.filter( t =&gt; t.completed ); case 'SHOW_ACTIVE': return todos.filter( t =&gt; !t.completed ); }}// takes state, return the props to the presentational components, props会在state变化的时候自动更新. // map redux store to the props of TodoList componentconst mapStateToTodoListProps = (state) =&gt; { return { todos: getVisibleTodos( state.todos, state.visibilityFilter ) };};// map redux store to the callback props of TodoList componentconst mapDispatchToTodoListProps = (dispatch) =&gt; { return { onTodoClick: (id) =&gt; { dispatch(toggleTodo(id)) } };};const VisibleTodoList = connect( mapStateToTodoListProps, mapDispatchToTodoListProps)(TodoList);// curried function that needs to be called twice // TodoList is the presentational component I want to pass the state to, 不再需要手动subscribe, unsubscribe, 也不用声明 propType, connect handles them for us// every container component needs a reference to the storeconst TodoApp = () =&gt; ( &lt;div&gt; &lt;AddTodo /&gt; &lt;VisibleTodoList /&gt; &lt;Footer /&gt; &lt;/div&gt;);const { Provider } = ReactRedux;const { createStore } = Redux;ReactDOM.render( &lt;Provider store = {createStore(todoApp)}&gt; &lt;TodoApp /&gt; &lt;/Provider&gt;, document.getElementById('root')) 参考 Getting Started with Redux Redux: Implementing store from scratch - article Implementing store from scratch - Video","link":"/posts/2017/04/12/redux-basics/"}],"tags":[],"categories":[]}